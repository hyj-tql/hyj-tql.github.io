<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解 P3645 【[APIO2015]雅加达的摩天楼】]]></title>
    <url>%2F2019%2F05%2F26%2F%E9%A2%98%E8%A7%A3%20P3645%20%E3%80%90%5BAPIO2015%5D%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有$m$只$doge$分布在$n$个摩天大楼上。楼和$doge$都是从$0$开始编号。 每只$doge$初始位置$b[i]$，弹跳力$p[i]$。 它每一次跳会恰好跳$p[i]$个大楼。比如从$x$可以到$x±p[i]$。 现在，$0$号$doge$要把某信息传给$1$号$doge$。对于一只$doge$，若它尚未知道信息，就不能动。 对于一只$doge$，若它已经知道信息，可以选择把信息告诉处于同一位置的$doge$们，或者跳去别的位置。 求最少跳的步数。 $Solution$先考虑暴力 对于每一只$doge$，我们从$b[i]$ 连边到所有它可以跳到（可以跳好多步）的位置，边权为需要跳的次数。 从$b[0]$跑一下最短路即可。 但是，这样边数太多了。 那么考虑一下分块，把每一座摩天大楼拆成$O(\sqrt{n})$层，第$0$层表示原点,第$j$层代表一步能跳到$b[i]±j$的摩天大楼，如果某座摩天大楼的$p[i]&gt;size$则暴力从该摩天大楼的原点向$b[i]±j$的摩天大楼的原点连边，然后这一层每一个摩天大楼向它能到达的摩天大楼的相同层连双向边，并且每座摩天大楼的每一层都要向该摩天大楼的原点连边，可以保证边数在$n\sqrt{n}$级别左右(视$n,m$同阶) $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 6000020#define M 6000020using namespace std;struct edge&#123; int dis,to,next;&#125;e[M*9];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt,head[N],dis[N],inque[N],b[N],p[N],n,m;inline int id(int x,int y)&#123; return y*n+x;&#125;inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt;&#125;void spfa(int s)&#123; memset(dis,0x3f,sizeof(dis)); dis[s]=0;queue&lt;int&gt;q;q.push(s); while (!q.empty())&#123; int u=q.front();inque[u]=0;q.pop(); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (dis[v]&gt;dis[u]+e[i].dis)&#123; dis[v]=dis[u]+e[i].dis; if (!inque[v])q.push(v),inque[v]=1; &#125; &#125; &#125;&#125;signed main()&#123; n=read(),m=read();int size=sqrt(n/3); for (int i=0;i&lt;m;++i)&#123; b[i]=read(),p[i]=read(); if (p[i]&gt;size)&#123;//大于size的直接暴力连,边数最多m*sqrt(n)条 for (int d=1,j=b[i]-p[i];j&gt;=0;++d,j-=p[i]) add(id(b[i],0),id(j,0),d); for (int d=1,j=b[i]+p[i];j&lt;n;++d,j+=p[i]) add(id(b[i],0),id(j,0),d); &#125;else&#123; add(id(b[i],0),id(b[i],p[i]),0);//从每层原点向第p[i]层连边，表示b[i]这个摩天大楼可以跳到b[i]±j的摩天大楼 &#125; &#125; for (int j=1;j&lt;=size;++j)&#123; for (int i=0;i&lt;n;++i)&#123; if (i+j&lt;n) add(id(i,j),id(i+j,j),1); if (i-j&gt;=0)add(id(i,j),id(i-j,j),1); add(id(i,j),id(i,0),0); &#125; &#125; spfa(id(b[0],0)); if (dis[id(b[1],0)]&gt;=inf)puts("-1"); else printf("%d\n",dis[id(b[1],0)]); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>连边优化</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3604 【美好的每一天】]]></title>
    <url>%2F2019%2F05%2F25%2F%E9%A2%98%E8%A7%A3%20P3604%20%E3%80%90%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$一个区间如果满足区间内的值重排之后可以成为一个回文串，则这个区间可以回归天空 当前有$m$个区间，要求每个区间中有多少个子区间可以回归天空 $Solution$很容易想到是莫队题，但是对于维护区间贡献很难处理。 由于区间内的字符都是小写字母，考虑用$2$的幂次表示，如$’a’$表示为$2^0$,$’b’$表示为$2^1$,$’z’$表示为$2^{25}$(用$2$的幂次表示的原因下会讲) 然后考虑一个区间$[l,r]$对答案有贡献当且仅当$a_{r}~xor~a_{l-1}=2^x$或$0$，其中$a_{i}$为异或前缀和 开一个计数数组$c$,其中$c_{i}$表示当前区间中异或前缀和的值为$i$的点的个数，统计答案时若当前枚举到的点$j$的异或前缀和为$a_{j}$，枚举$2$的所有幂次和$0$,$ans$直接加上(或减去)$c[a_{j}]+\sum\limits_{i=0}^{25}c[2^i~xor~a_{j}]$ 至于为什么区间内字符用$2$的幂次表示,换用别的编号呢$?$ 如果不用$2$的幂次表示,换用别的编号，那么即使$xor$起来$=0$也不能说明区间内的数能排列成回文串,如一个区间内三个数的的编号分别为$1,4,5$,即使它们异或起来也是$0$，但是它们显然不能构成回文串。 $PS:$当前维护$[l,r]$的信息时，$ans$应加上$[l-1,r-1]$的信息(若是减去则维护$[l-1,r]$的信息)，并且桶维护$[l-1,r]$的信息,因为当前枚举到的点是$r$。 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 60007using namespace std;struct node&#123; int l,r,num;&#125;q[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ans,block,n,m,w[N],a[N],Ans[N];unsigned short c[1&lt;&lt;26];char s[N];inline bool cmp(node a,node b)&#123; return (a.l/block)^(b.l/block)?a.l&lt;b.l:(((a.l/block)&amp;1)?a.r&lt;b.r:a.r&gt;b.r);&#125;inline void add(int k)&#123; for (int i=0;i&lt;26;++i) ans+=c[k^(1&lt;&lt;i)]; ans+=c[k]; ++c[k];&#125;inline void del(int k)&#123; for (int i=0;i&lt;26;++i) ans-=c[k^(1&lt;&lt;i)]; --c[k]; ans-=c[k];&#125;signed main()&#123; n=read(),m=read();block=(m&amp;&amp;n/sqrt(m*2/3))?n/sqrt(m*2/3):sqrt(n); scanf("%s",s+1); for (int i=1;i&lt;=n;++i)w[i]=(1&lt;&lt;(s[i]-'a')),a[i]=a[i-1]^w[i]; for (int i=1;i&lt;=m;++i)q[i].l=read()-1,q[i].r=read(),q[i].num=i; sort(q+1,q+1+m,cmp); int l=1,r=0; for (int i=1;i&lt;=m;++i)&#123; int ql=q[i].l,qr=q[i].r; while (l&gt;ql)add(a[--l]); while (r&lt;qr)add(a[++r]); while (l&lt;ql)del(a[l++]); while (r&gt;qr)del(a[r--]); Ans[q[i].num]=ans; &#125; for (int i=1;i&lt;=m;++i)printf("%d\n",Ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>莫队</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF366C 【Dima and Salad】]]></title>
    <url>%2F2019%2F05%2F25%2F%E9%A2%98%E8%A7%A3%20CF366C%20%E3%80%90Dima%20and%20Salad%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有$n$个水果,每个水果有两个属性：美味值和卡路里值。现在选用若干个（至少$1$个）水果制作一份特殊的沙拉，沙拉的美味值为所选的水果的美味值的和，沙拉的卡路里值为所选水果的卡路里值的和。要保证沙拉的美味值恰好是卡路里值的$K$倍。请计算该沙拉美味值最大为多少。 $Solution$根据题意可得$\sum a_{i}-k\times\sum b_{i}=0$ 所以我们考虑将$a_{i}$作为价值，$a_{i}-k\times b_{i}$作为重量，进行背包转移即可，由于重量有可能是负数，所以应用$map$存储转移数组或是将下标强行加上一个大数。 $Code$123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 30007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int a[N],v[N],f[200][N],g[200][N];signed main()&#123; int n=read(),k=read(),m=100*n;memset(f,-0x7f,sizeof(f));memset(g,-0x7f,sizeof(g)); for (int i=1;i&lt;=n;++i)a[i]=read(); for (int i=1;i&lt;=n;++i)v[i]=a[i]-read()*k; f[0][m]=0; for (int i=1;i&lt;=n;++i) for (int j=0;j&lt;=2*m;++j) f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+a[i]); cout&lt;&lt;(f[n][m]!=0?f[n][m]:-1)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>背包</tag>
        <tag>巧妙转化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2414 【[NOI2011]阿狸的打字机】]]></title>
    <url>%2F2019%2F05%2F24%2F%E9%A2%98%E8%A7%A3%20P2414%20%E3%80%90%5BNOI2011%5D%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$打字机上只有$28$个按键，分别印有$26$个小写英文字母和$’B’$、$’P’$两个字母。这个打字机是这样工作的： 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。 按一下印有$’B’$的按键，打字机凹槽中最后一个字母会消失。 按一下印有$’P’$的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。 例如，阿狸输入$aPaPBbP$，纸上被打印的字符如下：$a aa ab$我们把纸上打印出来的字符串从$1$开始顺序编号，一直到$n$。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数$(x,y)($其中$1\leqslant x,y\leqslant n)$，打字机会显示第$x$个打印的字符串在第$y$个打印的字符串中出现了多少次。 $Solution:$先无脑搭出一只$AC$自动机再说，然后再考虑各档分的做法 $40$给每个串的结束位置都标记一下，给$AC$自动机中的每个节点记录一个父亲节点，然后对于每个串的结束位置都暴力往上跳，计算有几个被标记过的节点即可 $70(1)$这样对于每一个询问都要暴力往上跳 如果对于某个串有重复的多次询问 那么就会多很多次没有任何意义的计算 所以，可以离线把所有询问都按照$y$排序 $y$相同的询问将从$y$向上跳碰到的标记记录下来，最后一起统计 $70(2)$原来是$y$的某个节点往上跳能不能到达$x$ 现在反过来： $x$往下跳能够到达几个$y$的节点 如果把$y$这个字符串所有的节点全部打上一个$1$的标记 那么，每次就变成了求$x$结束位置的子树和 而一个点的子树在$dfs$序上一定是连续的一段 单点修改，区间查询，考虑用树状数组打标记 $100$每次把串插入进树状数组会导致很多的串会有重复 考虑对$Trie$进行$dfs$ 对于每个节点访问到的时候对它的$dfs$序打一个$+1$,结束的时候对它的$dfs$序打一个$-1$ 每次访问到一个结束节点的时候，一定是有且仅有这个结束节点对应的串的所有节点被打了标记，这样就可以直接回答这个串作为$y$的所有询问了 $Code$$40$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 500007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N];int tot,K,ch[N][26],fail[N],fa[N],w[N],ed[N];void build_fail()&#123; queue&lt;int&gt;q; for (int i=0;i&lt;26;++i)if (ch[0][i])q.push(ch[0][i]); while (!q.empty())&#123; int now=q.front();q.pop(); for (int i=0;i&lt;26;++i) if (ch[now][i]) fail[ch[now][i]]=ch[fail[now]][i],q.push(ch[now][i]); else ch[now][i]=ch[fail[now]][i]; &#125;&#125;int query(int x,int y)&#123; int res=0; for (int now=ed[y];now;now=fa[now]) for (int t=now;t;t=fail[t]) if (w[t]==x)&#123; ++res;break; &#125; return res;&#125;signed main()&#123; scanf("%s",s);int len=strlen(s); int now=0; for (int i=0;i&lt;len;++i)&#123; if (s[i]=='B')&#123; now=fa[now]; &#125;else if (s[i]=='P')&#123; ed[++K]=now;w[now]=K; &#125;else&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot,fa[tot]=now; now=ch[now][v]; &#125; &#125; build_fail(); int n=read(); for (int i=1;i&lt;=n;++i)&#123; int x=read(),y=read(); printf("%d\n",query(x,y)); &#125; return 0;&#125; $70(1)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 500007using namespace std;struct node&#123; int x,y,num;&#125;q[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N];int cnt[N],tot,K,ch[N][26],ans[N],fail[N],fa[N],w[N],ed[N];void build_fail()&#123; queue&lt;int&gt;q; for (int i=0;i&lt;26;++i)if (ch[0][i])q.push(ch[0][i]); while (!q.empty())&#123; int now=q.front();q.pop(); for (int i=0;i&lt;26;++i) if (ch[now][i]) fail[ch[now][i]]=ch[fail[now]][i],q.push(ch[now][i]); else ch[now][i]=ch[fail[now]][i]; &#125;&#125;int query(int y)&#123; int res=0; for (int now=ed[y];now;now=fa[now]) for (int t=now;t;t=fail[t])&#123; ++cnt[w[t]]; &#125; return res;&#125;inline bool cmp(node a,node b)&#123; return a.y&lt;b.y;&#125;signed main()&#123; scanf("%s",s);int len=strlen(s); int now=0; for (int i=0;i&lt;len;++i)&#123; if (s[i]=='B')&#123; now=fa[now]; &#125;else if (s[i]=='P')&#123; ed[++K]=now;w[now]=K; &#125;else&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot,fa[tot]=now; now=ch[now][v]; &#125; &#125; build_fail(); int n=read(); for (int i=1;i&lt;=n;++i)q[i].x=read(),q[i].y=read(),q[i].num=i; sort(q+1,q+1+n,cmp); for (int i=1,j=1;i&lt;=n;i=j)&#123; query(q[i].y); while (q[i].y==q[j].y)ans[q[j].num]=cnt[q[j].x],++j; memset(cnt,0,sizeof(cnt)); &#125; for (int i=1;i&lt;=n;++i)printf("%d\n",ans[i]); return 0;&#125; $70(2)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 500007using namespace std;struct node&#123; int x,y,num;&#125;q[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N];int cnt[N],tot,K,ch[N][26],ans[N],fail[N],fa[N],w[N],ed[N];void build_fail()&#123; queue&lt;int&gt;q; for (int i=0;i&lt;26;++i)if (ch[0][i])q.push(ch[0][i]); while (!q.empty())&#123; int now=q.front();q.pop(); for (int i=0;i&lt;26;++i) if (ch[now][i]) fail[ch[now][i]]=ch[fail[now]][i],q.push(ch[now][i]); else ch[now][i]=ch[fail[now]][i]; &#125;&#125;int query(int y)&#123; int res=0; for (int now=ed[y];now;now=fa[now]) for (int t=now;t;t=fail[t])&#123; ++cnt[w[t]]; &#125; return res;&#125;inline bool cmp(node a,node b)&#123; return a.y&lt;b.y;&#125;signed main()&#123; scanf("%s",s);int len=strlen(s); int now=0; for (int i=0;i&lt;len;++i)&#123; if (s[i]=='B')&#123; now=fa[now]; &#125;else if (s[i]=='P')&#123; ed[++K]=now;w[now]=K; &#125;else&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot,fa[tot]=now; now=ch[now][v]; &#125; &#125; build_fail(); int n=read(); for (int i=1;i&lt;=n;++i)q[i].x=read(),q[i].y=read(),q[i].num=i; sort(q+1,q+1+n,cmp); for (int i=1,j=1;i&lt;=n;i=j)&#123; query(q[i].y); while (q[i].y==q[j].y)ans[q[j].num]=cnt[q[j].x],++j; memset(cnt,0,sizeof(cnt)); &#125; for (int i=1;i&lt;=n;++i)printf("%d\n",ans[i]); return 0;&#125; $100$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 500007using namespace std;struct edge&#123; int to,next;&#125;e[N];struct node&#123; int x,y,num;&#125;q[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N];int ql[N],qr[N],cc[N][26],ttt,head[N],dfn[N],low[N],dfsnum,c[100007],cnt[N],tot,K,ch[N][26],ans[N],fail[N],fa[N],w[N],ed[N];void add(int x,int d)&#123;for (;x&lt;=dfsnum;x+=(x&amp;(-x)))c[x]+=d;&#125;int sum(int x)&#123;int res=0;for (;x;x&amp;=x-1)res+=c[x];return res;&#125;void build_fail()&#123; queue&lt;int&gt;q; for (int i=0;i&lt;26;++i)if (ch[0][i])q.push(ch[0][i]); while (!q.empty())&#123; int now=q.front();q.pop(); for (int i=0;i&lt;26;++i) if (ch[now][i]) fail[ch[now][i]]=ch[fail[now]][i],q.push(ch[now][i]); else ch[now][i]=ch[fail[now]][i]; &#125;&#125;int query(int y)&#123; int res=0; for (int now=ed[y];now;now=fa[now]) for (int t=now;t;t=fail[t])&#123; ++cnt[w[t]]; &#125; return res;&#125;void Dfs(int u)&#123; dfn[u]=++dfsnum; for (int i=head[u];i;i=e[i].next)Dfs(e[i].to); low[u]=dfsnum;&#125;inline void Add(int u,int v)&#123; e[++ttt].to=v; e[ttt].next=head[u]; head[u]=ttt;&#125;inline bool cmp(node a,node b)&#123; return a.y&lt;b.y;&#125;void dfs(int u)&#123; add(dfn[u],1); if (w[u]) for (int i=ql[w[u]];i&lt;=qr[w[u]];++i) ans[q[i].num]=sum(low[ed[q[i].x]])-sum(dfn[ed[q[i].x]]-1); for (int i=0;i&lt;26;++i) if (cc[u][i])&#123; dfs(cc[u][i]); &#125; add(dfn[u],-1);&#125;signed main()&#123; scanf("%s",s);int len=strlen(s); int now=0; for (int i=0;i&lt;len;++i)&#123; if (s[i]=='B')&#123; now=fa[now]; &#125;else if (s[i]=='P')&#123; ed[++K]=now;w[now]=K; &#125;else&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot,fa[tot]=now; now=ch[now][v]; &#125; &#125; for (int i=0;i&lt;=tot;++i) for (int j=0;j&lt;26;++j) cc[i][j]=ch[i][j]; build_fail(); for (int i=1;i&lt;=tot;++i)Add(fail[i],i);Dfs(0); int n=read(); for (int i=1;i&lt;=n;++i)q[i].x=read(),q[i].y=read(),q[i].num=i; sort(q+1,q+1+n,cmp); for (int i=1,j=1;i&lt;=n;i=j)&#123; ql[q[i].y]=i; while (q[i].y==q[j].y)++j; qr[q[i].y]=j-1; &#125; dfs(0); for (int i=1;i&lt;=n;++i)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>$AC$自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF596D 【Wilbur and Trees】]]></title>
    <url>%2F2019%2F05%2F24%2F%E9%A2%98%E8%A7%A3%20CF596D%20%E3%80%90Wilbur%20and%20Trees%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$太长了,不想解释(逃 $Solution:$容易发现,砍树是从两端开始砍的，因此两端会影响中间，而中间则不会影响到两端的树，因为砍到中间的时候，两端的树都已经砍过了.所以做$dp$的时候，例如正在处理区间$i$到$j$，我们不需要关注区间内的树是向哪边倒的，因为中间的树不会影响两端的，我们需要关注的是$i-1$和$j+1$位的地方的树，因为只有这些地方会对中间的树有影响，所以我们用$dp[i][j][0/1][0/1]$来表式$i-1$和$j+1$这两棵树的状态时，$i$到$j$之间的答案。若状态若为$0$，则表示向左侧倒，若为$1$，则表示向右侧倒。 接下来分类讨论: $1.$第$i$颗树向左倒，不会影响别的树 $2.$第$j$棵树向右倒，不会影响别的树 $3.$第$i$棵树向右倒，会影响到第$i$棵树右边的树 $(1)$第$i$棵树能把$(i+1)$~$j$之间的所有树都压倒 $(2)$第$i$棵树不能把$(i+1)$~$j$之间的所有树都压倒 $4.$第$j$棵树向左倒，会影响到前面的树 $(1)$第$j$棵树能把$i$~$(j-1)$之间的所有树都压倒 $(2)$第$j$棵树不能把$i$~$(j-1)$之间的所有树都压倒 采用记搜实现 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define N 2007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125; int loc[N],dl[N],dr[N],h,n;double f[N][N][2][2],p,q;double dfs(int l,int r,int x,int y)&#123; if (l&gt;r)return 0; if (f[l][r][x][y]!=-1)return f[l][r][x][y]; double res=0,L=min(h,loc[l]-loc[l-1]-x*h),R=min(h,loc[r+1]-loc[r]-(!y)*h); res+=0.5*p*(dfs(l+1,r,0,y)+L);//最左边向左倒 res+=0.5*q*(dfs(l,r-1,x,1)+R);//最右边向右倒 if (dl[r]&lt;=l)res+=0.5*p*(loc[r]-loc[l]+L); else res+=0.5*p*(dfs(l,dl[r]-1,x,0)+loc[r]-loc[dl[r]]+h);// 最右边的向左倒，且能覆盖整个区间的树 if (dr[l]&gt;=r)res+=0.5*q*(loc[r]-loc[l]+R); else res+=0.5*q*(dfs(dr[l]+1,r,1,y)+loc[dr[l]]-loc[l]+h);// 最左边的向右倒，且能覆盖整个区间的树 return f[l][r][x][y]=res;&#125;signed main()&#123; n=read();cin&gt;&gt;h&gt;&gt;p;q=1-p; for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) for (int x=0;x&lt;2;++x) for (int y=0;y&lt;2;++y) f[i][j][x][y]=-1.0; for (int i=1;i&lt;=n;++i)loc[i]=read(); sort(loc+1,loc+1+n);loc[0]=-inf;loc[n+1]=inf; dl[1]=1; for (int i=2;i&lt;=n;++i) if (loc[i]-loc[i-1]&lt;h)dl[i]=dl[i-1]; else dl[i]=i; dr[n]=n; for (int i=n-1;i;--i) if (loc[i+1]-loc[i]&lt;h)dr[i]=dr[i+1]; else dr[i]=i; //dl[i],dr[i]分别表示从i这棵树开始向左/右最多能覆盖到第dl[i]/dr[i]棵树 printf("%.9lf\n",dfs(1,n,0,1)); &#125;]]></content>
      <tags>
        <tag>概率期望$DP$</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4135 【作诗】]]></title>
    <url>%2F2019%2F05%2F24%2F%E9%A2%98%E8%A7%A3%20P4135%20%E3%80%90%E4%BD%9C%E8%AF%97%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$$N$个数，$M$组询问，每次问$[l,r]$中有多少个数出现正偶数次。 $Solution:$考虑分块 先设$:f[i][j]$表示$i$块到$j$块的有多少个数出现正偶数次; $sum[i][j]$表示前$i$块中，数值$j$的出现次数; 预处理$f$数组和$sum$数组,时间复杂度$O(n\sqrt n)$ 处理询问时，设$res$为最终答案,$A$为询问左端点所在块，$B$为询问右端点所在块，先把$res$初值设为$f[A+1][B-1]$,然后处理两侧的不完整块. 对于一个值$j$,它在第$A+1$个块到第$B-1$个块中出现的次数就是$sum[B-1][j]-sum[A][j]$(类似于前缀和) 在处理不完整块的时候,若当前点的下标为$j$,那么只需要判断$++cnt[w[j]]+sum[B-1][w[j]]-sum[A][w[j]]$的奇偶性,并特判一下$0$变$1$的情况,然后更改$res$的值即可. $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 100007#define S 323using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int size,num,w[N],ans,n,m,c,sum[S][N],cnt[N],belong[N],l[N],r[N],f[S][S];void build()&#123; size=sqrt(n);num=(n-1)/size+1; for (int i=1;i&lt;=n;++i)belong[i]=(i-1)/size+1; for (int i=1;i&lt;=num;++i)l[i]=(i-1)*size+1,r[i]=i*size;r[num]=n; for (int i=1;i&lt;=num;++i)&#123; int res=0; for (int j=i;j&lt;=num;++j)&#123; for (int k=l[j];k&lt;=r[j];++k) if (!((++cnt[w[k]])&amp;1))++res; else if (cnt[w[k]]!=1)--res; f[i][j]=res; &#125; for (int j=i;j&lt;=num;++j) for (int k=l[j];k&lt;=r[j];++k)--cnt[w[k]]; &#125; memset(cnt,0,sizeof(cnt)); for (int i=1;i&lt;=n;++i)&#123; ++cnt[w[i]]; if (i==r[belong[i]]) memcpy(sum[belong[i]],cnt,sizeof(sum[belong[i]])); &#125;&#125;inline int calc(int l,int r,int w)&#123; return (l&lt;r)?(sum[r-1][w]-sum[l][w]):0;&#125;int query(int x,int y)&#123; x=(x+ans)%n+1,y=(y+ans)%n+1; if (x&gt;y)swap(x,y); int A=belong[x],B=belong[y],res=f[A+1][B-1]; for (int i=x;i&lt;=min(y,r[A]);++i)&#123; if (!((++cnt[w[i]]+calc(A,B,w[i]))&amp;1))++res; else if (cnt[w[i]]+calc(A,B,w[i])!=1)--res; &#125; if (A!=B)&#123; for (int i=l[B];i&lt;=y;++i)&#123; if (!((++cnt[w[i]]+calc(A,B,w[i]))&amp;1))++res; else if (cnt[w[i]]+calc(A,B,w[i])!=1)--res; &#125; for (int i=l[B];i&lt;=y;++i)--cnt[w[i]]; &#125; for (int i=x;i&lt;=min(y,r[A]);++i)--cnt[w[i]]; return res;&#125;signed main()&#123; n=read(),c=read(),m=read(); for (int i=1;i&lt;=n;++i)w[i]=read(); build(); memset(cnt,0,sizeof(cnt)); for (int i=1;i&lt;=m;++i) printf("%d\n",ans=query(read(),read())); return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2864 【[USACO06JAN]树林The Grove】]]></title>
    <url>%2F2019%2F05%2F24%2F%E9%A2%98%E8%A7%A3%20P2864%20%E3%80%90%5BUSACO06JAN%5D%E6%A0%91%E6%9E%97The%20Grove%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给定一张$R\times C$的地图，并给出一个联通块和一个起点，要求从起点出发，绕联通块一圈的最短路。 $Solution:$设起点为$S$,从这个树林的第一行最左边的那个点向左连出一条射线，然后从$S$开始$bfs$，求穿越射线奇数次最后终点在$S$的最短路径即可。 以样例为例， $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3fusing namespace std;struct node&#123; int x,y,p;&#125;;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;queue&lt;node&gt;q;char s[60];int n,m,ma[60][60],dis[60][60][2],xx,yy,sx,sy,dx[]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;-1,0,1,-1,1,-1,0,1&#125;;//dis[x][y][v]表示当前bfs的坐标为(x,y),穿越射线次数的奇偶性为vinline bool across(node a,node b)&#123; if (a.x==xx&amp;&amp;a.y&lt;yy&amp;&amp;xx&gt;b.x)return 1; if (b.x==xx&amp;&amp;b.y&lt;yy&amp;&amp;xx&gt;a.x)return 1; return 0;&#125;//判断是否穿越射线void bfs()&#123; q.push((node)&#123;sx,sy,0&#125;); memset(dis,0x3f,sizeof(dis));dis[sx][sy][0]=0; while (!q.empty())&#123; node u=q.front();int x=u.x,y=u.y,p=u.p;q.pop(); for (int i=0;i&lt;8;++i)&#123; int xx=x+dx[i],yy=y+dy[i]; node v=(node)&#123;xx,yy,p&#125;; if (ma[xx][yy]==-1||xx&lt;1||yy&lt;1||xx&gt;n||yy&gt;m)continue; if (across(u,v))v.p^=1; if (dis[xx][yy][v.p]!=inf)continue; dis[xx][yy][v.p]=dis[x][y][p]+1; q.push(v); &#125; &#125;&#125;//bfssigned main()&#123; n=read(),m=read(); for (int i=1;i&lt;=n;++i)&#123; scanf("%s",s+1); for (int j=1;j&lt;=m;++j) if (s[j]=='.')ma[i][j]=1; else if (s[j]=='*')ma[sx=i][sy=j]=1; else&#123;if (!xx)xx=i,yy=j;ma[i][j]=-1;&#125; &#125; bfs(); printf("%d",dis[sx][sy][1]); return 0;&#125;]]></content>
      <tags>
        <tag>奇技淫巧</tag>
        <tag>射线法</tag>
        <tag>$bfs$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3702 【[SDOI2017]序列计数】]]></title>
    <url>%2F2019%2F05%2F19%2F%E9%A2%98%E8%A7%A3%20P3702%20%E3%80%90%5BSDOI2017%5D%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[很显然，要求的方案数可以转化为所有方案数减去不含质数的方案数 对于所有方案，设$f_{i,j}$表示前$i$个数$mod~p$等于$j$的方案数 $f_{i,j}=\sum\limits_{k=1}^{m}f_{i-1,((j-k)\%p+p)\%p}$ 对于不含质数的方案，我们只需先预处理$cnt_i$表示$1$~$m$中$\%p==i$的合数的个数，设$g_{i,j}$表示前$i$个数$mod~p$等于$j$且没有质数的方案数。 $g_{i,j}=\sum\limits_{k=0}^{p-1} cnt_{((j-k)\%p+p)\%p}$ 然后发现这两个东西显然都可以用矩阵快速幂优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define ll long long#define mod 20170408#define M 20000070#define re registerusing namespace std;bool f[M];int cnt[M],pre[7000000],tot,n,m,p,ans;inline void add(int &amp;a,int b)&#123; a+=b; while (a&gt;=mod)a-=mod;&#125;struct node&#123; int a[207][207]; inline void init0()&#123;memset(a,0,sizeof(a));&#125; inline void init1()&#123; for (int i=0;i&lt;=p-1;++i) for (int j=0;j&lt;=p-1;++j) a[i][j]=i==j; &#125; friend node operator *(node a,node b)&#123; node res;res.init0(); for (int i=0;i&lt;=p-1;++i) for (int k=0;k&lt;=p-1;++k) for (int j=0;j&lt;=p-1;++j) add(res.a[i][k],1ll*a.a[i][j]*b.a[j][k]%mod); return res; &#125; friend node operator ^(node x,int p)&#123; node res;res.init1(); while (p)&#123; if (p&amp;1)res=res*x; x=x*x; p&gt;&gt;=1; &#125; return res; &#125;&#125;t,A;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;void init()&#123; f[1]=1; for (int i=2;i&lt;=m;++i)&#123; if (!f[i])pre[++tot]=i,--cnt[i%p]; for (int j=1;j&lt;=tot&amp;&amp;i*pre[j]&lt;=m;++j)&#123; f[i*pre[j]]=1; if (i%pre[j]==0)break; &#125; &#125;&#125;signed main()&#123;// freopen("dodo.in", "r", stdin); freopen("dodo.out", "w", stdout); n=read();m=read();p=read(); for (int i=1;i&lt;=m;++i)++cnt[i%p]; init();t.init0(); for (re int i=0;i&lt;=p-1;++i) for (re int j=0;j&lt;=p-1;++j)&#123; int d=((j-i)%p+p)%p; if (d==0)d=p;//特判，因为序列中的数都是不超过mm的正整数 if (m&gt;=d)t.a[i][j]=(m-d)/p+1; &#125; t=t^n;int res=t.a[0][0]; for (int i=0;i&lt;=p-1;++i) for (int j=0;j&lt;=p-1;++j)&#123; int d=((j-i)%p+p)%p;//余数 t.a[i][j]=cnt[d]; &#125; t=t^n; cout&lt;&lt;((res-t.a[0][0])%mod+mod)%mod&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4008 【[NOI2003]文本编辑器】]]></title>
    <url>%2F2019%2F05%2F19%2F%E9%A2%98%E8%A7%A3%20P4008%20%E3%80%90%5BNOI2003%5D%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[块状链表模板题，但出奇的恶心 由于一些操作会产生或删去一些块，所以对于块的产生与删去，块的编号用内存池分配 先给出几个操作，添加块($add$),查询属于哪个块($belong$),分裂($split$),合并($merge$)，具体细节看代码分析. 下面对题目给的操作进行分析 $1.Move~k$ 将光标移动到第 $k$个字符之后直接移动即可1pos=read(); $2.Insert~n~s$ 在光标处插入长度为$n$的字符串$s$，光标位置不变将插入串分块，最后一块(即剩余块,唯一的一块长度不一定是$size$的块)与它后面那一块判断一下，如果长度相加后$&lt;size$,那么就合并. 并且我们很可能在块内插入，那我们就要将这个块从插入位置$split$,然后进行插入。 $3.Delete~n$ 删除光标后的n个字符，光标位置不变先将两端所在的块分裂，然后直接删除，并且对两端分类出的块长度和进行判断，如果$&lt;size$，就进行$merge$操作。 $4.Get~n$ 输出光标后的$n$个字符，光标位置不变只需把左边块和右边块的需要部分给截出来，与中间完整的块拼在一起输出即可 $5.Prev$ 光标前移一个字符直接移动即可1--pos; $6.Next$ 光标后移一个字符直接移动即可1++pos; $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 100007using namespace std;struct node&#123; int nx,size; char s[4500];&#125;t[9000];char ans[8000000];int cnt=1,tot,pos,pool[800000];const int size=2007;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline int mod()&#123;return pool[++cnt];&#125;inline void del(int x)&#123;pool[cnt--]=x;&#125;//动态分配和回收内存池void add(int x,int y,int len,char *s)&#123;//在编号为x的块后面加一个编号为y的块 t[y].nx=t[x].nx;t[y].size=len; memcpy(t[y].s,s,sizeof(t[y].s)); t[x].nx=y;&#125;inline int belong(int &amp;k)&#123;//查询属于哪个块 int p=1; while (p&amp;&amp;k&gt;t[p].size)k-=t[p].size,p=t[p].nx; return p;&#125;void split(int x,int y)&#123;//将第x个块从y处分裂 if (!x||y==t[x].size)return;//如果当前块不存在或从块中最后一个开始分割是没有意义的 add(x,mod(),t[x].size-y,t[x].s+y);//t[x].s+y就相当于截去了t[x].s[1~(y-1)] t[x].size=y;&#125;void merge(int x,int y)&#123;//合并x和y，把y接在x的后面,然后把y删除 memcpy(t[x].s+t[x].size,t[y].s,t[y].size); t[x].size+=t[y].size;t[x].nx=t[y].nx;del(y);&#125;void ins(int len,char *s)&#123; int k=pos,now=belong(k),w=now; split(now,k);int sum,nx; for (sum=0;sum+size&lt;=len;sum+=size)&#123; add(now,nx=mod(),size,s+sum); now=nx; &#125; if (len-sum&gt;0)&#123;//如果剩余块的大小大于0 add(now,nx=mod(),len-sum,s+sum); if (t[now].size+t[nx].size&lt;size&amp;&amp;nx) merge(now,nx); &#125; if (t[w].size+t[t[w].nx].size&lt;size&amp;&amp;t[w].nx) merge(w,t[w].nx);&#125;void dele(int len)&#123; int k=pos,now=belong(k); split(now,k); int i; for (i=t[now].nx;t[i].size&lt;len&amp;&amp;i;i=t[i].nx) len-=t[i].size; split(i,len); for (int j=t[now].nx;j!=t[i].nx;j=t[now].nx) t[now].nx=t[j].nx,del(j); int q=t[i].nx; while (t[now].size+t[q].size&lt;size&amp;&amp;q)merge(now,q),q=t[q].nx;&#125;void print(int len)&#123; int k=pos; int now=belong(k); int nx=t[now].nx; int l=min(len,t[now].size-k); memcpy(ans,t[now].s+k,l); while (l+t[nx].size&lt;=len&amp;&amp;nx)&#123; memcpy(ans+l,t[nx].s,t[nx].size); l+=t[nx].size;nx=t[nx].nx; &#125; if (len-l&gt;0&amp;&amp;nx) memcpy(ans+l,t[nx].s,len-l); ans[len]='\0'; printf("%s\n",ans);&#125;char s[8000000];inline char gc()&#123; char ch=getchar(); while (ch!='M'&amp;&amp;ch!='I'&amp;&amp;ch!='D'&amp;&amp;ch!='G'&amp;&amp;ch!='P'&amp;&amp;ch!='N')ch=getchar(); return ch;&#125;signed main()&#123; int T=read(); for (int i=1;i&lt;=2e5+7;++i)pool[i]=i; while (T--)&#123; char ch=gc(); if (ch=='M')&#123;//将光标移动到第 k个字符之后 pos=read(); &#125;else if (ch=='I')&#123;//在光标处插入长度为n的字符串s，光标位置不变 int n=read(); for (int i=0;i&lt;n;++i)&#123; s[i]=getchar(); if (s[i]&lt;32||s[i]&gt;126)--i; &#125; ins(n,s); &#125;else if (ch=='D')&#123;//删除光标后的n个字符 dele(read()); &#125;else if (ch=='G')&#123;//输出光标后的n个字符 print(read()); &#125;else if (ch=='P')&#123; --pos; &#125;else&#123; ++pos; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
        <tag>块状链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2325 【[SCOI2005]王室联邦】]]></title>
    <url>%2F2019%2F05%2F19%2F%E9%A2%98%E8%A7%A3%20P2325%20%E3%80%90%5BSCOI2005%5D%E7%8E%8B%E5%AE%A4%E8%81%94%E9%82%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[我们可以考虑这样一种构造方法： 我们$dfs$整棵树，处理当前节点$u$时，将其子节点进行分块，如果需要进行分块的节点数不能整除块的大小，则将未被分块的子节点与$u$分在同一个块。 枚举$u$的每个子节点$v$，递归处理子树后，将每个子节点返回的未被分块的节点添加到集合$S$中，一旦$\vert S\vert\geqslant size$就把$S$作为一个新的块并将$u$作为省会，然后清空$S$并继续枚举$v$。 处理完所有子树后，将$u$也加入到集合$S$中，此时在$S$中的节点为未被分块的节点，将被返回到上一层，显然$S$的大小最大为$size$,$size-1$个子树节点$+u$节点本身。 由于返回的集合的大小最大为$size$，对于一个子树会对集合最多增加$B-1$个节点，那么每个块的大小最大为$2B-1,$满足条件。 在$dfs$结束后，集合$S$中可能还有节点（最多有$B$个），那么我们把这$ B$个节点并入最后一个块（以根节点为省会的最后一个块，块的大小最大为 $2B-1$）中，那么这个块的大小最大为$3B-1$，符合条件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 100007using namespace std;struct node&#123; int to,next;&#125;e[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt,top,head[N],sh[N],K,col[N],st[N],n,B;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; int now=top; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs(v,u); if (top-now&gt;=B)&#123; sh[++K]=u; while (top&gt;now)col[st[top--]]=K; &#125; &#125; st[++top]=u;&#125;signed main()&#123; n=read(),B=read(); for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; dfs(1,0); if (n==B)sh[++K]=1; while (top)col[st[top--]]=K; printf("%d\n",K); for (int i=1;i&lt;=n;++i)printf("%d ",col[i]);puts(""); for (int i=1;i&lt;=K;++i)printf("%d ",sh[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3449 【[POI2006]PAL-Palindromes】]]></title>
    <url>%2F2019%2F05%2F12%2F%E9%A2%98%E8%A7%A3%20P3449%20%E3%80%90%5BPOI2006%5DPAL-Palindromes%E3%80%91%2F</url>
    <content type="text"><![CDATA[题意：给出$n$个回文串$s_1, s_2, \cdots,s_n$求如下二元组$(i, j)$的个数$s_i + s_j$仍然是回文串 对于每个字符串进行$hash$,判断连接形成回文串只需判断$a+b$是否$=$$b+a$即可 注:这里的$x+y$指的是将字符串$y$连到字符串$x$后面去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define N 2000002#define hash HASH#define mod 1000000007#define base 131using namespace std;int n,m,hash[N],len[N],ch[N][26],tot,po[N],w[N],ans;string s[N];int calc(string s)&#123; int res=0,len=s.length(); for (int i=0;i&lt;len;++i)res=(res*base+s[i]-'a')%mod; return res;&#125;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;void build(string s,int id)&#123; int len=s.length(),now=0; for (int i=0;i&lt;len;++i)&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot; now=ch[now][v]; &#125; w[now]=id;&#125;void query(string ss,int id)&#123; int le=ss.length(),now=0; for (int i=0;i&lt;le;++i)&#123; int v=ss[i]-'a'; now=ch[now][v]; if (w[now]&amp;&amp;w[now]!=id)&#123; if ((hash[w[now]]*po[len[id]]%mod+hash[id])%mod==(hash[id]*po[len[w[now]]]%mod+hash[w[now]])%mod)&#123; ++ans; &#125; &#125; &#125;&#125;signed main()&#123; n=read();po[0]=1; for (int i=1;i&lt;=200000;++i)po[i]=po[i-1]*base%mod; for (int i=1;i&lt;=n;++i)&#123; len[i]=read();cin&gt;&gt;s[i]; build(s[i],i); hash[i]=calc(s[i]); &#125; for (int i=1;i&lt;=n;++i) query(s[i],i); cout&lt;&lt;ans*2+n; return 0;&#125;]]></content>
      <tags>
        <tag>$hash$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4683 【[IOI2008] Type Printer 打印机】]]></title>
    <url>%2F2019%2F05%2F12%2F%E9%A2%98%E8%A7%A3%20P4683%20%E3%80%90%5BIOI2008%5D%20Type%20Printer%20%E6%89%93%E5%8D%B0%E6%9C%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[给出这么多字符串，显然就是要你建出字典树 在建完字典树后，我们手动模拟一下，发现树上兄弟的遍历先后其实是没有关系的(只所有兄弟是连着一起遍历的就行了)(即$dfs$序)， 唯一不同的就是最后遍历的一个单词不用删，所以我们考虑让最长的单词最后遍历，于是考虑在最长单词的所有字母上加上标记，最后走。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 500007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ch[N][26],tot,book[N],w[N],ans,n;char s[N][26];void build(char *s)&#123; int len=strlen(s),now=0; for (int i=0;i&lt;len;++i)&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot; now=ch[now][v]; &#125; w[now]=1;&#125;void work(char *s)&#123; int len=strlen(s),now=0; for (int i=0;i&lt;len;++i)&#123; int v=s[i]-'a'; now=ch[now][v]; book[now]=1; &#125;&#125;void query(int now,int flag)&#123; if (w[now])&#123;++ans;if (flag)puts("P");&#125; int t=-1; for (int i=0;i&lt;26;++i) if (ch[now][i]) if (!book[ch[now][i]])&#123; ++ans;if (flag)printf("%c\n",i+'a'); query(ch[now][i],flag); ++ans;if (flag)puts("-"); &#125;else t=i; if (t!=-1)&#123; ++ans; if (flag)printf("%c\n",t+'a'); query(ch[now][t],flag); &#125;&#125;signed main()&#123; n=read();int mx=0,num; for (int i=1;i&lt;=n;++i)&#123; scanf("%s",s[i]); build(s[i]);int len=strlen(s[i]); if (len&gt;mx)&#123;mx=len;num=i;&#125; &#125; work(s[num]); query(0,0); printf("%d\n",ans); query(0,1); return 0;&#125;]]></content>
      <tags>
        <tag>$Trie$树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇技淫巧杂记]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[奇技淫巧杂记$1.$描述给定两个数$n,m,$其中$m$是一个素数。将$n(0\leqslant n\leqslant 2^{31})$的阶乘分解质因数，求其中有多少个$m$。 做法： $while(n/m) ans+=n/m,n/=m;$ $ans$即为答案]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2403 【[SDOI2010]所驼门王的宝藏】]]></title>
    <url>%2F2019%2F05%2F01%2F%E9%A2%98%E8%A7%A3%20P2403%20%E3%80%90%5BSDOI2010%5D%E6%89%80%E9%A9%BC%E9%97%A8%E7%8E%8B%E7%9A%84%E5%AE%9D%E8%97%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Tarjan+toposort$的经典套路题吧，$Tarjan+toposort$应该一眼就能看出来，但是发现对于第$1$,$2$种边连边显然会超时，这里用了一种比较无脑简单的方法(像我这种小蒟蒻都能想出来肯定简单啊)，这里以第$1$种为例(第二种类比一下就可以了) 若有多个第一种门在某一行，那么这些门都是可以互相到达的，但是我们两两之间连$n^2$的边显然很愚蠢，只需要连成一个环即可(第$1$个连第$2$个，第$2$个连第$3$个，最后一个连第$1$个)，在这个环上的其他所有点，只需从环上任意一点连出去即可(像对于网络流时经常用的建一个虚点连接两边优化$n^2$连边的方法应该也可以) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 1003000#define mod 19260817#define pb push_backusing namespace std;struct node1&#123; int u,to,next;&#125;e[N&lt;&lt;4];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;unordered_map&lt;ll,int&gt;mp,ed;vector&lt;int&gt;x[N],y[N];int dx[]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;-1,0,1,-1,1,-1,0,1&#125;;int opt[N],R,C,m,u[N],v[N],cnt=1,head[N],dfn[N],low[N],ans,f[N],st[N],top,num,col,in[N],w[N],color[N];inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].u=u; e[cnt].next=head[u]; head[u]=cnt;&#125;inline ll h(ll x,ll y)&#123; return 1ll*(x-1)*C+1ll*y;&#125;inline ll ee(ll x,ll y)&#123; return 1ll*(x-1)*col+1ll*y;&#125;void Tarjan(int u)&#123; dfn[u]=low[u]=++num; st[++top]=u; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (!dfn[v])&#123; Tarjan(v); low[u]=min(low[u],low[v]); &#125;else if (!color[v]) low[u]=min(low[u],dfn[v]); &#125; if (low[u]==dfn[u])&#123; ++col; do&#123; ++w[col];color[st[top--]]=col; &#125;while (st[top+1]!=u); &#125;&#125;void topo()&#123; queue&lt;int&gt;q; for (int i=1;i&lt;=col;++i)if (!in[i])q.push(i),f[i]=w[i]; while (!q.empty())&#123; int u=q.front();q.pop(); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; --in[v]; f[v]=max(f[v],f[u]+w[v]); if (!in[v])q.push(v); &#125; &#125;&#125;signed main()&#123; m=read(),R=read(),C=read(); for (int i=1;i&lt;=m;++i)&#123; u[i]=read(),v[i]=read(),opt[i]=read(); mp[h(u[i],v[i])]=i; x[u[i]].pb(i); y[v[i]].pb(i); &#125; for (int i=1;i&lt;=R;++i)&#123; int st=0,cnt=0; while (st&lt;x[i].size()&amp;&amp;opt[x[i][st]]!=1)++st;int last; if (st!=x[i].size())&#123;++cnt;last=x[i][st];&#125; if (cnt)for (int j=0;j&lt;st;++j)add(last,x[i][j]); for (int j=st+1;j&lt;x[i].size();++j) if (opt[x[i][j]]==1)&#123; add(last,x[i][j]); last=x[i][j];++cnt; &#125;else add(x[i][st],x[i][j]); if (cnt&gt;1)add(last,x[i][st]); &#125; for (int i=1;i&lt;=C;++i)&#123; int st=0,cnt=0; while (st&lt;y[i].size()&amp;&amp;opt[y[i][st]]!=2)++st;int last; if (st!=y[i].size())&#123;++cnt;last=y[i][st];&#125; if (cnt)for (int j=0;j&lt;st;++j)add(last,y[i][j]); for (int j=st+1;j&lt;y[i].size();++j) if (opt[y[i][j]]==2)&#123; add(last,y[i][j]); last=y[i][j];++cnt; &#125;else&#123;add(y[i][st],y[i][j]);&#125; if (cnt&gt;1)add(last,y[i][st]); &#125; for (int i=1;i&lt;=m;++i) if (opt[i]==3) for (int ii=0;ii&lt;8;++ii)&#123; int x=u[i]+dx[ii],y=v[i]+dy[ii]; if (!mp[h(x,y)])continue; add(i,mp[h(x,y)]); &#125; for (int i=1;i&lt;=m;++i) if (!dfn[i]) Tarjan(i); int tot=cnt;memset(head,0,sizeof(head));cnt=0; for (int i=1;i&lt;=tot;++i)&#123; int u=e[i].u,v=e[i].to; if (color[u]!=color[v])&#123; if (ed[ee(color[u],color[v])])continue; add(color[u],color[v]); ed[ee(color[u],color[v])]=1; ++in[color[v]]; &#125; &#125; topo(); for (int i=1;i&lt;=col;++i) ans=max(ans,f[i]); cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>$Tarjan$</tag>
        <tag>拓扑排序</tag>
        <tag>连边优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2151 【[SDOI2009]HH去散步】]]></title>
    <url>%2F2019%2F05%2F01%2F%E9%A2%98%E8%A7%A3%20P2151%20%E3%80%90%5BSDOI2009%5DHH%E5%8E%BB%E6%95%A3%E6%AD%A5%E3%80%91%2F</url>
    <content type="text"><![CDATA[如果没有限制条件不能沿着刚走过的道路走回，那就是裸的矩阵快速幂优化$DP$了。 但是，这个限制条件使得无论怎么构造矩阵，普通的矩阵快速幂不能符合要求 这时，我们就要向别的方向想了，普通的矩阵快速幂是点之间转移，那我们能不能边与边之间转移呢$？$ 只需要在矩阵中将除了当前边与当前边的反向边以外的所有边对的权值都赋为$1$,然后进行矩阵快速幂即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define int long long#define mod 45989using namespace std;struct ed&#123; int u,v;&#125;e[393939];int cnt,ans,n,m,t,A,B;struct node&#123; int a[207][207]; inline void init0()&#123;memset(a,0,sizeof(a));&#125; inline void init1()&#123; memset(a,0,sizeof(a)); for (int i=0;i&lt;=n;++i) for (int j=0;j&lt;=n;++j) a[i][j]=i==j; &#125; friend node operator *(node a,node b)&#123; node res;res.init0(); for (int i=0;i&lt;=n;++i) for (int k=0;k&lt;=n;++k) for (int j=0;j&lt;=n;++j)&#123; res.a[i][k]=(res.a[i][k]+a.a[i][j]*b.a[j][k]%mod)%mod; &#125; return res; &#125; friend node operator ^(node x,int p)&#123; node res;res.init1(); while (p&gt;0)&#123; if (p&amp;1)res=res*x; x=x*x; p&gt;&gt;=1; &#125; return res; &#125;&#125;f;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;signed main()&#123;// freopen("desire.in","r", stdin); freopen("desire.out", "w", stdout); cnt=read(),m=read(),t=read(),A=read(),B=read(); f.init0();n=-1; for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); e[++n]=(ed)&#123;u,v&#125;; e[++n]=(ed)&#123;v,u&#125;; &#125; for (int i=0;i&lt;=n;++i) for (int j=0;j&lt;=n;++j) if ((i!=j)&amp;&amp;((i^1)!=j)&amp;&amp;(e[i].v==e[j].u)) f.a[i][j]=1; f=f^(t-1); for (int i=0;i&lt;=n;++i) if (e[i].u==A) for (int j=0;j&lt;=n;++j) if (e[j].v==B) ans=(ans+f.a[i][j])%mod; printf("%d",ans);&#125;]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF878C Tournament]]></title>
    <url>%2F2019%2F05%2F01%2F%E9%A2%98%E8%A7%A3%20CF878C%20Tournament%2F</url>
    <content type="text"><![CDATA[我们考虑两个选手之间的关系，如果一个选手能在任何一项运动中战胜对手，那么就从他自身向对手连一条有向边。这样显然会出现很多环，于是可以大力缩点，将整张图缩成一个$DAG$（实际实现中会变为一条链）。那么显然入度为零的环中包含的点数即为最后可能成为冠军的人数。 这里缩点的技巧就是这道题的关键，由于题目要求动态插入点，那么$tarjan$就不再适合了。于是我们可以选择$set$作为容器，把上述判断的条件重载成小于号，在$set$中用$find$查找（这里的$find$查找完全是根据$”&lt;”$来的,即对于两个参数$a,b$,判断$==$的操作相当于判断$(!(a&lt;b))$&amp;&amp;$(!(b&lt;a)),)$是否有与当前选手可以合并的，并进行合并操作。合并后，我们的节点（即一个环）记录的是环中每项运动所有选手中的最大值和最小值，这样可以方便地进行环与环之间的比较。 将所有点插入后，答案即为$set$中的最后一个元素的大小，因为我们重载了小于号，所以最后一个节点都是“大于”之前的点的，在缩点后的图中一定是入度为$0$。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3fusing namespace std;int n,k;struct node&#123; int mx[15],mn[15],size; friend bool operator &lt;(node a,node b)&#123; for (int i=1;i&lt;=k;++i) if (a.mx[i]&gt;b.mn[i])return 0; return 1; &#125;&#125;lxy;set&lt;node&gt;s;set&lt;node&gt;::iterator it;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int main()&#123; n=read(),k=read(); for (int i=1;i&lt;=n;++i)&#123; lxy.size=1; for (int j=1;j&lt;=k;++j)lxy.mx[j]=lxy.mn[j]=read(); it=s.find(lxy); while (it!=s.end())&#123; lxy.size+=(*it).size; for (int j=1;j&lt;=k;++j) lxy.mx[j]=max(lxy.mx[j],(*it).mx[j]),lxy.mn[j]=min(lxy.mn[j],(*it).mn[j]); s.erase(it);it=s.find(lxy); &#125; s.insert(lxy); printf("%d\n",(*--s.end()).size); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>$STL$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流杂记(待填坑,可能咕咕)]]></title>
    <url>%2F2019%2F04%2F30%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[求二分图最大匹配方案时只需求出所有反向边中边权大于0的即可 二分图匹配只需源点连向所有左侧的点，边权为inf，所有右侧的点连汇点，边权也为$inf$，两侧的点的连边即是原图上的连边，边权为$1$。求最大流即可 证明：我们求最大流等于求最小割，因为两侧的点与源汇点的连边权都为$inf$，所以割边只能是 拆点最大流模型的一般建模思路是运用流的容量限制，使得题目中的约束得以满足，有时还需使用一些特殊的方法（如拆点）来满足题目的特别约束。 拆点的主要应用1.例如一件物品只能用有限次，但是如果不拆点普通建模跑网络流很可能会导致这个点被超过限制次数的流量经过，使答案出错，所以如果将这个点拆成两个，设为$i_1$ , $i_2$,原入边连 $i_1$，原出边连 $i_2$,$i_1$与$i_2$之间连边权为限制次数的边即可。正确性显然。 例题1:P1231 教辅的组成 例题2:P1345 [USACO5.4]奶牛的电信(拆点解决最小割点问题) 例题: P1402 酒店之王 二分图最大匹配的三个定理 1:最大匹配数 + 最大独立集 =$n$(点数) 2:二分图的最小覆盖数 = 最大匹配数 3:最小路径覆盖 = 最大独立集 最大独立集是指求一个二分图中最大的一个点集，该点集内的点互不相连。 最小顶点覆盖是指 在二分图中，用最少的点，让所有的边至少和一个点有关联。 最小路径覆盖是指一个不含圈的有向图G 中，G的一个路径覆盖是一个其结点不相交的路径集合P，图中的每一个结点仅包含于P 中的某一条路径。路径可以从任意结点开始和结束，且长度也为任意值，包括0. 在二分图匹配时，如果有很多个条件都不满足才能连边，跑最大匹配是错误的，]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流——最小割求最大权闭合子图]]></title>
    <url>%2F2019%2F04%2F30%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E5%89%B2%E6%B1%82%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[有一个有向图，每一个点都有一个权值（可以为正或负或$0$），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。 如下图： 能选的子图有$Ø$(即不选),{$4$},{$3,4$},{$2,4$},{$1,2,3,4$},它们的权值分别为$0,-1,5,-6,4.$所以最大权闭合子图为{$3,4$}，权值为$5$. 解法这个问题可以转化为最小割问题，用网络流解决。 从源点$s$向每个正权点连一条容量为权值的边，每个负权点向汇点$t$连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。 求它的最小割，割掉后，与源点s连通的点构成最大权闭合子图，权值为（正权值之和$-$最小割）。 如何理解割掉一条边的含义由于原图的边都是无穷大，那么割边一定是与源点$s$或汇点$t$相连的。 割掉$s$与$i$的边，表示不选择$i$点作为子图的点； 割掉$i$与$t$的边，表示选择$i$点为子图的点。 如果$s$与$i$有边，表示$i$存在子图中； 如果$i$与$t$有边，表示$i$不存在于子图中。 合法性只有$s$与$t$不连通时，才能得到闭合子图。 如果$s$与$t$连通，则存在点$i,j$，使得$s$到$i$有边，$i$到$j$连通,$j$到$t$有边，所以$j$一定是$i$的后继，但选择了$i$，没有选择$j$，不是闭合子图。 如果$s$与$t$不连通，选择了正权点$i$，一定选择了$i$后继中的所有负权点。设$j$是$i$的后继中的正权点，则割掉$s$到$j$的边是没有意义的，最小割不会割掉它，则$j$一点被选中，所以$i$的所有后继都被选中，符合闭合图的定义。 最优性最小割=(不选的正权之和+要选的负权绝对值之和） 最大权闭合子图=（正权之和-不选的正权之和-要选的负权绝对值之和）=正权值和-最小割 因为正权值和，是定值，而最小割保证值最小，所以最大权闭合子图一定最优。 例题洛谷P3410 拍照 POJ2987_Firing P4174 [NOI2006]最大获利 拓展要求输出方案枚举每个点的$dep$，如果$dep&lt;inf$，那么则是方案内的点 因为那种无论怎么买花费$&gt;$收入，这样的购买有一个特点，因为它不能供给需求，所以源点到它的残流一定是$0$，就是说不管是正向边还是反向边都是$0$，同样的那些可以供给的，源点到它的残留一定大于$0$，也就是正向边或者反向边大于$0$，说明做这个购买能赚钱。 所以在最后一遍$bfs$时，边权为$0$的边是不会走的，也就是说$bfs$时只会走边权大于$0$的边，所以走过的每一个点都是方案中的点，因为只有走过的点$dep$才会小于$inf$，所以只需要找出$dep&lt;inf$的点即可 例题P2762 太空飞行计划问题]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 4.21模拟赛T4]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%204.21%E6%A8%A1%E6%8B%9F%E8%B5%9BT4%2F</url>
    <content type="text"><![CDATA[$Description$$Ahri$得到了一个$(h+1) × (w+1)$的巧克力，这意味着她横着最多可以切$h$刀，竖着最多可以切$w$刀。 她想总共切$K$刀，每刀要么竖着切要么横着切，如果竖着切了$i$刀，横着切了$j$刀，会得到$(i+1) × (j+1)$个巧克力，定义一个切$K$刀的方案的代价是每一刀切完后巧克力个数之和，假设每刀切的位置是随机选择的（即剩余能切的位置等概率随机选一个），请你求出期望代价，对$1e9+7$取模 $Solution:$做法一:参考xjh大佬的博客 我们把答案的每一部分分开来考虑 每一部分对答案的贡献就是这一部分能算进答案里的方案数$×$这部分的价值 显然这里的每一部分就指的是横着切$i$刀，竖着切$j$刀 这一部分的价值横着切i刀，竖着切j刀的价值很好求，就是$(i+1)(j+1)$ 无论怎么切，这一部分的价值都是$(i+1)(j+1)$ 难点在于求这一部分能算进答案里的方案数 我们把所有方案都画出来，就会清楚的发现怎么求了 方案数就是能走到这个状态的方案数$×$这个状态走到结束状态的方案数(简称来的状态和去的状态) 来的状态就是$A^i_h\times A^j_w\times$(不同的切横切竖的顺序),$A^i_h\times A^j_w$比较好理解，但对(不同的切横切竖的顺序) 不知道怎么求 我们稍微转换一下：有$i$个$0$(相当于横切)，$j$个$1$(相当于纵切)，问用它们构成一个长为$i+j$的$01$串的方案数，答案就相当于有$i+j$个位置，选$i$个位置放$0$,剩余位置放$1$的方案数，即$C^{i}_{i+j}$。 去的状态就是$A^{k-i-j}_{n-i-j}$ 贴上$xjh$大佬的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod=1e9+7;const int N=10005;int h,w,k,n,ans,jc[N],inv[N];int add(int a,int b)&#123; a+=b; if(a&gt;=mod)a-=mod; return a;&#125;int kuai(int a,int b)&#123; int res=1; while(b) &#123; if(b%2==1)res=res*a%mod; a=a*a%mod; b=b/2; &#125; return res;&#125;signed main()&#123; freopen("ahri.in","r",stdin); freopen("ahri.out","w",stdout); jc[0]=1;inv[0]=inv[1]=1; for(int i=1;i&lt;=10000;i++)jc[i]=jc[i-1]*i%mod; for(int i=2;i&lt;=10000;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod; for(int i=2;i&lt;=10000;i++)inv[i]=inv[i]*inv[i-1]%mod; scanf("%lld%lld%lld",&amp;h,&amp;w,&amp;k); n=h+w; for(int i=0;i&lt;=h;i++) for(int j=0;j&lt;=w;j++) &#123; if(i==0&amp;&amp;j==0)continue; if(i+j&gt;k)break; //ans=add(ans,a[h][i]*a[w][j]%mod*c[i+j][i]%mod*a[n-i-j][k-i-j]%mod*(i+1)%mod*(j+1)%mod); ans=add(ans,jc[h]*inv[h-i]%mod*jc[w]%mod*inv[w-j]%mod*jc[i+j]%mod*inv[i]%mod*inv[j]%mod*jc[n-i-j]%mod*inv[n-k]%mod*(i+1)%mod*(j+1)%mod); &#125; cout&lt;&lt;(ans*kuai(jc[n]%mod*inv[n-k]%mod,mod-2)%mod+mod)%mod; return 0;&#125; 做法二:概率期望$DP$(菜鸡我的做法) 下文中读入的$h,w$,分别设为$n,m$ 设$g[i][j]$为切了$i$刀，有$j$刀是横向切的的期望,纵向切的刀数$k$显然$=i-j$ 显然$g[i][j]=\sum f*val$,此处$f$表示其中一种切法的概率，$val$这种切法能得到的价值和。 我们去掉$val$,设$f[i][j]=\sum f$ 对于$f$数组的转移显然不难,$f[i][j]=f[i-1][j]\times \dfrac{m-(k-1)}{n+m-i}+f[i-1][j]\times \dfrac{n-(j-1)}{n+m-i}$ 但是$g$数组的转移就不简单了，我们考虑当前的$g[i][j]$如何从上一个状态转移过来。 之前说过$g[i][j]=\sum f*val$ $\qquad \qquad \qquad $$=f[i][j]\times (j+1)\times(k+1)$ 我们假设 就这样，式子就推出来了 $ans=\sum\limits_{i=1}^{n} g[K][i]$ 答案的寻找范围显然 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define int long long#define re register#define mod 1000000007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int g[2][5005],f[2][5005],ans,inv[10009];signed main()&#123; freopen("ahri.in", "r", stdin); freopen("ahri.out", "w", stdout); int n=read(),m=read(),k=read();inv[0]=inv[1]=1; for (int i=2;i&lt;=10007;++i)inv[i]=(mod-mod/i)*inv[mod%i]%mod; f[1][1]=n*inv[n+m]%mod;f[1][0]=m*inv[n+m]%mod;//概率 g[1][1]=2*n%mod*inv[n+m]%mod;g[1][0]=2*m%mod*inv[n+m]%mod;//期望 for (int i=2;i&lt;=k;++i)&#123; int now=i&amp;1;//滚存 memset(f[now],0,sizeof(f[now])); memset(g[now],0,sizeof(g[now])); for (int j=0;j&lt;=min(i,n);++j)&#123; if (i-j&gt;m)continue; int k=i-j; //考虑最后一刀横向切还是纵向切 int A=0,B=0; if (k!=0)&#123;//最后一刀纵向切 A=f[now^1][j]*(m-(k-1))%mod*inv[n+m-i+1]%mod; g[now][j]+=g[now^1][j]*(m-(k-1))%mod*inv[n+m-i+1]%mod+(j+1)*(k+1)%mod*A%mod; &#125; f[now][j]%=mod;g[now][j]%=mod; if (j!=0)&#123;//最后一刀横向切 B=f[now^1][j-1]*(n-(j-1))%mod*inv[n+m-i+1]%mod; g[now][j]+=g[now^1][j-1]*(n-(j-1))%mod*inv[n+m-i+1]%mod+(j+1)*(k+1)%mod*B%mod; &#125; f[now][j]=A+B;//概率相加 f[now][j]%=mod;g[now][j]%=mod; &#125; &#125; for (int i=0;i&lt;=n;++i) ans=(ans+g[k&amp;1][i])%mod;//统计答案 cout&lt;&lt;ans&lt;&lt;endl;&#125; 其他做法此外还有复杂度跟我的做法一样，但实现更简单一些的$DP$; 并且用$FFT$优化$xjh$大佬的$O(nlogn)$做法和一种$O(logK+logn+logm)$的神奇做法。]]></content>
      <tags>
        <tag>思维题</tag>
        <tag>概率期望$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 51nod有限背包计数问题]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%2051nod%E6%9C%89%E9%99%90%E8%83%8C%E5%8C%85%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接 很考验对背包的理解 对于$1$~$sqrt(n)$与$(sqrt(n)+$$1)$~$n,$我们可以用NOIP2001数的划分的类似做法，分别处理，显然$1$~$sqrt(n)$是个多重背包问题，$(sqrt(n)+$$1)$~$n$是个完全背包问题 对于$1$~$sqrt(n)$，我们可以用总方案数减去不合法的方案数(具体见代码注释)，并利用滚存优化空间 对于$(sqrt(n)+$$1)$~$n,$我们可以用NOIP2001数的划分的类似做法，将划分分成两种类型，进行$dp$转移 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3fusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int f[2][393939],g[319][100007],ans;signed main()&#123;// freopen("game.in", "r", stdin); freopen("game.out", "w", stdout); int n=read(),mod=read(); f[0][0]=1;//选0个的方案数为1 int sq=sqrt(n),now=0; for (int i=1;i&lt;=sq;++i)&#123; now^=1;//滚存 for (int j=0;j&lt;=n;++j)&#123; f[now][j]=f[now^1][j];//加上i-1的方案种数 if (j&gt;=i)f[now][j]+=f[now][j-i];//完全背包方案数的递推式 if (f[now][j]&gt;=mod)f[now][j]-=mod; if (j&gt;=i*(i+1))f[now][j]=f[now][j]-f[now^1][j-i*(i+1)]+mod;//减去不符合的方案数，即不在j-i*i到j范围内的方案数 if (f[now][j]&gt;=mod)f[now][j]-=mod; &#125; &#125;//前sqrt(n)个数进行多重背包计算方案 //g[i][j]表示选了i个,而不是选到第i种，和为j的方案数，注意i的含义与f[i][j]中的i的含义不一样 //类似NOIP2001数的划分的做法,所有划分成两种：//1.包含sqrt(n)+1(即最小的数)//2.不包含sqrt(n)+1的//一个dp状态的方案数就是由这两种划分构成的//对于第一种划分，只需要单独加上一份sqrt(n)+1即可，所以划分数等于f[i-1][j-(sqrt(n)+1)];//对于第二种划分，只需要给当前每份都加上1，每份就不可能等于sqrt(n)+1了，因为最小就是sqrt(n)+1,所以划分数就等于f[i][j+i]; g[0][0]=1;//选0个，和为0的方案数为1 if (sq+1&lt;=n)g[1][sq+1]=1;//选1个sqrt(n)+1(最小值) for (int i=1;i&lt;=sq;++i)&#123; for (int j=0;j&lt;=n;++j)&#123; if (j+sq+1&lt;=n)g[i+1][j+sq+1]+=g[i][j];//第一种划分 if (g[i+1][j+sq+1]&gt;=mod)g[i+1][j+sq+1]-=mod; if (j+i&lt;=n)g[i][j+i]+=g[i][j];//第二种划分 if (g[i][j+i]&gt;=mod)g[i][j+i]-=mod; &#125; &#125; for (int i=0;i&lt;=n;++i) for (int j=0;j&lt;=sq;++j)&#123; ans+=1ll*f[now][i]*g[j][n-i]%mod;// 最后枚举多少空间给前sqrt(n)个物品(剩下空间给其它物品) if (ans&gt;=mod)ans-=mod; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF632F 【Magic Matrix】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF632F%20%E3%80%90Magic%20Matrix%E3%80%91%2F</url>
    <content type="text"><![CDATA[最小生成树： 咋一看和最小生成树一点关系都没有，但是我们设$a_{i,j}$表示$i$到$j$的边的边权为$a_{i,j}$,然后观察本题的三个条件： $1.$对于每一个$i,j,a_{i,j}=a_{j,i}$(说明是无向图) $2.$对于每个$i,a_{i,i}=0$(表示没有自环) $3.$对于每个$i,j,k$,都有$a_{i,j}\leqslant max(a_{i,k},a_{k,j})$ 第三个条件说明的就是最小生成树 我们可以设$f_{i,j}$为$i$到$j$的任意路径的最长边的最小值，可得$a_{i,j}\geqslant f_{i,j}.$ 假设一个矩阵满足条件,则$a_{i,j}\leqslant max(a_{i,k_1}~,~a_{k_1,k_2}),a_{k_1,j}\leqslant max(a_{k_1,k_2},a_{k_2,j})\cdots\cdots$ $∴a_{i,j}\leqslant max(a_{i,k_1},a_{k_1,k_2},a_{k_2,k_3},\cdots,a_{k_m,j})$ $=f_{i,j}$ 判断矩阵是否合法，就是判断图上的$i$到$j$的任意路径的最长边的最小值是否等于$a_{i,j}$. 这可以用最小生成树实现,模拟一遍$Kruskal$会更好理解，从最小的边开始加，形成环显然走已经形成的路更优，加边到形成树就保证图联通了就没必要加边了 判断合法即判断完全图中是不是任意一个生成树都是最小生成树 具体实现就是以任意一个节点(我使用$1$)为根，记录每个节点的父节点$fa$,然后找一个$y$,如下图，如果$max(a,b)&lt;c$,那么就不符合最小生成树和题目给定条件了。 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define re registerusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,a[2555][2555],vis[2555],dis[2555],fa[2555],dep[2555];int main()&#123; int n=read(); for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++)a[i][j]=read(); for(re int i=1;i&lt;=n;i++) if(a[i][i])&#123; puts("NOT MAGIC\n"); return 0; &#125; for (re int i=1;i&lt;=n;++i) for (re int j=1+i;j&lt;=n;++j) if (a[i][j]!=a[j][i])&#123; puts("NOT MAGIC"); return 0; &#125; for (re int i=0;i&lt;=n;++i)fa[i]=i,dis[i]=1e9+1e8;dis[1]=0; for (re int i=1;i&lt;=n;++i)&#123; re int pos=0; for (re int j=1;j&lt;=n;++j) if (!vis[j]&amp;&amp;dis[pos]&gt;dis[j]) pos=j; vis[pos]=1; for (re int j=1;j&lt;=n;++j) if (!vis[j]&amp;&amp;a[pos][j]&lt;dis[j]) dis[j]=a[pos][j],fa[j]=pos,dep[j]=dep[pos]+1; &#125; for (re int i=1;i&lt;=n;++i) for (re int j=1;j&lt;=n;++j)&#123; re int x=i,y=j; if (max(a[x][fa[x]],a[fa[x]][y])&lt;a[x][y]) return puts("NOT MAGIC"),0; if (max(a[x][fa[y]],a[fa[y]][y])&lt;a[x][y]) return puts("NOT MAGIC"),0; &#125; puts("MAGIC"); return 0;&#125;]]></content>
      <tags>
        <tag>思维题</tag>
        <tag>最小生成树</tag>
        <tag>神仙题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 牛客练习赛6 手铐]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B6%20%E6%89%8B%E9%93%90%2F</url>
    <content type="text"><![CDATA[链接：牛客练习赛6手铐 $Description$给你一个连通无向图，保证每个点最多属于一个简单环，每个点度数最多为$3$，求这个图有多少“手铐图形个数” 其中“手铐图形个数”，定义为三元组$(x,y,S)$，其中$x$和$y$表示图上的两个点，$S$表示一条$x$到$y$的简单路径，而且必须满足： $1.x$和$y$分别在两个不同的简单环上 $2.x$所在的简单环与路径$S$的所有交点仅有$x,y$所在的简单环与路径$S$的所有交点仅有$y$。 $(x,y,S)$与$(y,x,S)$算同一个手铐 $Solution:$我们考虑把环给缩掉，缩了之后的点叫做方点，然后本来树上的点叫做圆点 缩完后变成 首先手铐两端都必须是一个方点，然后可以发现如果一条两端都是方点的路径上总共有$x$个方点(不包括两端的方点)，则这两个端点可以构成$2^{x}$个手铐（每次可以走两端） 如图这构成了4个手铐 由于无向图缩点后一定形成一棵树，我们考虑对于生成的这个树进行树形$DP$用$f[u]$表示以$u$为根的子树，到$u$构成的“一半的手铐”的数量也就是说这样的： 半手铐维护的方法就是 如果u是圆点，则$f[u]=\sum f[v]$; 如果u是方点，则$f[u]=(\sum f[v])\times 2 + 1$; 因为下面上来的每个半手铐都可以走两个方向，然后这个点也可以作为一个半手铐的端点 在跑树形$DP$时顺便统计答案。 对于每个节点$u$,我们强制它的贡献就是手铐的两端在它的两颗子树中，或是一个在子树中，一个是它自己。 对于手铐的两端在它的两颗子树中，只要算出$\frac{\sum f[v]\times(sum-f[v])}{2}$即可 当节点$u$是方点时，贡献还要$\times 2$再加上所有子树中的半手铐个数(即$u$节点与子树中半手铐匹配) $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 2003000#define mod 19260817using namespace std;struct node&#123; int to,next;&#125;e[N&lt;&lt;1];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,m,u[N],v[N],cnt=1,head[N],dfn[N],low[N],ans,f[N],st[N],top,num,col,w[N],color[N];inline int inv2()&#123;return (mod-mod/2)%mod;&#125;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void Tarjan(int u,int E)&#123; dfn[u]=low[u]=++num; st[++top]=u; for (int i=head[u];i;i=e[i].next)&#123; if (i==(E^1))continue; int v=e[i].to; if (!dfn[v])&#123; Tarjan(v,i); low[u]=min(low[u],low[v]); &#125;else if (!color[v]) low[u]=min(low[u],dfn[v]); &#125; if (low[u]==dfn[u])&#123; ++col; do&#123; ++w[col];color[st[top--]]=col; &#125;while (st[top+1]!=u); &#125;&#125;void dfs1(int u,int fa)&#123; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs1(v,u); f[u]=(f[u]+f[v]*w[u]%mod)%mod; &#125; f[u]+=w[u]==2;&#125;void dfs(int u,int fa)&#123; int res=0,sum=(w[u]==2?(f[u]-1)*inv2()%mod:f[u]); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs(v,u); res=(res+w[u]*f[v]%mod*((sum-f[v]+mod)%mod))%mod; &#125; ans=(ans+res*inv2()%mod)%mod; if (w[u]==2)ans=(ans+sum)%mod;&#125;signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=m;++i)&#123; u[i]=read(),v[i]=read(); add(u[i],v[i]);add(v[i],u[i]); &#125; for (int i=1;i&lt;=n;++i) if (!dfn[i]) Tarjan(i,0); for (int i=1;i&lt;=col;++i)w[i]=(w[i]&gt;1)+1; memset(head,0,sizeof(head));cnt=0; for (int i=1;i&lt;=m;++i) if (color[u[i]]!=color[v[i]])&#123; add(color[u[i]],color[v[i]]); add(color[v[i]],color[u[i]]); &#125; dfs1(1,0); dfs(1,0); cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>树形$DP$</tag>
        <tag>$Tarjan$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF24D 【Broken robot】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF24D%20%E3%80%90Broken%20robot%E3%80%91%2F</url>
    <content type="text"><![CDATA[设状态$f[i][j]$为从坐标$(i,j)$走到最后一行的期望 此时需要分类讨论,由于$f[n]j=0$，所以我们倒着枚举行,也可感性理解为从最后一行走到第x行 当$j=1$时，$f[i][1]=\frac{1}{3}f[i][1]+\frac{1}{3}f[i][2]+\frac{1}{3}f[i+1][1]+1$ 当$j=m$时，$f[i][m]=\frac{1}{3}f[i][m]+\frac{1}{3}f[i][m-1]+\frac{1}{3}f[i+1][m]+1$ 当$1&lt;j&lt;m$时，$f[i][j]=\frac{1}{4}f[i][j-1]+\frac{1}{4}f[i][j]+\frac{1}{4}f[i][j+1]+\frac{1}{4}f[i+1][j]+1$ 然后我们发现这个式子是有后效性的，所以要$dp+$高斯消元。 为了更好高斯消元，我们可以压掉第一维，式子中的$f[i+1]$计为数组$last$。(但我实现上还是用了两维) 经过移项化简后得到： 当$j=1$时，$2f[1]-f[2]=last[i] + 3$ 当$j=m$时，$-f[m-1]+2f[m]=last[m]+3$ 当$1&lt;j&lt;m$时，$-f[j-1]+3f[j]-f[j+1]=last[j]+4$ 由于是倒着枚举，所以$last$数组在转移前已经知道了，这就完全是个高斯消元的式子了，用矩阵表示就会变成下面这个样子 $\begin{bmatrix}2\ &amp;-1\ &amp;0\ &amp;0\ &amp;0\-1\ &amp;3\ &amp;-1\ &amp;0\ &amp;0\0 &amp;-1\ &amp;3\ &amp;-1\ &amp; 0\0\ &amp;0\ &amp;-1\ &amp;3\ &amp;-1\0\ &amp;0\ &amp;0\ &amp;-1\ &amp;2\end{bmatrix}$ 用高斯消元显然会T，但是我们发现每行最多只有$3$个非$0$元素,所以我们可以暴力模拟高斯消元求解,最后答案就是$f[x][y]$ 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define mod 1000000007#define ll long longusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;double f[1007][1007],a1[1007],a2[1007],a3[1007],c[1007];//c数组为方程组'='右边的值，a1,a2,a3分别表示一行中三个元素的值，f数组即为转移数组signed main()&#123; int n=read(),m=read(),x=read(),y=read(); if (m==1)&#123; printf("%.10lf",2.0*(n-x)); return 0; &#125; for (int i=n-1;i&gt;=x;--i)&#123; for (int j=1;j&lt;=m;++j)c[j]=f[i+1][j]+4.0; c[1]-=1.0;c[m]-=1.0; a1[1]=0;a2[1]=2.0;a3[1]=-1.0; for (int j=2;j&lt;=m-1;++j)a1[j]=-1,a2[j]=3,a3[j]=-1; a1[m]=-1;a2[m]=2;a3[m]=0; for (int j=2;j&lt;=m;++j)&#123; double z=a1[j]/a2[j-1]; a2[j]-=z*a3[j-1]; c[j]-=c[j-1]*z; &#125; f[i][m]=c[m]/a2[m]; for (int j=m-1;j;--j)f[i][j]=(f[i][j+1]+c[j])/a2[j]; &#125; printf("%.10lf",f[x][y]);&#125;]]></content>
      <tags>
        <tag>概率期望$DP$</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SRM 563 Div1 500 SpellCards]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20SRM%20563%20Div1%20500%20SpellCards%2F</url>
    <content type="text"><![CDATA[$Description$有$n$张符卡排成一个队列，每张符卡有两个属性，等级$l_{i}$和伤害$d_{i}$。你可以做任意次操作，每次操作为以下二者之一： $1$. 把队首的符卡移动到队尾。 $2$. 使用队首的符卡，对敌人造成$d_{i}$点伤害，并丢弃队首的$l_{i}$张符卡（包括你所使用的符卡）。如果队列不足$l_{i}$张符卡那么你不能使用。 求出造成的伤害的总和的最大值。 $1$$\leqslant$$n$$\leqslant$$50,1$$\leqslant$$l_{i}$$\leqslant$$50,1$$\leqslant$$d_{i}$$\leqslant$$10000$ $Solution:$我们可以把原问题简化成在环上操作，这样第一个操作就被简化掉了 设我们选的集合的点的$l_{i}$为$L_{i}$，注意这里集合内的所有的$L_{i}$是可重的，也就是可以覆盖下一个点，例如下图是合法的。 显然我们只需要满足$\sum L_{i}\leqslant$$n$就行了 我们发现一定有一个点没有覆盖下一个点，证明：如果每个点都覆盖了下一个点，那么整个环一定被完全覆盖了，再加上重叠的部分，$\sum L_{i}$不会$\leqslant$$n$，所有一定有一个点没有覆盖下一个点 那么，我们就可以直接用掉这个点$L_{i}$包含的区间，此时$n-=L_{i}$,剩下的$\sum L_{i}$依然满足$\leqslant$$n$，这个点的上一个点就变成了没有覆盖下一个点的点了，就可以一直删，直到删完。 然后我们发现就是一个裸的背包问题 $Code:$123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3fusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int f[60],l[60],d[60];int main()&#123; int n=read(); for (int i=1;i&lt;=n;++i)l[i]=read(); for (int i=1;i&lt;=n;++i)d[i]=read(); for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) f[j]=max(f[j],f[j-l[i]]+d[i]); printf("%d",f[n]); return 0;&#125;]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 bzoj4668冷战]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20bzoj4668%E5%86%B7%E6%88%98%2F</url>
    <content type="text"><![CDATA[bzoj4668: 冷战 并查集按秩合并$+LCA$找最大。 并查集按秩合并：复杂度为$O(nlogn)$，稍劣于路径压缩，但优点在于保留了树形结构，对于每个并查集记录一个值$rank$，初始值为$1$，表示树高，每次将$rank$小的并查集根节点合并到$rank$大的并查集根节点上(即把$f[find(x)]$赋值成$find(y))$，并将$v[x]$赋为$cnt$(即当前是第几次合并)这时$rank$不变，若两个并查集$rank$相同，则将一个合并到另一个,将$v[x]$赋值$,rank[find(y)]++;$ 在$find$函数中，每次在回溯过程中更新每个点的一个值$deep$，表示它的深度$(deep[k]=deep[f[k]]+1;)$ 若$opt=0$，每次用并查集按秩合并两个点. 若$opt=1$，则用暴力求$LCA$的方法从一个点不停的走向它的父亲，直到它的$deep\geqslant$另一个点的$deep$，此时若$deep[x]==deep[y]$,则退出，否则交换$x$与$y$，继续进行上述过程，直到$x==y$，在过程中不断更新$v[x]$的最大值，记录在变量$ans$中，并返回$ans$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define re register #define dd c=getchar()using namespace std;inline int read() &#123;int s=0,w=1;char c;while (dd,c&gt;'9' || c&lt;'0') if (c=='-') w=-1;while (c&gt;='0' &amp;&amp; c&lt;='9') s=s*10+c-'0',dd;return s*w;&#125;#undef ddinline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;int lastans,f[600000],cnt,dep[600000],v[600000],rank[600000];int find(int k)&#123; if (f[k]==k)return k; int o=find(f[k]); dep[k]=dep[f[k]]+1; return o;&#125;void merge(int x,int y,int z)&#123; x=find(x),y=find(y); if (x==y)return; if (rank[x]&gt;rank[y])swap(x,y); if (rank[x]==rank[y])rank[y]++; f[x]=y;v[x]=z;&#125;int lca(int x,int y)&#123; if (find(x)!=find(y))return 0; int ans=0; while (x!=y)&#123; if (dep[x]&lt;dep[y])swap(x,y); ans=max(ans,v[x]); x=f[x]; &#125; return ans;&#125;int main()&#123; freopen("build.in","r",stdin); freopen("build.out","w",stdout); int n=read(),m=read(); for (int i=1;i&lt;=n;++i)f[i]=i,rank[i]=1;//初始化 for (int i=1;i&lt;=m;++i)&#123; int opt=read(),x=read()^lastans,y=read()^lastans; if (opt)&#123; lastans=lca(x,y); wln(lastans); &#125;else&#123; cnt++; merge(x,y,cnt); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>按秩合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF780F 【Axel and Marston in Bitland】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF780F%20%E3%80%90Axel%20and%20Marston%20in%20Bitland%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目要求第$i$个是由第$i-1$个和（第$i-1$个取反）拼在后面。 求最长路。 因此可以用倍增的思想进行$dp$，$dp$思路在代码中。可以用$bitset$优化 最后选取时从长的往短的枚举，在加的过程中大于$1e18$就退出 听说好像可以用矩乘优化，但蒟蒻我不会 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;bitset&lt;505&gt;f[2][65][505],t,pre;//f[p][s][x][y]表示第一条边为p类型，x与y之间有2的s次方的路径存不存在ll ans;int main()&#123; int n=read(),m=read(); while (m--)&#123; int x=read(),y=read(),t=read(); f[t][0][x][y]=1; &#125;// 转移方程:f[p][s][x][y]|=(f[p][s][x][k]&amp;f[p^1][s][k][y]) k为枚举的中转点 //最后一位可以用bitset压掉，即if (f[p][s-1][x][k]) f[p][s][x]|=f[p^1][s-1][k] for (int s=1;s&lt;=60;++s)//s为路径长度是2的多少幂次 for (int p=0;p&lt;=1;++p)//p为第一条边的类型 for (int x=1;x&lt;=n;++x)//x为起点 for (int k=1;k&lt;=n;++k)//k为枚举的中转点 if (f[p][s-1][x][k]) f[p][s][x]|=f[p^1][s-1][k]; for (int i=1;i&lt;=n;++i) if (f[0][60][1][i])&#123; puts("-1");return 0; &#125; int now=0;pre[1]=1;//一开始只有节点1可以作为起点 for (int s=59;s&gt;=0;--s)&#123;// 贪心得选，能选长的就选长的 t.reset(); for (int i=1;i&lt;=n;++i) if (pre[i])//pre数组表示当前可不可以选为起点 t|=f[now][s][i];//t数组表示从当前可选的起点走接下来能到达的点 if (t.count())&#123; pre=t; now^=1; ans+=(1ll&lt;&lt;s); if (ans&gt;1e18)&#123;puts("-1");return 0;&#125; &#125; &#125; printf("%I64d",ans);&#125;]]></content>
      <tags>
        <tag>$DP$</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2444 【[POI2000]病毒】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2444%20%E3%80%90%5BPOI2000%5D%E7%97%85%E6%AF%92%E3%80%91%2F</url>
    <content type="text"><![CDATA[很考验对$fail$指针的理解,假设我们构造出了一个无限长的安全代码，再到$AC$自动机上匹配，从原点出发，向下走遇到一个环，然后不停地在这个环上跳转(无法理解就手玩样例)，且这个环上没有危险节点(即病毒单词最后一个字母在$Trie$树上的位置) 注意：这个环不包括$fail$指针,但是包括优化边(即如果节点$i$的某个字符儿子为空，那么这个儿子存为$i$的$fail$指针指向的节点的相同字符儿子)(有点绕,放张样例构成的$trie$图) 黑边是$trie$树上的正常边，蓝边是在处理$AC$自动机时连上的优化边，红边是$fail$指针。灰色节点即危险节点 这里的环只由蓝边和黑边构成的，即不考虑走$fail$指针， 这样，问题就变成了找一个从根节点出发能在不经过危险节点的情况下走到到的环，且环上没有危险节点。 注意：如果某个点的$fail$指针指向的点是有危险节点，那么该节点也是危险节点 接下来$dfs$找环，找到就输出属于基础图论。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 1000007using namespace std;struct node&#123; int fail,cnt,ch[2];&#125;f[N&gt;&gt;1];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ans,cnt,ok[N],vis[N];char s[N];queue&lt;int&gt;q;inline void build(char *s)&#123; int len=strlen(s),now=0; for (int i=0;i&lt;len;++i)&#123; int v=s[i]-'0'; if (!f[now].ch[v])f[now].ch[v]=++cnt; now=f[now].ch[v]; &#125; f[now].cnt=1;&#125;inline void build_fail()&#123; for (int i=0;i&lt;2;++i)if (f[0].ch[i])q.push(f[0].ch[i]); while (!q.empty())&#123; int u=q.front();q.pop(); for (int i=0;i&lt;2;++i) if (f[u].ch[i])&#123; f[f[u].ch[i]].fail=f[f[u].fail].ch[i]; f[f[u].ch[i]].cnt|=f[f[f[u].fail].ch[i]].cnt; q.push(f[u].ch[i]); &#125;else f[u].ch[i]=f[f[u].fail].ch[i]; &#125;&#125;void dfs(int now)&#123; if (ok[now])&#123;puts("TAK");exit(0);&#125; if (vis[now]||f[now].cnt)return; vis[now]=ok[now]=1; if (f[now].ch[0])dfs(f[now].ch[0]); if (f[now].ch[1])dfs(f[now].ch[1]); ok[now]=0;&#125;signed main()&#123; int n=read(); for (int i=1;i&lt;=n;++i)&#123; scanf("%s",s); build(s); &#125; build_fail(); dfs(0); puts("NIE"); return 0;&#125;]]></content>
      <tags>
        <tag>$AC$自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1155D 【Beautiful Array】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF1155D%20%E3%80%90Beautiful%20Array%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给定一个值$x$,一个长度为$n$的数组$a$，你可以选择一段区间，让这段区间每个数都乘上$x$,求最大连续子段和 $Solution:$三个数组,$f_{i}$表示以$i$结尾的最大子段和,$g_{i}$表示选定区间还未完结($a_{i}$乘上$x$)的最大子段和，$h_{i}$表示已经选定区间已经在$1$~$(i-1)$中一处结尾$(a_{i}$不乘$x)$ $f_{i}=max(f_{i-1},0)+a_{i}$ $g_{i}=max(g_{i-1},f_{i-1},0)+a_{i}\times x$ $h_{i}=max(h_{i-1},g_{i-1},0)+a_{i}$ $ans=max(h_{i},g_{i})$ $Code$12345678910111213141516#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;signed main()&#123; int n=read(),m=read(),ans=0,a,f=0,g=0,h=0; for (int i=1;i&lt;=n;++i) a=read(),h=max(h,max(g,0ll))+a,g=max(g,max(0ll,f))+a*m,f=max(f,0ll)+a,ans=max(ans,max(h,max(f,g))); cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3393 【逃离僵尸岛】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P3393%20%E3%80%90%E9%80%83%E7%A6%BB%E5%83%B5%E5%B0%B8%E5%B2%9B%E3%80%91%2F</url>
    <content type="text"><![CDATA[题意：有$N$个点，$M$条双向边，$K$个被侵略城市，与这$K$个被侵略城市距离$\leqslant$$S$的城市就是危险城市。其他就是安全城市。安全城市的点权就是$P$，危险城市的点权就是$Q$,问才$1$号点到$N$号点的最小花费。 标记危险城市显然需要跑最短路，但是对于$K$个点跑$K$次最短路时间复杂度太高，于是我们建立虚点连接$K$个点，边权为$0$,原先道路边权为$1$,跑最短路即可，这样就可以找到所有危险城市了。 对于点权最短路，我们只需要将到达点的权值设为边权即可，对于到达点是危险城市或是$1$或$N$特判。 记得开$long long$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3fusing namespace std;struct node&#123; int to,next,dis;&#125;e[499999];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt,head[400000],dis[300000],inque[300000],tag[300000];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt;&#125;void spfa(int s)&#123; memset(dis,0x3f,sizeof(dis)); memset(inque,0,sizeof(inque)); dis[s]=0;queue&lt;int&gt;q;q.push(s); while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (dis[v]&gt;dis[u]+e[i].dis)&#123; dis[v]=dis[u]+e[i].dis; if (!inque[v])&#123; inque[v]=1;q.push(v); &#125; &#125; &#125; &#125;&#125;signed main()&#123; int n=read(),m=read(),k=read(),s=read(),p=read(),q=read(); for (int i=1;i&lt;=k;++i)&#123; int t=read(); tag[t]=2; add(0,t,0); &#125; for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); add(u,v,1);add(v,u,1); &#125; spfa(0); for (int i=1;i&lt;=n;++i) tag[i]=tag[i]==0?dis[i]&lt;=s:2; for (int i=1;i&lt;=cnt;++i)&#123; if (tag[e[i].to]==2)&#123;e[i].dis=inf;continue;&#125; if (e[i].to==n||e[i].to==1)&#123;e[i].dis=0;continue;&#125; if (tag[e[i].to]==1)&#123;e[i].dis=q;continue;&#125; else e[i].dis=p; &#125; spfa(1); printf("%lld",dis[n]); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3959 【宝藏】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P3959%20%E3%80%90%E5%AE%9D%E8%97%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[在任意时刻，我们关心的只有我们已经把多少点加进树了，以及树的最大树高是多少。 设$f[S][i]$为当前树已经包含集合$S$中的点，并且树高是$i$。 那么怎么判断$S_{0}$在转移中是否合法呢？我们设$G_{S}$是$S$能拓展到的边的集合，显然$G$数组是可以预处理出来的。 $f[S][i]=min(f[S_0][i-1]+pay)$，其中满足$S_{0}$是$S$的子集，通过$S_{0}$加边一定可以联结成$S$。$pay$是这次加边的花费。 设$ss=S~xor~S_{0}$，即$ss$是在$S$但不在$S_{0}$中的元素。 这里$pay$的计算显然是对于每个$ss$中的元素找$S_{0}$中的元素与它最短一条的边求和后$\times $树高(即$i$)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3fusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt,ma[393939],head[393939],f[15][40000],dis[39][39],ans;signed main()&#123; int n=read(),m=read();memset(dis,0x3f,sizeof(dis)); for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),d=read(); dis[v][u]=dis[u][v]=min(dis[v][u],d); &#125; memset(f,0x3f,sizeof(f)); for (re int i=1;i&lt;=n;++i)dis[i][i]=0,f[0][1&lt;&lt;(i-1)]=0; for (re int i=1;i&lt;=(1&lt;&lt;n)-1;++i) for (re int j=1;j&lt;=n;++j) if (i&amp;(1&lt;&lt;(j-1))) for (re int k=1;k&lt;=n;++k) if (dis[j][k]!=inf) ma[i]|=1&lt;&lt;(k-1); for (int s=2;s&lt;=(1&lt;&lt;n)-1;++s) for (re int i=s-1;i;i=s&amp;(i-1)) if ((s|ma[i])==ma[i])&#123; int res=0,st=s^i; for (re int k=1;k&lt;=n;++k) if (st&amp;(1&lt;&lt;(k-1)))&#123; int t=inf; for (re int p=1;p&lt;=n;++p) if (i&amp;(1&lt;&lt;(p-1))) t=min(t,dis[p][k]); res+=t; if (res&gt;inf)break; &#125; if (res&lt;inf) for (re int t=1;t&lt;n;++t) f[t][s]=min(f[t][s],f[t-1][i]+res*t); &#125; ans=inf; for (int i=0;i&lt;n;++i) ans=min(ans,f[i][(1&lt;&lt;n)-1]); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>状压$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1453 【城市环路】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1453%20%E3%80%90%E5%9F%8E%E5%B8%82%E7%8E%AF%E8%B7%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[会了这道题就可以顺便$A$了P2607 [ZJOI2008]骑士 由于只有$n$条边，每个点之间互通，所以图就是一颗基环树 所以只需要$dfs$找环，在环上找任意一条边，枚举这条边的两端中其中一端不选(因为两端不能同时选，所以至少有一端不选)，然后进行树形$dp$即可，由于然后这道题就和没有上司的舞会一样了。 dfs找环：一边走一边用一个$vis$数组标记，回溯时$vis$清零，如果当前点的儿子上有$vis$标记,那么这个点和它的儿子就在环上。 树形$dp$:设$f[u][0/1]$表示u这个节点选$(0)$或不选$(1)$的最大价值（这里$v$表示u的所有子节点) $f[u][1]=\sum f[v][0]$ $f[u][0]=\sum max(f[v][0],f[v][1])$ 答案就是$f[root][0]$,这里的$root$就是枚举的一端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 393939*7using namespace std;struct node&#123; int to,next;&#125;e[N&lt;&lt;1];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int now,la,n,ans,cnt,head[N],f[N][2],vis[N],fa[N],v[N];inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa,int rt,int unrt)&#123; f[u][0]=0;f[u][1]=v[u];vis[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa||(u==rt&amp;&amp;v==unrt))continue; if (v!=rt)&#123; dfs(v,u,rt,unrt); f[u][1]+=f[v][0]; f[u][0]+=max(f[v][1],f[v][0]); &#125; &#125;&#125;void dfss(int u,int fa)&#123; vis[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; if (vis[v])&#123;la=v;now=u;return;&#125; dfss(v,u); &#125; vis[u]=0;&#125;void lxy(int u)&#123; now=u,la=0; dfss(u,0); dfs(now,0,now,la); int res=f[now][0]; dfs(la,0,la,now); ans+=max(res,f[la][0]); return;&#125;signed main()&#123; n=read(); for (int i=1;i&lt;=n;++i) v[i]=read(); for (int i=1;i&lt;=n;++i)&#123; int u=read()+1,v=read()+1; add(u,v);add(v,u); &#125; double K; scanf("%lf",&amp;K); for (int i=1;i&lt;=n;++i) if (!vis[i]) lxy(i); double res=1.0*K*ans; printf("%.1lf",res); return 0;&#125;]]></content>
      <tags>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT2164 【Rabbit Exercise】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20AT2164%20%E3%80%90Rabbit%20Exercise%E3%80%91%2F</url>
    <content type="text"><![CDATA[当$k=1$时，$a[i]=\frac{1}{2}[a[i-1]-(a[i]-a[i-1])]+\frac{1}{2}[a[i+1]+(a[i+1]-a[i])]$ 经过化简后$a[i]=a[i+1]+a[i-1]-a[i]$,用差分数组表示就是: $c[i]=a[i]-a[i-1]$ $c[i]=(a[i+1]+a[i-1]-a[i])-a[i-1]$ $c[i]=a[i+1]-a[i]$ $c[i]=c[i+1]$ $c[i+1]=a[i+1]-a[i]$ $c[i+1]=a[i+1]-(a[i+1]+a[i-1]-a[i])$ $c[i+1]=a[i]-a[i-1]$ $c[i+1]=c[i]$ 然后我们发现一次运算就是把$c[i]$与$c[i+1]$交换，于是$k$轮跳转就相当于$k$次交换，然后利用类似快速幂的方法求解 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define mod 1000000007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int a[100007],c[100007],v[100007],t[100007],n;inline void ksm(int p)&#123; while (p)&#123; if (p&amp;1)&#123; for (int i=1;i&lt;=n;++i)t[i]=c[v[i]]; for (int i=1;i&lt;=n;++i)c[i]=t[i]; &#125; for (int i=1;i&lt;=n;++i)t[i]=v[v[i]]; for (int i=1;i&lt;=n;++i)v[i]=t[i]; p&gt;&gt;=1; &#125;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(),c[i]=a[i]-a[i-1],v[i]=i; int m=read(),k=read(); for(int i=1;i&lt;=m;i++)&#123; int x=read(); swap(v[x],v[x+1]); &#125; ksm(k); double sum=0; for (int i=1;i&lt;=n;++i)&#123; sum+=c[i]; printf("%.1lf\n",sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT2364 【Colorful Balls】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20AT2364%20%E3%80%90Colorful%20Balls%E3%80%91%2F</url>
    <content type="text"><![CDATA[显然如果有三个球$a,b,c$,如果$a$与$b$能交换,$b$与$c$能交换，那$a$与$c$一定能通过$b$的“媒介”交换（$a$先于$b$交换，$b$与$c$交换，$a$与$b$交换）。 于是我们可以把$a,b,c$缩在同一个连通块里。 由于不同颜色与相同颜色交换条件是不一样的，我们先考虑相同颜色。 显然只需要用最小值做“媒介”即可。 然后我们考虑跨颜色交换。我们发现只需要用全局最小值做“媒介”，也就是说对于某个点，先通过该颜色最小值换到全局最小值，再通过全局最小值换到其他点。如果与全局最小值颜色相同，那我们就只能用次小值做媒介。 这样我们只需要记录某种颜色的最小值、全局最小值、全局次小值即可。 然后我们不难发现含有不同颜色的连通块只有一个，那就是全局最小值所在的连通块。 而只有一种颜色的连通块对答案没有影响。 于是我们只考虑最小值所在的连通块。首先我们找到全局最小值、全局次小值与每种颜色的最小值。如果他们都不能交换，那显然是凉了（答案为11）。我们对每种颜色数出能与该种颜色最小值交换的点数，然后用每种连通块的最小值与全局最小值（全局次小值）比较，求出这个联通块。我们发现就是求这个联通块排列方案数，其实就是可重集合排列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define int long long#define mod 1000000007#define N 200007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ksm(int x,int k)&#123; int res=1; while(k)&#123; if(k&amp;1)res=res*x%mod; x=x*x%mod; k&gt;&gt;=1; &#125; return res;&#125;int mn[N],c[N],w[N],cnt[N],jc[N],inv[N],n,A,B,ans;signed main()&#123;// freopen("keep.in", "r", stdin); freopen("keep.out", "w", stdout); n=read(),A=read(),B=read(); memset(mn,0x3f,sizeof(mn)); jc[0]=1; for(int i=1;i&lt;=n;i++)jc[i]=jc[i-1]*i%mod; inv[n]=ksm(jc[n],mod-2); for(int i=n-1;i&gt;=0;i--)inv[i]=inv[i+1]*(i+1)%mod; for (int i=1;i&lt;=n;++i)&#123; c[i]=read(),w[i]=read(); mn[c[i]]=min(mn[c[i]],w[i]);//颜色集合最小值 ++cnt[c[i]];//集合元素个数 &#125; int Mn=1,mnn=inf; for (int i=1;i&lt;=n;++i) if (mn[i]&lt;mn[Mn]) Mn=i;//找出全局最小值的颜色 for (int i=1;i&lt;=n;++i) if (i!=Mn) mnn=min(mn[i],mnn);//找出除全局最小值的集合以外的所有数的最小值 for (int i=1;i&lt;=n;++i)&#123; if (w[i]!=mn[c[i]]&amp;&amp;w[i]+mn[c[i]]&lt;=A)continue;//如果这个值不是所在集合的最小值但它与所在集合的最小值的和小于A，那么它是有意义的 if (c[i]!=Mn&amp;&amp;w[i]+mn[Mn]&lt;=B)continue;//如果这个值不在全局最小值所在的集合中 ，但它与全局最小值的和小于B，那么它是有意义的 if (c[i]==Mn&amp;&amp;w[i]+mnn&lt;=B)continue;//如果它在全局最小值所在的集合中，且它与除全局最小值的集合以外的所有数的最小值的和小于B，那么它是有意义的 --cnt[c[i]];//如果它不符合以上条件，那么它的存在是没有意义的 &#125; int num=cnt[Mn]; for (int i=1;i&lt;=n;++i) if (i!=Mn&amp;&amp;mn[Mn]+mn[i]&lt;=B)//如果这种颜色存在且它不是全局最小值所在的集合 num+=cnt[i]; ans=1; for (int i=1;i&lt;=n;++i) if(mn[i]!=inf&amp;&amp;(i==Mn||mn[i]+mn[Mn]&lt;=B)) ans=ans*inv[cnt[i]]%mod; for (int i=1;i&lt;=num;++i) ans=ans*i%mod;//这里是求有重复元素的排列种数 printf("%lld",ans);&#125;]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1357 花园]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1357%20%E8%8A%B1%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[我们用一个$m$位二进制数表示后$m$个花圃的状态，$1$表示为$M$. 那么令$f[i][j]$表示由状态$i$转移到状态$j$的方案数（$i$和$j$都合法，即1的个数不超过$k$）。($Floyd$矩阵) 所谓转移，是指如果$i$表示第$1$～$m$个花圃的状态，那么$j$代表第$2$～第$m+1$个花圃的状态。 那么怎么求得$f[i][j]$呢？ 枚举一个长度为$m-1$的状态，在它前面加$0/1$即是$i$，在它后面加$0/1$即是$j$，在过程中判断$1$的个数会不会超过$k$即可。 由于是个环，所以实质上有$n+m$个花圃，第$n+1~n+m$个花圃就相当于第$1～m$个花圃，所以我们求的答案就是一个合法状态转移$n$次，转移回原状态的方案数之和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define mod 1000000007using namespace std;int n,m,k,t,o[39+39],ans;struct node&#123; int a[39+39][39+39]; inline void init()&#123; for (int i=0;i&lt;=t;++i) for (int j=0;j&lt;=t;++j) if (i==j) a[i][i]=1; else a[i][j]=0; &#125; inline void init0()&#123;memset(a,0,sizeof(a));&#125; friend node operator * (node a,node b)&#123; node c;c.init0(); for (int i=0;i&lt;=t;++i) for (int k=0;k&lt;=t;++k) for (int j=0;j&lt;=t;++j)&#123; c.a[i][j]+=1ll*a.a[i][k]*b.a[k][j]%mod; if (c.a[i][j]&gt;mod)c.a[i][j]-=mod; &#125; return c; &#125; friend node operator ^ (node a,int p)&#123; node res; res.init(); while(p)&#123; if(p&amp;1) res=res*a; p&gt;&gt;=1; a=a*a; &#125; return res; &#125;&#125;f;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline int count(int x)&#123; int res=0; while (x)&#123; res+=x&amp;1; x&gt;&gt;=1; &#125; return res;&#125;signed main()&#123; n=read(),m=read(),k=read(); t=(1&lt;&lt;m)-1; for (int i=0;i&lt;=t&gt;&gt;1;++i)&#123; int num=count(i); if (num&lt;=k)&#123; o[i]=1,o[i&lt;&lt;1]=1; f.a[i][i&lt;&lt;1]=1; &#125; if (num+1&lt;=k)&#123; o[i|(1&lt;&lt;m-1)]=1,o[i&lt;&lt;1|1]=1; f.a[i][i&lt;&lt;1|1]=1; f.a[i|(1&lt;&lt;m-1)][i&lt;&lt;1]=1; f.a[i|(1&lt;&lt;m-1)][i&lt;&lt;1|1]=1; &#125; &#125; f=f^n; for (int i=0;i&lt;=t;++i) if (o[i]) ans=(ans+f.a[i][i])&gt;=mod?ans+f.a[i][i]-mod:ans+f.a[i][i]; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
        <tag>状压$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF718C 【Sasha and Array】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF718C%20%E3%80%90Sasha%20and%20Array%E3%80%91%2F</url>
    <content type="text"><![CDATA[众所周知，快速求$Fibonacci$第$n$项的方法是用矩阵乘法，即原始矩阵$(21)$$Fibonacci$矩阵^$(n-2)$,所以我们可以想到将$n$加上$k$相当于给$f[n]$乘上$Fibonacci$矩阵^$k$，所以我们可以想到线段树维护矩阵 对于第一个问题：由于矩阵具有分配律，即$a×b+a×c=a×(b+c)$，所以对于一段区间的矩阵可以相加维护。 对于第二个问题，显然将$[l,r]$的矩阵乘上转移矩阵的$x$次方即可。 用线段树维护即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define ls(k) (k&lt;&lt;1)#define rs(k) (k&lt;&lt;1|1)#define mod 1000000007#define getchar() (p1==p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf;using namespace std;struct node&#123; int a[3][3]; inline void init()&#123; a[1][1]=a[2][2]=1;a[1][2]=a[2][1]=0; &#125; inline void init0()&#123; a[1][1]=a[2][2]=a[1][2]=a[2][1]=0; &#125; inline void init1()&#123; a[1][1]=a[2][1]=a[1][2]=1;a[2][2]=0; &#125; friend node operator + (node aa,node bb)&#123; for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=1;j++)&#123; aa.a[i][j]=(aa.a[i][j]+bb.a[i][j]); if (aa.a[i][j]&gt;mod)aa.a[i][j]-=mod; &#125; return aa; &#125; friend node operator * (node a,node b)&#123; node c;c.init0(); for (int i=1;i&lt;=2;++i) for (int k=1;k&lt;=2;++k) for (int j=1;j&lt;=2;++j)&#123; c.a[i][j]+=1ll*a.a[i][k]*b.a[k][j]%mod; if (c.a[i][j]&gt;mod)c.a[i][j]-=mod; &#125; return c; &#125; friend node operator ^ (node a,int p)&#123; node res; res.init(); while(p)&#123; if(p&amp;1) res=res*a; p&gt;&gt;=1; a=a*a; &#125; return res; &#125;&#125;f[100005],p,jz[500005],tag[500005];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;inline bool check(node tag)&#123; return tag.a[1][1]!=1||!tag.a[2][2]!=1||tag.a[1][2]!=0||tag.a[2][1]!=0;&#125;inline void pushup(int k)&#123; jz[k]=jz[ls(k)]+jz[rs(k)];&#125;void build(int k,int l,int r)&#123; tag[k].init(); if (l==r)&#123; jz[k]=f[l]; return; &#125; int mid=l+r&gt;&gt;1; build(ls(k),l,mid); build(rs(k),mid+1,r); pushup(k);&#125;inline void pushdown(int k)&#123; node sq=tag[k]; jz[ls(k)]=sq*jz[ls(k)]; tag[ls(k)]=tag[ls(k)]*sq; jz[rs(k)]=sq*jz[rs(k)]; tag[rs(k)]=tag[rs(k)]*sq; tag[k].init();&#125;void change(int k,int l,int r,int x,int y,node sq)&#123; if (x&lt;=l&amp;&amp;r&lt;=y)&#123; jz[k]=sq*jz[k]; tag[k]=tag[k]*sq; return; &#125; int mid=l+r&gt;&gt;1; if (check(tag[k]))pushdown(k); if (x&lt;=mid)change(ls(k),l,mid,x,y,sq); if (mid&lt;y) change(rs(k),mid+1,r,x,y,sq); pushup(k);&#125;node query(int k,int l,int r,int x,int y)&#123; if (x&lt;=l&amp;&amp;r&lt;=y) return jz[k]; int mid=l+r&gt;&gt;1; if (check(tag[k]))pushdown(k); if (x&lt;=mid&amp;&amp;mid&lt;y) return query(ls(k),l,mid,x,y)+query(rs(k),mid+1,r,x,y); else if (x&lt;=mid)return query(ls(k),l,mid,x,y); else return query(rs(k),mid+1,r,x,y);&#125;signed main()&#123; int n=read(),m=read(); p.init1(); node ttt; ttt.a[1][1]=ttt.a[2][1]=1; for (int i=1;i&lt;=n;++i)&#123; int x=read()-2; if (x==-1)f[i].a[1][1]=1,f[i].a[2][1]=0; else f[i]=(p^x)*ttt; &#125; build(1,1,n); while (m--)&#123; int opt=read(),x=read(),y=read(); if (opt==1)&#123; int d=read(); change(1,1,n,x,y,p^d); &#125;else&#123; node ans=query(1,1,n,x,y); write(ans.a[1][1]);puts(""); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4159 【[SCOI2009]迷路】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P4159%20%E3%80%90%5BSCOI2009%5D%E8%BF%B7%E8%B7%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[首先考虑边权只有$0,1$的情况。这时候只需要$Floyd$矩阵进行矩阵乘法即可，但是这道题的边权并不是$0,1$，那么我们能不能让$Floyd$矩阵中的每个单位存大于$1$的边权，然后矩乘呢？ 不能也就是说在$Floyd$矩阵中每个单位的值只能是$0$或$1$，但是我们发现$2 &lt;= N &lt;= 10$，这意味着我们可以乱搞将每个点都拆开，将这张图转化成边权只有$0,1$的图，这样上面的意义就成立了。 我们发现可以将每个点拆成$9$个点，令有序数对$(i,j)$表示点$i$拆成的第$j$个点，其中第$0$个点是“真”点，其余的是“假”点。 我们可以令 $(i,j)$表示到“真”点$(i,0)$的距离为j的“假”点，只要让$(i,j)$向$(i,j-1)$连一条边权为$1$的边。 而对于原图中的一条$u→v $边权为$w$的边，只要让$(u,0)$向$(v,w−1)$连一条边权为$1$的边。 这样我们就还原了原图中的边，并且将边权都转化成了$0,1$。 而每个$(i,j)$又可以唯一对应一个编号$(i-1)9+j$，因此原矩阵就变成了一个 $9n9n$的矩阵$ f$. 答案就是$f[0][n-9]$即点$1$的真点与点$n$的真点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define mod 2009#define inf 0x3f3f3f3fusing namespace std;char s[400][400];int f[400][400],now[400][400],t[400][400],ans[400][400];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for (int i=1;i&lt;=n;++i) scanf("%s",s[i]+1); for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) if (s[i][j]!='0')&#123; now[(i-1)*9][(j-1)*9+s[i][j]-'0'-1]=1; &#125; for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=8;++j)&#123; now[(i-1)*9+j][(i-1)*9+j-1]=1; &#125; int ttt=m;n*=9; for (int i=0;i&lt;=n;++i)ans[i][i]=1; while (ttt&gt;0)&#123; if (ttt&amp;1)&#123; memset(t,0,sizeof(t)); for (re int i=0;i&lt;=n;++i) for (re int j=0;j&lt;=n;++j) for (re int k=0;k&lt;=n;++k) t[i][j]=(t[i][j]+now[i][k]*ans[k][j])%mod; for (re int i=0;i&lt;=n;++i) for (re int j=0;j&lt;=n;++j) ans[i][j]=t[i][j]; &#125; ttt&gt;&gt;=1; memset(t,0,sizeof(t)); for (re int i=0;i&lt;=n;++i) for (re int j=0;j&lt;=n;++j) for (re int k=0;k&lt;=n;++k) t[i][j]=(t[i][j]+now[i][k]*now[k][j])%mod; for (re int i=0;i&lt;=n;++i) for (re int j=0;j&lt;=n;++j) now[i][j]=t[i][j]; &#125; printf("%d",ans[0][n-9]); return 0;&#125;]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2765 魔术球问题]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2765%20%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我们考虑建图，把每个点拆开，若两个数和为平方数，那么就从编号小的向编号大的连权值为$1$的有向边。那么就把这个问题转换成了最大匹配问题。 然后我们考虑对于一个新的球，如果能找到原来在的一个球能够匹配，那么可以直接匹配，否则就需要新开一根柱子。所以我们从小到大枚举放的球数，每次加入一个球，直到柱子个数超过给定的上限，那么上一次就是能放的最多球数。 对于方案，我们为了方便，在新增一根柱子的时候记录这个需要新柱子的球的编号，其余路径就按网络流跑二分图匹配的路径记录搞一搞即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3fusing namespace std;const int mx=3939;struct node&#123; int to,next,dis;&#125;e[393939];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int num,ans[10000],ttt,res,n,m,s,t,cnt=1,nex[10000],vis[10000],head[10000],cur[10000],dep[10000];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].next=head[v]; head[v]=cnt;&#125;inline bool bfs()&#123; memset(dep,0,sizeof(dep)); queue&lt;int&gt;q;q.push(s); dep[s]=1; while(!q.empty())&#123; int u=q.front();q.pop(); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;!dep[v])&#123; dep[v]=dep[u]+1;// if (v==t)return 1; q.push(v); &#125; &#125; &#125; return dep[t]&gt;0;&#125;int dfs(int u,int mn)&#123; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]==dep[u]+1) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi;if (v!=t)nex[(u-1)%mx+1]=(v-1)%mx+1; if (mn==used)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (bfs())&#123; for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; return res;&#125;int main()&#123; n=read(),s=0,t=mx&lt;&lt;1|1; while (ttt&lt;=n)&#123;++num; add(s,num,1);add(num+mx,t,1); for (int i=sqrt(num)+1;i*i-num&lt;num;++i) add(i*i-num,num+mx,1); int k=Dinic(); if (!k)ans[++ttt]=num; &#125; printf("%d\n",num-1); for (int i=1;i&lt;num;++i) if (!vis[i])&#123; int now=i; while (now)&#123; vis[now]=1; printf("%d ",now); now=nex[now]; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF117C Cycle]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF117C%20Cycle%2F</url>
    <content type="text"><![CDATA[题目大意：给定一个竞赛图(有向完全图，从数据保证$map[i][i]=0$，$map[i][j]≠map[j][i]$。可以看出)，找出一个长度为$3$的环。 竞赛图的重要性质： 竞赛图没有自环，没有二元环；若竞赛图存在环，则一定存在三元环。 前半句话浅显易懂，后半句话的意思就是说：竞赛图要么没有环，如果存在一个环大于三元，那么一定存在另一个三元的小环。 简单证明：假设一个竞赛图存在一个$N$元环(大于三元),环上有连续三点$A,B,C$(存在有向边$AB,BC)$ 根据竞赛图的定义，一定存在有向边$CA$或$AC$中的一者。 情况$1:$若存在$CA,$则$A,B,C$构成三元环； 情况$2:$若存在$AC$，不考虑$B$点，剩下的点构成一个$(N-1)$元环。显然，如果一直不存在情况$1$的话，最终也会形成一个三元环。 下面用类似$dfs$的$tanjan$寻找 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std; char s[5005];int n,low[39393],col,flag,in[39393],dfn[39393],st[39393],w[39393],t[39393],tot,vis[39393],top,num;bool a[5005][5005];void Tarjan(int u)&#123; if (flag)return; if (in[u]&amp;&amp;st[top]!=u)&#123; flag=1; while (st[top]!=u)t[++tot]=st[top--]; t[++tot]=u; return; &#125; if (vis[u])return; st[++top]=u;in[u]=vis[u]=1; for (int v=1;v&lt;=n;++v) if (a[u][v]) Tarjan(v); --top; in[u]=0;&#125;int main()&#123; scanf("%d",&amp;n); for (int i=1;i&lt;=n;++i)&#123; scanf("%s",s+1); for (int j=1;j&lt;=n;++j) if (s[j]=='1')a[i][j]=1; &#125; for (int i=1;i&lt;=n;++i) if (!vis[i])Tarjan(i); if (!flag)&#123;puts("-1");return 0;&#125; for (int j=3;j&lt;=tot;++j) if (a[t[1]][t[j]])&#123; printf("%d %d %d\n",t[1],t[j],t[j-1]); return 0; &#125;//如果枚举到j，说明之前有一条j-1到1的有向边，因为如果有1到j-1的有向边，之前程序就该结束了，不可能循环到j printf("%d %d %d\n",t[1],t[tot],t[tot-1]);//单独特判 return 0;&#125;]]></content>
      <tags>
        <tag>竞赛图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SP4318 【MFISH - Catch Fish】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20SP4318%20%E3%80%90MFISH%20-%20Catch%20Fish%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意:一条河分为$n$个段，每个段都有一个给定的鱼的数量$A_i$，现有$m$条船，每条船都有两个值$B_i$与$D_i$,$B_i$表示船必须在$B_i$处落锚，这意味着船必须占据$B_i$这个位置。且船的长度为$D_i$.数据保证$m$条船一定都可以放在河上。(也就是说我们选择时一定每条船都选，因为每条船都放显然是最优的)。求最大捕鱼数。 这道题给人一种贪心的错觉，实际上它是一个$DP$，首先对于每条船求出它左端点能放的最左边和最右边，这个结合代码应该很好理解 接下来就是$DP$了，$f_{j}$表示之前放的所有点的最右端为$j$的最大收益。显然我们可以发现每个$j$唯一对应着一条船，所以我们可以枚举每条船。 $f_{j+d_{i}-1}=max(f_{j+d_{i}-2},f_{j-1}+(sum_{a_{j+d_{i}-1}}-sum_{a_{j}}));$ 在代码实现上还有一些细节需要处理，具体详见代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define ll long long #define inf 0x3f3f3f3fusing namespace std;struct node&#123; int x,y,l,r;&#125;b[393939];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;void write(const int &amp;x)&#123; char ggg[10001];int s=0;int tmp=x; if(tmp==0)&#123;putchar('0');return;&#125;if(tmp&lt;0)&#123;tmp=-tmp;putchar('-');&#125; while(tmp&gt;0)&#123;ggg[s++]=tmp%10+'0';tmp/=10;&#125;while(s&gt;0)&#123;putchar(ggg[--s]);&#125;&#125;inline bool cmp(node a,node b)&#123; return a.x&lt;b.x;&#125;int a[393939],f[393939];signed main()&#123; int n=read(); for (int i=1;i&lt;=n;++i) a[i]=a[i-1]+read(); int m=read(); for (int i=1;i&lt;=m;++i) b[i].x=read(),b[i].y=read(); sort(b+1,b+1+m,cmp); b[0].l=1;b[m+1].x=inf; for (int i=1;i&lt;=m;++i)b[i].l=max(b[i].x-b[i].y+1,b[i-1].l+b[i-1].y); for (int i=1;i&lt;=m;++i)b[i].r=min(b[i+1].x-b[i].y,b[i].x); b[m+1].r=n+1; for (int i=1;i&lt;=n;++i)&#123; for (int j=b[i].l;j&lt;=b[i].r;++j) f[j+b[i].y-1]=max(f[j+b[i].y-1],f[j-1]+a[j+b[i].y-1]-a[j-1]); for (int j=b[i].l+b[i].y-1;j&lt;b[i+1].r;++j)f[j]=max(f[j],f[j-1]); &#125; printf("%d",f[n]);&#125;]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF570E 【Pig and Palindromes】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF570E%20%E3%80%90Pig%20and%20Palindromes%E3%80%91%2F</url>
    <content type="text"><![CDATA[感觉有点像传纸条，传纸条是是维护两个点同时从起点出发，保证步数相同，转移到终点，这道题是一个点从起点，另一个点从终点出发，保证步数相同$f[step][i][j][k][p]$表示走了$step$步，一个点走到$(i,j),$另一个点走到$(k,p)$，但是这样的状态在时空复杂度上都过不去，所以我们要优化，于是我们发现$j$和$p$都可以通过$step$算出来，并且我们可以滚动数组存储$step$这一位，并且在细节处理上这道题还是挺麻烦的12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define base 131#define mod 1000000007#define ll long longusing namespace std;int dx[]=&#123;-1,-1,0,0&#125;,dy[]&#123;1,0,1,0&#125;,f[2][1000][1000];char s[1000][1000];int main()&#123; int n=read(),m=read(); for (int i=1;i&lt;=n;++i) scanf("%s",s[i]+1); if (s[1][1]!=s[n][m])&#123; puts("0"); return 0; &#125; f[1][1][n]=1; int now=1; for (int st=2;st&lt;=(n+m)&gt;&gt;1;++st)&#123; now^=1; memset(f[now],0,sizeof(f[now])); for (int i=1;i&lt;=min(st,n);++i) for (int k=n;k&gt;=max(n-st,i);--k)&#123; int j=st-i+1,p=m-(st-(n-k))+1; if (s[i][j]==s[k][p]) for (int t=0;t&lt;4;++t) f[now][i][k]=(f[now][i][k]+f[now^1][i+dx[t]][k+dy[t]])%mod;//左边的点可以由左与上转移过来，右边的点可以由右与下转移过来 &#125; &#125; ll ans=0; if ((n+m)&amp;1) for (int i=1;i&lt;=n;++i) ans=(ans+f[now][i][i]+f[now][i][i+1])%mod; else for (int i=1;i&lt;=n;++i) ans=(ans+f[now][i][i])%mod;//n与m的奇偶性需要特判 printf("%d",ans);&#125;]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4088 【[USACO18FEB]Slingshot】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P4088%20%E3%80%90%5BUSACO18FEB%5DSlingshot%E3%80%91%2F</url>
    <content type="text"><![CDATA[由于坐标很大，先离散化，然后离线处理询问，然后通过调整枚举顺序与在树状数组的插入位置等处理不同情况，手推一下应该不难理解，情况如下图所示 设$x,y$为弹弓左端点与右端点,$s,t$为查询左端点与右端点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;struct node&#123; int x,y,v,id;&#125;a[200200];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int c[200200],cnt,nm,px[200200],py[200200],ans[100100];inline bool cmp(node a,node b)&#123;return (a.x!=b.x)?a.x&lt;b.x:a.y&lt;b.y;&#125;inline void change(int x,int d)&#123; for (;x&lt;=cnt;x+=x&amp;-x) c[x]=min(c[x],d);&#125;inline int query(int x)&#123; int res=0x3f3f3f3f3f3f3f3f; for (;x;x-=x&amp;-x) res=min(res,c[x]); return res;&#125;signed main()&#123; int n=read(),m=read(); for (int i=1;i&lt;=n;++i)&#123; int x=read(),y=read(),t=read(); a[++cnt]=node&#123;x,y,t,0&#125;; px[cnt]=x;py[cnt]=y; &#125; for (int i=1;i&lt;=m;++i)&#123; int x=read(),y=read(); a[++cnt]=node&#123;x,y,0,i&#125;; px[cnt]=x;py[cnt]=y; ans[i]=abs(y-x); &#125; sort(px+1,px+1+cnt); sort(py+1,py+1+cnt); sort(a+1,a+1+cnt,cmp); nm=unique(px+1,px+1+cnt)-px-1; for (int i=1;i&lt;=cnt;++i)a[i].x=lower_bound(px+1,px+1+nm,a[i].x)-px; nm=unique(py+1,py+1+cnt)-py-1; for (int i=1;i&lt;=cnt;++i)a[i].y=lower_bound(py+1,py+1+nm,a[i].y)-py;//离散化 memset(c,0x3f,sizeof(c)); for (int i=1;i&lt;=cnt;++i) if (!a[i].id) change(a[i].y,-px[a[i].x]-py[a[i].y]+a[i].v); else ans[a[i].id]=min(ans[a[i].id],query(a[i].y)+px[a[i].x]+py[a[i].y]); memset(c,0x3f,sizeof(c)); for (int i=1;i&lt;=cnt;++i) if (!a[i].id) change(cnt-a[i].y+1,-px[a[i].x]+py[a[i].y]+a[i].v); else ans[a[i].id]=min(ans[a[i].id],query(cnt-a[i].y+1)+px[a[i].x]-py[a[i].y]); memset(c,0x3f,sizeof(c)); for (int i=cnt;i;--i) if (!a[i].id) change(a[i].y,px[a[i].x]-py[a[i].y]+a[i].v); else ans[a[i].id]=min(ans[a[i].id],query(a[i].y)-px[a[i].x]+py[a[i].y]); memset(c,0x3f,sizeof(c)); for (int i=cnt;i;--i) if (!a[i].id) change(cnt-a[i].y+1,px[a[i].x]+py[a[i].y]+a[i].v); else ans[a[i].id]=min(ans[a[i].id],query(cnt-a[i].y+1)-px[a[i].x]-py[a[i].y]);//四种情况 for (int i=1;i&lt;=m;++i) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离线</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2602 [ZJOI2010]数字计数]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2602%20%5BZJOI2010%5D%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题意：给定两个正整数$a$和$b$，求在$[a,b]$中的所有整数中，每个数字各出现了多少次。 定义状态$f[i][j][k]$表示以$j$开头的$i$位数$k$出现的次数 状态转移方程 $f[i][j][k]=\sum\limits_{p=0}^{9}f[i-1][p][k]+(10^{i-1}* [j==k])$ (解释：$i$位数除去最高位就是$i-1$位数，所以要加上所以$i-1$位数的出现次数$(\sum\limits_{p=0}^{9}f[i-1][p][k])$，再加上最高位出现的次数$(10^{i-1}* [j==k])$ 求$A$到$B$之间出现的次数即使就$(1$~$B)-(1$~$(A-1))$的次数 $dp$完了后要开始统计了，首先特判$0$的情况，然后计算出这个数的位数$pos$，所以位数比这个数小的都可以统计答案。由于不能有前导$0$，所以最高位要从$1$枚举到$9$，再枚举所有$i$位数，从最高位枚举到最低位，只要小于当前位的都可以统计(注意等于不可以统计)，再统计一下当前位的贡献，最后还要减去前导$0$的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define int long long#define sqr(x) ((x)*(x))using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int f[30][40][40],ans[300],poow[200];void make(int x,int d)&#123; if (!x)&#123; ans[0]+=d;return;//0单独特判 &#125; int o=x,poos=0; while(o)&#123;++poos;o/=10;&#125;//算出这个数的位数 for (int i=1;i&lt;poos;++i)//位数比这个数小的都可以统计答案 for (int j=1;j&lt;=9;++j)//从1开始循环是因为开头不能为0 for (int k=0;k&lt;=9;++k) ans[k]+=f[i][j][k]*d; for (int i=poos;i&gt;=1;--i)&#123; int now=x/poow[i-1];x%=poow[i-1]; for (int j=0;j&lt;now;++j)&#123;//比当前位小的都要统计答案 for (int k=0;k&lt;=9;++k) ans[k]+=f[i][j][k]*d; &#125; ans[now]+=(x+1)*d;//当前位也要统计答案(x+1)是因为有后面都是0的情况) &#125; for (int i=0;i&lt;=9;++i)ans[i]-=f[poos][0][i]*d;//减去前导0 ans[0]+=d;//0要特殊处理，因为减去前导0时把0一起统计了&#125; signed main()&#123; int a=read(),b=read(); int cnt=13; poow[0]=1;for (int i=1;i&lt;=cnt;++i)poow[i]=poow[i-1]*10;//预处理10的幂次 for (int j=0;j&lt;=9;++j)f[1][j][j]=1; for (int i=2;i&lt;=cnt;++i) for (int j=0;j&lt;=9;++j)&#123; for (int k=0;k&lt;=9;++k) for (int p=0;p&lt;=9;++p) f[i][j][k]+=f[i-1][p][k]; f[i][j][j]+=poow[i-1]; &#125; make(b,1); make(a-1,-1);//类似前缀和 for (int i=0;i&lt;=9;++i) printf("%lld ",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数位$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1345 [USACO5.4]奶牛的电信Telecowmunication]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1345%20%5BUSACO5.4%5D%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication%2F</url>
    <content type="text"><![CDATA[题意：求网络流图中最小割点 一开始题意看成最小割边，把板子改了一下直接交，80(这样都能有80) 我们可以考虑“拆点”，即把一个点拆成两个点，中间连一条边权为1的边。 前一个点作为“入点”，别的点连边连入这里。 后一个点作为“出点”，出去的边从这里出去。 这样，只要我们切断中间那条边，就可以等效于除去这个点 红色的边边权为$1$，黑色的边边权为$inf$。 原点和汇点的内部边权为$inf$，因为显然这两个点不能删除。 题面给的边删除没意义（因为我们要删点），所以也设为$inf$ 网络流建反向边只是为了有”反悔”的机会，确保答案最优，所以在已有反向边时就没有必要建边圈为$0$的反向边了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;struct node&#123; int to,dis,next;&#125;e[400000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int vis,res,cnt=1,head[400000],inque[400000],dep[400000],n,m,s,t;inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; head[u]=cnt;&#125;inline int bfs()&#123; memset(dep,0x3f,sizeof(dep)); memset(inque,0,sizeof(inque)); queue&lt;int&gt;q;q.push(s); dep[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]&gt;dep[u]+1)&#123; dep[v]=dep[u]+1; if (v==t)return 1; if (!inque[v])&#123; q.push(v);inque[v]=1; &#125; &#125; &#125; &#125; return dep[t]&lt;0x3f3f3f3f;&#125;int dfs(int u,int mn)&#123; if (u==t) return mn; int mi=0,used=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]==dep[u]+1)&#123; if (mi=dfs(v,min(mn-used,e[i].dis)))&#123; used+=mi; e[i].dis-=mi; e[i^1].dis+=mi; if (used==mn)break; &#125; &#125; &#125; return used;&#125;inline int Dinic()&#123; int x; while (bfs()) while (x=dfs(s,0x3f3f3f3f))res+=x; return res;&#125;int main()&#123; n=read(),m=read(),s=read()+n,t=read(); for (int i=1;i&lt;=n;++i)add(i,i+n,1),add(i+n,i,0); for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); add(u+n,v,0x3f3f3f3f); add(v+n,u,0x3f3f3f3f); &#125; printf("%d",Dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF773DPerishable Roads]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF773DPerishable%20Roads%2F</url>
    <content type="text"><![CDATA[题意：一个$n$个点的完全图，定义$d_x$为生成树上点$x$到根路径上的最小边权。问图$G$的生成树$\sum d_x$最小是多少？ 人性化题意:给出$n$个点的完全图，对于完全图中的每个点$i,i$作为终点时，要使其他每个点到点$i$的“距离”和最小，对于每个点都输出这个最小值。 这里的“距离”是指对于其他每个点，那个点到点$i$路径上的最小值。且对于每个点$i$，计算答案时应保证图内每条边的方向一定。 首先可以发现这个路标建出来是一颗树，对于每一个点的贡献是这个点到终点的路径上的最小值。然后有一个十分机智的想法就是对于所有终点，把所有点都连在最短的边的一端，然后另一端连向终点。 然后这个东西显然是假的 不过我们可以考虑对它进行一些微小的修改让它成为正确的。 考虑这个想法的错误之处在于最短边的一端到终点的距离可能很长，所以我们考虑对这个进行计算，最短边的一边到终点路径显然是一条链。 显然这条链的边权只有单调递增时才有意义，因为任意一个破坏单调性的点都可以跟最短边不连接的一端连接，这样显然会更优。 这个过程有点难理解，也比较难实现，所以我们把这个过程想象成一个连边的过程，一开始最短路的一端直接跟终点连接。如下图 如果要去更新图$1$中的$a$，那么我们必须找到另一个点来松弛它，如图$2$，我们假设$c&lt;b$(因为如果$c&gt;b$,后面最短路操作会更新)，那么这些点的总贡献就变成了$2\times c$(显然)，因为是一条链，所以我们可以就此跑一遍最短路找出终点到最短边的最小总长度。 由于过程中维护最短边两端的点各自的个数，我们先将每条边减去最短边的权值，最后在加上最短边权值$\times (n-1)$ 怎么计算答案呢？我们设那条链上除终点外有$x$个点，那么那棵树上就有$n-1-x$个点，设最小边长度为$minn$，那么答案为$dis[t]+minn*(n-1-x)$。这个$x$很难计算，考虑消去。即计算$dis[t]$前先对所有边权减去一个$minn$，设新链答案为$dis[t]$，那么答案会变成$(dis[t]+minn\times x)+minn\times(n-1-x)$，即$dis[t]+minn\times(n-1)$,于是$x$就消去了。所以我们计算$dis[t]$即可。 因为要求最优解，我们跑最短路求$dis$(定义见上) 。即向终点直接连边，所以赋为终点与最小点的边权。还有一种状态，即是图$2$的情况，考虑那条链上有$3$个点。设加入的为点$j$，那么链的答案可能为最小点到终点的答案加上$j$到终点的答案，即$a[i][j]\times 2$($a$数组为邻接矩阵,$i$是终点) 最后$dijkstra$松弛即可 (模板) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int s,n,a[3005][3005],mn=21000000000000,dis[400000],vis[400000];void dijkstra(int s)&#123; memset(dis,0x3f,sizeof(dis)); for (int i=1;i&lt;=n;++i)&#123; dis[i]=a[s][i]; for (int j=1;j&lt;=n;++j) if (i!=j) dis[i]=min(dis[i],a[i][j]*2); &#125;//边权如此赋值的原因就是上述的图2情况 vis[s]=1; for (int i=1;i&lt;n;++i)&#123; int mn=210000000000000,k=0; for (int j=1;j&lt;=n;++j) if (!vis[j]&amp;&amp;mn&gt;dis[j]) mn=dis[j],k=j; vis[k]=1; for (int j=1;j&lt;=n;++j) if (!vis[j]&amp;&amp;dis[j]&gt;dis[k]+a[k][j]) dis[j]=dis[k]+a[k][j]; &#125;&#125;//不堆优化的dijkstrasigned main()&#123; n=read(); for (int i=1;i&lt;n;++i) for (int j=i+1;j&lt;=n;++j)&#123; a[i][j]=a[j][i]=read(); if (mn&gt;a[i][j])&#123; mn=a[i][j];s=i;//s即最短边靠终点的那个端点 &#125; &#125; for (int i=1;i&lt;n;++i) for (int j=i+1;j&lt;=n;++j) a[i][j]=a[j][i]=a[i][j]-mn; dijkstra(s); for (int i=1;i&lt;=n;++i)printf("%lld ",dis[i]+mn*(n-1));&#125;]]></content>
      <tags>
        <tag>思维题</tag>
        <tag>神仙题</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF538F 【A Heap of Heaps】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF538F%20%E3%80%90A%20Heap%20of%20Heaps%E3%80%91%2F</url>
    <content type="text"><![CDATA[神仙题题意：给一个数组建完全$k$叉树，$k$范围$[1,n-1]$，问每个$k$对应的不满足最小堆性质的结点个数 暴力$n^2$肯定要$T$飞，这里先引入几个性质： $1.\frac{n}{1}+\frac{n}{2}+\frac{n}{3}+…+\frac{n}{n-1}+\frac{n}{n}=nlogn$(调和级数) 2.在$i$叉树中，一个节点$j$的儿子的范围一定是一段区间$(j×i-i+2)$~$(j×i+1)$ 接下来是正解，我们发现对于一个节点$x$，它儿子中所有不合法的节点数即是它儿子中权值小于$x$的权值的数量，这显然可以联想到树状数组求逆序对的思想。 先排一遍序，记录下第i小的数在原先序列中的位置。然后从小的数开始处理，小的数后面肯定是大的数，不可能会出现非法节点，然后处理完小的数之后维护树状数组，对小的数对应的权值单点修改$+1$，这样在后面处理大的数的时候询问就会算上这些更新后的权值了。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x) using namespace std;struct node&#123; int a,b;&#125;a[400000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,c[400000],ans[400000];inline bool cmp(node a,node b)&#123; if (a.a!=b.a)return a.a&lt;b.a; else return a.b&lt;b.b;&#125;inline void change(int x)&#123; for (;x&lt;=n;x+=lowbit(x)) ++c[x];&#125;inline int sum(int x)&#123; int res=0; for (;x;x-=lowbit(x)) res+=c[x]; return res;&#125;int main()&#123; n=read(); for (int i=1;i&lt;=n;++i) a[i].a=read(),a[i].b=i; sort(a+1,a+1+n,cmp); for (int i=1;i&lt;=n;++i)&#123; change(a[i].b); for (int j=1;j&lt;n&amp;&amp;a[i].b*j-j+2&lt;=n;++j) ans[j]+=sum(min(n,a[i].b*j+1))-sum(a[i].b*j-j+1); &#125; for (int i=1;i&lt;n;++i)printf("%d ",ans[i]);&#125;]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2986 [USACO10MAR]伟大的奶牛聚集]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2986%20%5BUSACO10MAR%5D%E4%BC%9F%E5%A4%A7%E7%9A%84%E5%A5%B6%E7%89%9B%E8%81%9A%E9%9B%86%2F</url>
    <content type="text"><![CDATA[观察如果已经知道$1$号节点所需的时间 那么，我们可以做如下假设： ① 所有的牛首先到达了$1$号节点 ② $3$号节点以及他子树上的节点都需要退回$1-&gt;3$的路径的长度 ③ 除了$3$号节点以及他子树上的节点都需要前进$1-&gt;3$的路径的长度 通过上面的三条东西，我们就可以从任意一个父节点推出子节点的时间 所以，又是一遍$O(n)$的计算就可以推出最终的答案 $d[v] = d[u] - size[v]\times e[i].w + (n - size[v])*e[i].w;$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define int long long#define sqr(x) ((x)*(x))using namespace std;struct node&#123; int dis,to,next;&#125;e[400000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,m,cnt,ans=2100000000000000,size[300000],dep[400000],f[400000],head[400000],c[400000];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; head[u]=cnt;&#125;void dfs1(int u,int fa)&#123; size[u]=c[u]; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dep[v]=dep[u]+e[i].dis; dfs1(v,u); size[u]+=size[v]; &#125;&#125;void dfs(int u,int fa)&#123; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; f[v]=f[u]+(m-2*size[v])*e[i].dis; ans=min(ans,f[v]); dfs(v,u); &#125;&#125;signed main()&#123; n=read(); for (int i=1;i&lt;=n;++i)c[i]=read(),m+=c[i]; for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(),d=read(); add(u,v,d);add(v,u,d); &#125; dfs1(1,0); for (int i=1;i&lt;=n;++i)f[1]+=dep[i]*c[i]; dfs(1,0); printf("%lld\n",min(ans,f[1])); return 0;&#125;]]></content>
      <tags>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1948 [USACO08JAN]电话线Telephone Lines]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1948%20%5BUSACO08JAN%5D%E7%94%B5%E8%AF%9D%E7%BA%BFTelephone%20Lines%2F</url>
    <content type="text"><![CDATA[二分答案+$spfa$ 题意：求原点$1$到$n$的所有路中的第$k+1$长的路最小。 因为题意中的答案要最小，我们贪心肯定要使$k$次免费的资格用完，那么最划算的方案肯定是拿最长的$k$条路使之免费，然后付第$k+1$长路的长度的钱。。。这样的贪心思路显然是正确的。 我们首先二分第$k+1$长的路的长度(即答案)，然后关键是如何判断正确性。我们考虑简化问题，对于长度小于二分出的答案的线段，因为不需要付价钱，所以可以将其权值看作是$0$;同理，大于二分的值的路径，我们将长度看作$1$(意味着我需要使用$1$次免费的资格)。我们跑一遍$spfa$，看到了$n$点的最短路的长度，如果大于$k$，则不行，缩小$r$范围继续二分;如果小于，则有可能更小，缩小$l$范围继续二分。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;struct node&#123; int dis,to,next; bool operator &lt;(const node &amp;x)const&#123; return x.dis&lt;dis; &#125;&#125;e[400000];int n,m,k,o,head[400000],cnt,dis[400000],vis[400000],u[400000],w[400000],v[400000];inline void add(int u,int v,int d)&#123; e[++cnt].dis=d; e[cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;priority_queue&lt;node&gt;q;bool dijkstra()&#123; memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); dis[1]=0; q.push(node&#123;0,1&#125;); while (!q.empty())&#123; int x=q.top().to;q.pop(); if (vis[x])continue; vis[x]=1; for (int i=head[x];i;i=e[i].next)&#123; int y=e[i].to; if (dis[y]&gt;dis[x]+e[i].dis)&#123; dis[y]=dis[x]+e[i].dis; q.push(node&#123;dis[y],y&#125;); &#125; &#125; &#125; if (dis[n]&gt;k) return 0; else&#123;o=1;return 1;&#125;&#125;int main()&#123; n=read(),m=read(),k=read(); for (int i=1;i&lt;=m;++i) u[i]=read(),v[i]=read(),w[i]=read(); int l=0,r=1000000; while (l&lt;r)&#123; int mid=l+r&gt;&gt;1; memset(head,0,sizeof(head));cnt=0; for (int i=1;i&lt;=m;++i)add(u[i],v[i],mid&lt;w[i]),add(v[i],u[i],mid&lt;w[i]); if (dijkstra())r=mid; else l=mid+1; &#125; if (o)printf("%d\n",l); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2451 [SDOI2005]遗传代码]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2451%20%5BSDOI2005%5D%E9%81%97%E4%BC%A0%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[想法题，如果一个$l$等于一个$r$，那么他们可以抵消成一个，但是洛谷数据好像有锅，当前位置上的$r&gt;l$时，$ans$加上$r-l$，或者当前位置上的$l&lt;r$时，$ans$加上$l-r$，都是对的。(但洛谷上只有$r-l$是对的) 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int ans,l[300000],r[300000];int main()&#123; int n=read(); for (int i=1;i&lt;=n;++i)&#123; ++l[read()]; ++r[read()]; &#125; for (int i=1;i&lt;=1000;++i) if (r[i]&gt;l[i]) ans+=abs(r[i]-l[i]); cout&lt;&lt;ans+n; return 0;&#125;]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5022 旅行]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P5022%20%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[题意：前$60$分图是一棵树，直接暴力$dfs$枚举边，暴力判断,$O(n)$。后$40$分是一颗基环树，暴力删边,再按照前$60$分的方法暴力$dfs$，$O(n^2)$。 但是这样会$T$飞，所以我们要优化 优化$1:$我们发现我们每条边都删一遍完全没必要，只需对那个环上的所有边进行删除操作，用并查集判环即可 优化$2:$我们发现要求字典序最小，所以我们$dfs$时可以进行最优性剪枝，如果前面的编号与当前答案都相同(注意，这个前提很重要)，当前这条边的编号大于答案那么就可以$return$了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int qqq,ttt,n,m,vis[300000],ans[300000],tot,mp[300000][2],tx,ty,p[300000];vector&lt;int&gt;q[30000];void dfs(int u)&#123; vis[u]=1;ans[++tot]=u; for (int i=0;i&lt;q[u].size();++i)&#123; int v=q[u][i]; if (vis[v])continue; dfs(v); &#125; vis[u]=0;&#125;void dfss(int u)&#123; if (ttt)return; vis[u]=1;p[++tot]=u; if (p[tot]&gt;ans[tot]&amp;&amp;!qqq)&#123;ttt=1;return;&#125; if (p[tot]&lt;ans[tot])qqq=1; for (int i=0;i&lt;q[u].size();++i)&#123; int v=q[u][i];if (ttt)return; if (vis[v]||((u==tx&amp;&amp;v==ty)||(u==ty&amp;&amp;v==tx)))continue; dfss(v); &#125;&#125;void cmp_and_change()&#123; if (tot!=n)return; for (int i=1;i&lt;=n;++i)&#123; if (ans[i]&lt;p[i])return; if (ans[i]&gt;p[i])break; &#125; for (int i=1;i&lt;=n;++i)ans[i]=p[i];&#125;int main()&#123; n=read(),m=read(); for (int i=1;i&lt;=m;++i)&#123; int x=read(),y=read(); q[x].push_back(y); q[y].push_back(x); mp[i][0]=x;mp[i][1]=y; &#125; for (int i=1;i&lt;=n;++i)sort(q[i].begin(),q[i].end()); if (m==n-1)&#123; dfs(1); for (int i=1;i&lt;=tot;++i)printf("%d ",ans[i]); &#125;else&#123; memset(ans,0x3f,sizeof(ans)); for (int i=1;i&lt;=m;++i)&#123; memset(vis,0,sizeof(vis));ttt=0;qqq=0; tx=mp[i][0],ty=mp[i][1];tot=0; dfss(1); cmp_and_change(); &#125; for (int i=1;i&lt;=n;++i)write(ans[i]),putchar(' '); &#125;&#125;]]></content>
      <tags>
        <tag>剪枝优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3618 【误会】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P3618%20%E3%80%90%E8%AF%AF%E4%BC%9A%E3%80%91%2F</url>
    <content type="text"><![CDATA[$dp+hash$ 设子串长度为$m$，$f_{i}$表示到子串末尾在原句是第$i$个位置有几种方案，显然对于每个$f_{i}$有三种情况，当原句以$i$结尾的长度为$m$的字符串等于子串$f_{i}=f_{i-1}+f_{i-m}$,即选或不选，否则$f_{i}=f_{i-1}$,只能不选； 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const int p=313;int v=1,T,n,m,a[2000000];ull power[2000000],sum[2000000],f[200000],t;char s1[200000],s2[200000];int main()&#123; scanf("%d",&amp;T); power[0]=1; for (int i=1;i&lt;=100001;i++) power[i]=power[i-1]*p; while (v&lt;=T)&#123; scanf("%s\n%s",s1+1,s2+1); memset(f,0,sizeof(f)); n=strlen(s1+1);m=strlen(s2+1);t=0; for (int i=1;i&lt;=n;i++) sum[i]=sum[i-1]*p+s1[i]-96; for (int i=1;i&lt;=m;i++) t=t*p+s2[i]-96; f[0]=1; for (int i=1;i&lt;=n;i++) if (t==sum[i]-sum[i-m]*power[m]) f[i]=(f[i-1]+f[i-m])%1000000007; else f[i]=f[i-1]; printf("Case #%d: %d\n",v,f[n]); v++; &#125;&#125;]]></content>
      <tags>
        <tag>$hash$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2749 【[USACO5.1]夜空繁星Starry Night】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2749%20%E3%80%90%5BUSACO5.1%5D%E5%A4%9C%E7%A9%BA%E7%B9%81%E6%98%9FStarry%20Night%E3%80%91%2F</url>
    <content type="text"><![CDATA[难点在于判断图像是否相似，我们采用将每个点之间互相连起来，计算每个点与点之间的距离之和（也可用$hash$、直接写对称旋转函数或八个循环判断），共$\frac{n*(n-1)}{2}$条线段，这种做法的正确性不难证明，当和相同时，每条边长度相等（正确性下面再证），可以将图像看成一个多边形，连接点可以看成将多边形分成许多三角形，根据三角形全等判定条件（$sss$），可以判定每个三角形全等，根据三角形全等推出对应边相等、对应角相等，可证多边形全等当和相等，每条边也相等的证明：三角形将每个格点的边长设为$1$，故每条线段的长度都为整数或一个整数的开方，整数的小数部分为$0$，整数的开根小数部分取值十分有限，使用$long double$可以将出错率大大降低。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int k,tail,tx[200000],ty[200000],n,m,a[300000],b[300000],dx[]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;-1,0,1,-1,1,-1,0,1&#125;;char s[3000][3000],p='a',u[3999];long double t[39];void dfs(int x,int y,char q,char p)&#123;//深搜求联通块（广搜也可） for (int i=0;i&lt;8;i++)&#123;//根据题意是八个方向 int xx=x+dx[i],yy=y+dy[i]; if (xx&lt;1||xx&gt;n||yy&lt;0||yy&gt;=m||s[xx][yy]!=p) continue; tx[++tail]=xx;ty[tail]=yy; s[xx][yy]=q; dfs(xx,yy,q,p); &#125;&#125;void check(int x,int y)&#123; long double res=0; for (int i=1;i&lt;=tail;i++) for (int j=1;j&lt;=tail;j++) res+=sqrt((tx[i]-tx[j])*(tx[i]-tx[j])+(ty[i]-ty[j])*(ty[i]-ty[j]));//计算每个点与点之间的直线距离和 for (int i=1;i&lt;=k;i++) if (abs(res-t[i])&lt;0.00001)&#123;//浮点数的判定相等的方法 p--;char o=s[x][y]; s[x][y]=u[i]; dfs(x,y,u[i],o);//若与前面重复则重新赋值 return; &#125; t[++k]=res;u[k]=p;//不重复则加入数组（也可用map）&#125;int main() &#123;// freopen("star.in", "r", stdin), freopen("star.out", "w", stdout); cin&gt;&gt;m&gt;&gt;n; for (int i=1;i&lt;=n;i++) scanf("%s",s[i]); for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;m;j++) if (s[i][j]=='1')&#123; s[i][j]=p; tx[1]=i;ty[1]=j; tail=1; dfs(i,j,p,'1'); check(i,j); p++; &#125; for (int i=1;i&lt;=n;i++)&#123; for (int j=0;j&lt;m;j++) cout&lt;&lt;s[i][j]; cout&lt;&lt;endl; &#125;&#125;]]></content>
      <tags>
        <tag>奇技淫巧</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2052 [NOI2011]道路修建]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2052%20%5BNOI2011%5D%E9%81%93%E8%B7%AF%E4%BF%AE%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[题意：给定一棵有$n$个节点的树，树上每条边花费的价格是这条边两侧的点的数量的差的绝对值与这条边长度的积。求这棵树的总花费。 随便选一个点作为根节点(这里选用节点$1$)，我们可以对这棵树进行$dfs$计算出每个点的$size$，然后就知道这条边的贡献为$abs(n-2\times size_{v})\times w_{i}$，其中$v$为这条边的儿子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))struct node&#123; ll dis,to,next;&#125;e[3000000];using namespace std;inline void write(ll x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(ll x) &#123;write(x);puts("");&#125;inline ll read()&#123; ll s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;ll head[3000000],size[3000000],n,ans,cnt;inline void add(ll u,ll v,ll d)&#123; e[++cnt].dis=d; e[cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(ll u,ll fa)&#123; for (ll i=head[u];i;i=e[i].next)&#123; ll v=e[i].to; if (v==fa)continue; dfs(v,u); size[u]+=size[v]; &#125;&#125;void dfs1(ll u,ll fa)&#123; for (ll i=head[u];i;i=e[i].next)&#123; ll v=e[i].to; if (v==fa)continue; ans+=e[i].dis*abs(size[v]*2-n); dfs1(v,u); &#125;&#125;int main()&#123; n=read(); for (ll i=1;i&lt;=n-1;++i)&#123; size[i]=1; ll u=read(),v=read(),d=read(); add(u,v,d);add(v,u,d); &#125;size[n]=1; dfs(1,0); dfs1(1,0); cout&lt;&lt;ans;&#125;]]></content>
      <tags>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1268 树的重量]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1268%20%E6%A0%91%E7%9A%84%E9%87%8D%E9%87%8F%2F</url>
    <content type="text"><![CDATA[由于所有点均为叶子节点，很显然点$3$是从点$1$到点$2$的路径上分叉出来的 设蓝色部分长度为$len$，那么答案就是$g(1,2)+len$。$len$怎么求呢？显然，$len =\frac{g(1,3)+g(2,3)-g(1,2)}{2}$。 $n&gt;3$的情况也同理。枚举$i$，看看点$n$是不是从点$1$~$i$的路径上分叉出来的，求出的最小$len$就是要加到答案里面去的。 如果认为点$4$是从$1$~$2$的路径上分叉出来的，答案就会加上红色部分的长度。但是红色部分长度显然有一部分是多余的。只有认为点$4$是从$1$~$3$的路径上分叉出来的，才能加上正确答案（也就是蓝色部分）。所以对于当前点我们要枚举是从那一条路径中分叉出来的，取最小值。 证明：因为在最小的情况下，不会有任何冲突的地方，这样加点，可以保证时时刻刻没有冲突，而没有冲突的情况下答案是唯一的 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int a[3000][3000],ans;int main()&#123; while (1)&#123; int n=read(); if (!n)return 0; for (int i=1;i&lt;=n;++i) for (int j=i+1;j&lt;=n;++j) a[i][j]=a[j][i]=read(); ans=a[1][2]; for (int i=3;i&lt;=n;++i)&#123; int mn=2100000000; for (int j=2;j&lt;i;++j)&#123; mn=min(mn,(a[1][i]+a[i][j]-a[1][j])/2); &#125; ans+=mn; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1967 货车运输]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1967%20%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[题意：$n$个节点，$m$条边，$q$个询问，对于每个询问求图中两点间所有路径中最小边权的最大值 对于一条边，我们可以走另一条最小边权的最大值；比这条边的权值大的路径，所以对于原图，我们只需求最大生成树，然后求$LCA$即可，在倍增求$LCA$的同时算一个数组$w$表示最小边权的最大值； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))struct node1&#123; int dis,to,next;&#125;e[300000];struct node&#123; int u,v,d;&#125;ed[300000];using namespace std;inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int n,m,head[300000],fa[300000],dep[300000],f[300000][22],w[300000][22],cnt,vis[300000];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt;&#125;int find(int k)&#123;return fa[k]==k?k:fa[k]=find(fa[k]);&#125;inline bool cmp(node a,node b)&#123;return a.d&gt;b.d;&#125;void Kruskal()&#123; sort(ed+1,ed+1+m,cmp); for (int i=1;i&lt;=n;++i)fa[i]=i; int cnt=0; for (int i=1;i&lt;=m;++i)&#123; if (find(ed[i].u)==find(ed[i].v)) continue; fa[find(ed[i].u)]=find(ed[i].v); add(ed[i].u,ed[i].v,ed[i].d); add(ed[i].v,ed[i].u,ed[i].d); ++cnt; &#125;&#125;inline void deal_lca(int u,int fa)&#123; vis[u]=1; for (int i=1;i&lt;=20;++i) f[u][i]=f[f[u][i-1]][i-1],w[u][i]=min(w[u][i-1],w[f[u][i-1]][i-1]); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (vis[v])continue; dep[v]=dep[u]+1; f[v][0]=u;w[v][0]=e[i].dis; deal_lca(v,u); &#125;&#125;inline int lca(int x,int y)&#123; if (find(x)!=find(y))return -1; int res=2100000000; if (dep[x]&lt;dep[y])swap(x,y); for (int i=20;i&gt;=0;--i)&#123; if (dep[f[x][i]]&gt;=dep[y])res=min(res,w[x][i]),x=f[x][i]; &#125; if (x==y)return res; for (int i=20;i&gt;=0;--i)&#123; if (f[x][i]!=f[y][i]) res=min(res,min(w[x][i],w[y][i])),x=f[x][i],y=f[y][i]; &#125; return min(res,min(w[x][0],w[y][0]));&#125;int main()&#123; n=read(),m=read(); for (int i=1;i&lt;=m;++i) ed[i].u=read(),ed[i].v=read(),ed[i].d=read(); Kruskal(); for (int i=1;i&lt;=n;++i) if (!vis[i])&#123; dep[i]=1; deal_lca(i,0); f[i][0]=i; w[i][0]=2100000000; &#125; for (int i=1;i&lt;=20;++i) for (int j=1;j&lt;=n;++j)&#123; f[j][i]=f[f[j][i-1]][i-1]; w[j][i]=min(w[j][i-1],w[f[j][i-1]][i-1]); &#125; int q=read(); while(q--)&#123; int x=read(),y=read(); wln(lca(x,y)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>$LCA$</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF519E A and B and Lecture Rooms]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF519E%20A%20and%20B%20and%20Lecture%20Rooms%2F</url>
    <content type="text"><![CDATA[题意：有棵大小为$n$的树，再给出m次询问，每次询问中包含$A,B$两点，我们要找到离$A,B$两点距离相等的点一共有多少个。 需要对$A,B$之间的距离进行分类讨论： 需要对$A,B$之间的距离进行分类讨论： 一.如果询问的两个点之间的距离为奇数(或者之间的点为偶数)，那么无论怎样，它们之间必然有偶数个点，不可能有点到它们的距离相等。 二.如果询问的两个点之间的距离为偶数时，我们要找到$A,B$之间的中点，这个时候又需要分几个情况 { $1.A,B$两点到他们的$LCA$的距离不相等（包括$A,B$两点中其中一个点为另一个点的$LCA$的情况），那么我们需要找到$A,B$两点所在链上的中点，中点与它不包含所询问点的子树上的点都是满足条件的点 $2.A,B$两点到他们的$LCA$之间距离相等时，满足条件的点的个数即是整棵树的上节点的总数减去$LCA$包含所询问两点的子树的节点个数 } 三.$3.A,B$两点重合时，整颗树上的点到这两个点的距离都可以看做相等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))struct node&#123; int to,next;&#125;e[300000];using namespace std;inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int tot,size[300000],head[300000],cnt,fa[300000],dep[300000],son[300000],top[300000],w[300000],p[3000000];void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs1(int u)&#123; size[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (fa[u]==v)continue; fa[v]=u;dep[v]=dep[u]+1; dfs1(v); size[u]+=size[v]; if (!son[u]||size[v]&gt;size[son[u]]) son[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp;w[u]=++tot;p[tot]=u; if (son[u])dfs2(son[u],tp); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa[u]||v==son[u])continue; dfs2(v,v); &#125;&#125;inline int LCA(int x,int y)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&gt;dep[top[y]]) x=fa[top[x]]; else y=fa[top[y]]; &#125; return dep[x]&gt;dep[y]?y:x;&#125;//以上是树剖求LCA板子int find_mid(int x,int y,int lca,int len,int far)&#123; if (dep[x]-dep[lca]&lt;len)&#123; swap(x,y); len=far-len; &#125; while (x!=lca&amp;&amp;len&gt;0)&#123; int net=top[x]; if (w[x]-w[net]+1&lt;=len)len-=w[x]-w[net]+1; else return p[w[x]-len]; x=fa[net]; &#125; return x;&#125;//找mid这里应该用倍增，但是写了一种自己都看不懂的算法qwqint main()&#123; int n=read();int m=n-1; for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; dfs1(1); dfs2(1,1); int q=read(); while (q--)&#123; int x=read(),y=read(); int lca=LCA(x,y); int far=(dep[x]+dep[y]-dep[lca]*2); int mid=find_mid(x,y,lca,far/2,far); int midl=find_mid(x,y,lca,far/2-1,far); int midr=find_mid(y,x,lca,far/2-1,far); if (far&amp;1) printf("0\n"); else if (x==y)&#123; printf("%d\n",n); &#125;else if (dep[midl]==dep[midr])&#123; printf("%d\n",n-size[midl]-size[midr]); &#125;else&#123; printf("%d\n",size[mid]-(dep[midl]&gt;dep[midr]?size[midl]:size[midr])); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
        <tag>$LCA$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF700B Connecting Universities]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF700B%20Connecting%20Universities%2F</url>
    <content type="text"><![CDATA[题意：给出一棵树上的$2\times k$个节点，给他们配对，使得他们之间的距离和最大。 显然，如果对于每条边，它被经过的次数越多越好，那么它被经过的次数最多是多少呢，假设在它两侧分别有$x,y$个端点，那么它被经过的次数最多是$min(x,y)$; 所以$ans$就是$\sum min(x,y)$； 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline void write(ll x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(ll x) &#123;write(x);puts("");&#125;struct node&#123; ll to,next;&#125;e[500000];inline ll read()&#123; ll s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;ll n,k,head[500000],cnt,t[500000],b[500000],a[500000],ans;inline void add(ll u,ll v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(ll u,ll fa)&#123; if (b[u])t[u]=1; for (ll i=head[u];i;i=e[i].next)&#123; ll v=e[i].to; if (v==fa)continue; dfs(v,u); t[u]+=t[v]; &#125; ans+=min(t[u],2*k-t[u]);&#125;int main()&#123; n=read(),k=read(); for (ll i=1;i&lt;=2*k;++i) a[i]=read(),b[a[i]]=1;; for (ll i=1;i&lt;=n-1;++i)&#123; ll u=read(),v=read(); add(u,v);add(v,u); &#125; dfs(1,0); cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF746G New Roads]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF746G%20New%20Roads%2F</url>
    <content type="text"><![CDATA[题意：给你$3$个数字$n,t,k;$分别表示一棵树有$n$个点; 这棵树的深度$t$,以及叶子节点的个数$k;$给你树的每层节点个数; 让你画出这么一棵树; 输出它的$n-1$条边; 首先计算这样的树最多与最少能有几个叶子节点，如果$k$不在这个范围内，则输出$-1,return 0;$ 然后我们钦定同一深度的点都指向同一个父亲 这样叶子节点最多，并且计算一下我们需要消除的叶子节点数量$=n-t-k$。 然后从下到上进行调整,每次将当前层节点指向的父亲转移成上一层每个节点(如果当前层节点数大于上一层节点数，则多余的挤在一起)枚举用两个指针，一个指针指向当前层，另一个指针指向上一层，同时$+1$，如果一个指针指向了尽头就跳到上一层，如果消除的叶子节点数$=$我们需要消除的叶子节点数量则退出。 然后输出即可 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int a[300000],mx,mn,tot;int main()&#123; int n=read(),t=read(),k=read(); for (int i=1;i&lt;=t;++i)&#123; a[i]=read(); if (a[i]&gt;a[i-1])mn+=a[i]-a[i-1]; &#125; mx=n-t; if (k&lt;mn||k&gt;mx)&#123; cout&lt;&lt;-1;return 0; &#125; printf("%d\n",n); for (int i=2;i&lt;=a[1]+1;++i)printf("1 %d\n",i);//根节点与其子节点特殊处理 int T=mx-k;tot=a[1]+2;//T为我们需要消除的叶子节点数量，tot为初始指针指向第三层的第一个节点 for (int i=2;i&lt;=t;++i)&#123; int p=min(a[i],a[i-1]),q=0;//p表示当前层可以消除的叶子节点数，q是指针 while (p&amp;&amp;T)&#123; if (q)--T;//第一个点是下一层多余节点的连接处，所以T不能--; --p; printf("%d %d\n",tot+q-a[i-1],tot+q); ++q; &#125; while (q&lt;a[i])&#123; printf("%d %d\n",tot-a[i-1],tot+q); ++q; &#125;//处理多余节点 tot+=a[i];//指针指向下一行 &#125;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF765E Tree Folding]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF765E%20Tree%20Folding%2F</url>
    <content type="text"><![CDATA[题意：给你一棵树，可以把树上父亲相同的两条长度相同的链合并。（如图）问你最后能不能变成一条链，能的话求链的最短长度。 显然如果可以合并，那么合并后长度一定$\leqslant$直径的一半，所以，我们找到直径的中点作为根(若有两个中点则随便选一个) 对于每个点(除根以外)，如果它有两条或以上长度为不同的子节点形成的链，那么这棵树是无法合并的，输出$-1$，否则用一个$set$维护子节点形成的链长度情况，向上个节点传递$set$中链的长度$+1$ 特别的，对于根，因为它没有父亲节点，所以即使它有两条子节点形成的链，也是合法的(但是如果有三条及以上就不合法了)，如果有一条链，返回这条链的长度$+1$，如果有两条链，返回两条链长度之和$+2$； 最后，对于答案，如果$ans$是$2$的倍数，将它不停地除以$2$，直到$ans$是奇数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;struct node&#123; int to,next;&#125;e[700000];inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int cnt,head[500000],dep[400005][3],mx,loc,mid;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa,int t)&#123; dep[u][t]=dep[fa][t]+1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs(v,u,t); &#125; if (dep[u][t]&gt;mx)&#123; mx=dep[u][t]; loc=u; &#125;&#125;int dfs1(int u,int fa)&#123; set&lt;int&gt;lxy666; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v!=fa) lxy666.insert(dfs1(v,u)); &#125; if (u==fa)&#123;//根特殊处理 if (!lxy666.size())return 0; else if (lxy666.size()==1)return *lxy666.begin()+1; else if (lxy666.size()==2)return *lxy666.begin()+*--lxy666.end()+2; else&#123; puts("-1");exit(0); &#125; &#125;else&#123; if (!lxy666.size())return 0; else if (lxy666.size()==1)return *lxy666.begin()+1; else&#123; puts("-1");exit(0); &#125; &#125;&#125;int main()&#123; int n=read(); for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; mx=0; dfs(1,0,2); mx=0; dfs(loc,0,1); int len=mx-1;mx=0; dfs(loc,0,0); for (int i=1;i&lt;=n;++i) if (dep[i][1]+dep[i][0]-2==len)&#123; if (abs(dep[i][0]-dep[i][1])==0||abs(dep[i][0]-dep[i][1])==1)&#123; mid=i;break; &#125; &#125;//以上为找直径中点 int ans=dfs1(mid,mid);while(!(ans&amp;1))ans&gt;&gt;=1; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>思维题</tag>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1073F Choosing Two Paths]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF1073F%20Choosing%20Two%20Paths%2F</url>
    <content type="text"><![CDATA[题目大意：有一棵树，从中选取$2$条链，其中任何一条链的端点不能被另一条链包含，求这两条链，使这两条链的公共的点的部分最长，若相同，使得总长度最长。 因为其中任何一条链的端点不能被另一条链包含，所以重合线段的两个端点的度一定$\geqslant3($两条链的端点在这个节点处分开),在一棵树上要求公共部分最长，有点像求树的直径的做法，两遍$dfs$，特殊的是在更新答案时只有这个点度$\geqslant3$时才更新。 这道题还有个要求，在求公共部分最长的情况下还要使总长度最长 那我们就在$u$和$v$的子树中，找离根最远和次远的点即可。 为了保证求出的两个端点的子树中，“离根最远和次远的点到根距离之和”是最长的，所以在dfs的时候若两个点距离根同样远，则根据它们“离根最远和次远的点到根距离之和”的大小来判断即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;struct node1&#123; int to,dis,next;&#125;e[500000],e1[500000];inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int loc,ans,head[500000],head1[500000],dep[500000],ind[500000],f[500000],g[500000],cnt;struct node&#123; int x,sum; friend bool operator &lt;(node y,node z)&#123; if (z.x!=y.x)return y.x&lt;z.x; return y.sum&lt;z.sum; &#125;&#125;mx;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; dep[u]=dep[fa]+1;g[u]=f[u]=0;int cnt=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue;++cnt; dfs(v,u); if (dep[f[v]]&gt;dep[f[u]])&#123; g[u]=f[u]; f[u]=f[v]; &#125;else if (dep[f[v]]&gt;dep[g[u]])&#123; g[u]=f[v]; &#125; &#125; if (!cnt)f[u]=u; if (cnt&gt;1)&#123; node x=&#123;dep[u],dep[f[u]]+dep[g[u]]-dep[u]*2&#125;; if (mx&lt;x)&#123; mx=x; loc=u; &#125; &#125;&#125;int main()&#123; int n=read(); for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; mx=&#123;0,0&#125;; dfs(1,0); int a1=f[loc],b1=g[loc]; mx=&#123;0,0&#125;; dfs(loc,0); int a2=f[loc],b2=g[loc]; printf("%d %d\n%d %d\n",a1,a2,b1,b2); return 0;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1085D Minimum Diameter Tree]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF1085D%20Minimum%20Diameter%20Tree%2F</url>
    <content type="text"><![CDATA[树的直径的两个端点一定是叶子节点(当边权都为正时)，这个结论显然； 将每一条边分成两类，一类为叶子节点连接的边，设为$a$，另一类为没有叶子节点连接的边，设为$b$； 对于b，我们希望每条$b$对直径贡献尽量小，因为两条可能成为直径的边可能同时包含了$b$。所以将所有$b$的值设为$0$； 根据这个结论，我们将所有$s$均摊给每条$a$； 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int cnt,r[300000];int main()&#123; int n=read(),m=read(); for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); ++r[u];++r[v]; &#125; for (int i=1;i&lt;=n;++i) if (r[i]==1) ++cnt; printf("%.18lf",2*m*1.0/(cnt*1.0));&#125;]]></content>
      <tags>
        <tag>树相关</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1552 [APIO2012]派遣]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P1552%20%5BAPIO2012%5D%E6%B4%BE%E9%81%A3%2F</url>
    <content type="text"><![CDATA[题意：$n$个点组成一棵树，每个点都有一个领导力和费用，可以让一个点当领导，然后在这个点的子树中选择一些费用之和不超过$m$的点，得到领导的领导力乘选择的点的个数（领导可不被选择）的利润。求利润最大值。 $n\leqslant100000$； 每个点构造一个大根堆，堆里的就是这个点的人。 往父亲那里合并堆，记录堆的大小，费用的总和。 从儿子合并完毕后，在每个节点，不断踢出费用最大的人，直到费用的总和$\leqslant m$这就是这个点的最优方案了。（显然，花费最小的都留下了） 对于每个点，用这个点的领导力乘堆的大小尝试更新答案即可。 注意：和子树合并的时候,$rt[x]=merge(rt[x],rt[y])$注意是$rt[y]$因为这才是$y$的所属堆的入口。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline ll read()&#123; ll s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;ll ans,fa[300000],size[300000],p[300000],sum[300000],v[300000],n,m,dist[300000],f[300000],s[2][309009],c[300000],son[2][300000];ll merge(ll x,ll y)&#123; if (!x||!y)return x|y; if (v[x]&lt;v[y])swap(x,y); s[1][x]=merge(s[1][x],y); if (dist[s[0][x]]&lt;dist[s[1][x]])swap(s[0][x],s[1][x]); dist[x]=dist[s[1][x]]+1; return x;&#125;int main()&#123; n=read(),m=read(); for (ll i=1;i&lt;=n;++i)&#123; fa[i]=read();v[i]=read();p[i]=read(); size[i]=1;sum[i]=v[i];f[i]=i; ans=max(ans,p[i]); &#125; for (ll i=n;i&gt;1;--i)&#123; ll k=fa[i]; f[k]=merge(f[i],f[k]); sum[k]+=sum[i]; size[k]+=size[i]; while (sum[k]&gt;m)&#123; sum[k]-=v[f[k]]; f[k]=merge(s[0][f[k]],s[1][f[k]]); --size[k]; &#125; ans=max(ans,p[k]*size[k]); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF292D 【Connected Components】]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF292D%20%E3%80%90Connected%20Components%E3%80%91%2F</url>
    <content type="text"><![CDATA[题意一个无向图，给出$m$条边，有$k$次询问，每次询问将第$l_{i}$到$r_{i}$条边暂时删去，求这时候有多少个连通分量.$N\leqslant500,1\leqslant M,K\leqslant10000$ 每次暴力建边(即建$1$~$(l_{i}-1),(r_{i}+1)$~$m$这些边)，用并查集维护的思路很好想，复杂度为$O(mk)$, 在卡常或是手动$O3$的情况下可以跑过，但并不是最优解。 我们发现很多边重复建了很多次，没有意义，于是我们只需要预处理出$1$~$l_{i}$这些边连起来得到的并查集与$r_{i}$~$n$这些边连起来得到的并查集，将其合并，求出联通快即可。 难点：如何合并？ 我们可以将左边i条边所得的并查集$l_{i}$直接复制到现在一个的并查集$f$中，然后，我们将现在正在处理的并查集中的每个元素和连右边$j$条边的并查集$r_{j}$的元素一一合并，得到一个新的并查集，这个新的并查集中集合的元素就是答案(统计有多少$f_{i}=i$即可)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int f[10005],l[10005][505],r[10005][505],x[10005],y[10005];int find1(int i,int k)&#123; if (l[i][k]==k)return k; else return l[i][k]=find1(i,l[i][k]);&#125;int find2(int i,int k)&#123; if (r[i][k]==k)return k; else return r[i][k]=find2(i,r[i][k]);&#125;int find(int k)&#123; if (f[k]==k)return k; else return f[k]=find(f[k]);&#125;//三个数组的并查集操作int main()&#123; int n=read(),m=read(); for (int j=1;j&lt;=n;++j) l[0][j]=j,r[m+1][j]=j;//预处理 for (int i=1;i&lt;=m;++i)&#123; x[i]=read(),y[i]=read(); for (int j=1;j&lt;=n;++j)l[i][j]=l[i-1][j]; int u=find1(i,x[i]),w=find1(i,y[i]); if (u!=w)l[i][u]=w; &#125; for (int i=m;i;--i)&#123; for (int j=1;j&lt;=n;++j)r[i][j]=r[i+1][j]; int u=find2(i,x[i]),w=find2(i,y[i]); if (u!=w)r[i][u]=w; &#125; int k=read(); for (int i=1;i&lt;=k;++i)&#123; int l1=read(),r1=read(),cnt=0; for (int i=1;i&lt;=n;++i)f[i]=l[l1-1][i];//将l数组[l1-1]数组复制给f数组 for (int j=1;j&lt;=n;++j)f[find(l[l1-1][j])]=find(r[r1+1][j]);//合并两个并查集 for (int j=1;j&lt;=n;++j) if (f[j]==j) ++cnt;//统计答案 printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1972 [SDOI2009]HH的项链]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P1972%20%5BSDOI2009%5DHH%E7%9A%84%E9%A1%B9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[题意概括：给定一个长度为$N$的自然数序列$(N\leqslant500000$,数的范围$0$到$1000000$之间的整数)，有$M$个询问，每个询问两个整数$l,r$表示$l$~$r$区间内有几个不同的数$(M\leqslant500000)$ 这道题我们考虑离线+树状数组。 设$last_{i}$表示$1$~当前枚举到的右端点 这个序列中i这个数最后出现的位置，如果要求$l$~$r$之间不同的数个数，只要求有几个$last_{i}$在$l$~$r$之间即可,因为我们可以将当前不为空的$last_{i}$分成两类，一类为大小在$1$~$(l-1)$中，因为$last_{i}$表示最后出现的位置，所以在$l$之后不可能有$i$这个数，我们将这一类数设为$a$;另一类为大小在$l$~$r$中，由于$last_{i}$的定义，所以$i$这个数一定在$l$~$r$之间，我们将这一类数设为$b$。显然答案就是$b$，所以我们只需要求$sum_{r}-sum_{l-1}$即可(因为$sum_{r}=a+b,sum_{l-1}=a)$。 我们将询问保存下来，设为$b$数组，将$b$数组按照右端点排序，从让$i=1$~$n$枚举右端点，若$i=b[j].r$,则$j++$并统计答案，然后更新$last$数组。 单点修改，区间查询，显然可以用树状数组维护。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long longstruct node&#123; int l,r,num;&#125;b[3000000];using namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int ans[3000000],a[3000000],n,m,last[3000000],c[3000000];inline int lowbit(int x)&#123; return x&amp;(-x);&#125;inline void change(int x,int d)&#123; if (!x)return; for (;x&lt;=n;x+=lowbit(x)) c[x]+=d;&#125;inline int query(int x)&#123; int res=0; for (;x;x-=lowbit(x)) res+=c[x]; return res; &#125;inline bool cmp(node a,node b)&#123; return a.r&lt;b.r;&#125;int main()&#123; n=read(); for (int i=1;i&lt;=n;i++) a[i]=read(); m=read(); for (int i=1;i&lt;=m;i++) b[i].l=read(),b[i].r=read(),b[i].num=i; sort(b+1,b+1+m,cmp); int t=1; for (int i=1;i&lt;=n;i++)&#123; change(i,1); change(last[a[i]],-1); while (b[t].r==i)&#123; ans[b[t].num]=query(b[t].r)-query(b[t].l-1); t++; &#125; last[a[i]]=i; &#125; for (int i=1;i&lt;=m;i++) printf("%d\n",ans[i]);&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1550 [USACO08OCT]打井Watering Hole]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P1550%20%5BUSACO08OCT%5D%E6%89%93%E4%BA%95Watering%20Hole%2F</url>
    <content type="text"><![CDATA[做法最小生成树很容易发现，但是难点在于想单独打井，设一个源点$0$，把每个井与$0$连边，费用就是打井所需费用 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int u,v,d;&#125;a[3000000];int cnt,x,n,m,ed,ans,f[400000];bool cmp(node a,node b)&#123; return a.d&lt;b.d;&#125;int find(int k)&#123; return (f[k]==k)?k:(f[k]=find(f[k]));&#125;void bing(int x,int y,int d)&#123; int u=find(x),v=find(y); if (u==v)return; f[u]=v; ans+=d; ++ed;&#125;int main()&#123; scanf("%d",&amp;n); for (int i=1;i&lt;=300000;i++)f[i]=i; for (int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); a[++cnt].v=i;a[cnt].d=x; &#125; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++)&#123; scanf("%d",&amp;x); if (j&lt;i) a[++cnt].u=j,a[cnt].v=i,a[cnt].d=x; &#125; sort(a+1,a+1+cnt,cmp); for (int i=1;i&lt;=cnt&amp;&amp;ed&lt;=2*n+1;i++) bing(a[i].u,a[i].v,a[i].d); printf("%d",ans);&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2921 【[USACO08DEC]在农场万圣节Trick or Treat on the Farm】]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P2921%20%E3%80%90%5BUSACO08DEC%5D%E5%9C%A8%E5%86%9C%E5%9C%BA%E4%B8%87%E5%9C%A3%E8%8A%82Trick%20or%20Treat%20on%20the%20Farm%E3%80%91%2F</url>
    <content type="text"><![CDATA[发现巨佬们都用$Tarjan$，但是蒟蒻我用了并查集写这道题，这道题很像P2661，那道题用带权并查集求有向图中的最小环，这道题要求的是每个点在有向图中的环的长度或进入环之前经过的点数与环的长度的和。由于并查集经过路径压缩后只能存储它祖先的信息，所以我们开一个$fa$数组记录它的父亲。判断环我们只需判断读入的$a_{i}$与$i$是否祖先节点相同，那么就可以判断是否能构成一个环。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;//快读int ans[300000],f[300000],fa[3000000];int find(int k)&#123; if (f[k]==k)return k; else return f[k]=find(f[k]);&#125;//并查集int main()&#123; int n=read(); for (int i=1;i&lt;=200000;i++)f[i]=i,fa[i]=1;//初始化 for (int i=1;i&lt;=n;i++)&#123; int x=read(); if (find(x)==find(i))&#123;//如果构成环 int res=1; for (int j=x;j!=i;j=fa[j]) res++;//从x-&gt;x的父亲--&gt;……直到回到i，其中i~x这条边没算，所以res初值赋为1 for (int j=x;j!=i;j=fa[j]) ans[j]=res;//给环中的每个节点的答案赋值 ans[i]=res;//i这个点刚刚没赋值 &#125;else&#123; f[find(i)]=find(x); fa[i]=x; &#125; &#125;//由于i一定是第一次赋值，所以find(i)一定等于i，所以这个循环中的find(i)都可以写成i for (int i=1;i&lt;=n;i++) if (ans[i]==0)&#123; int res=1,j; for (j=fa[i];ans[j]==0;j=fa[j]) res++; ans[i]=res+ans[j]; &#125;//特别处理自身不在环中的点，计算进入环之前经过的点数与环的长度的和 for (int i=1;i&lt;=n;i++) printf("%d\n",ans[i]);&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4870 【[BalticOI 20A09 Day1]甲虫】]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P4870%20%E3%80%90%5BBalticOI%202009%20Day1%5D%E7%94%B2%E8%99%AB%E3%80%91%2F</url>
    <content type="text"><![CDATA[这道题应该一眼就能看出是区间$DP$，但是关键在于怎么写,我们用$f[i][j][0/1]$表示取完$i$~$j$之间的露水，停在$i$或$j$浪费的水分,因为露水水分不可能为负数，而走到后来可能行走路程$&gt;m$，使得计算出的水分为负，所以我们要枚举取的总的露水数$p$（注意不是水分数）于是我们可以列出状态转移方程： $f[i][j][0]=min(f[i+1][j][0]+(p-len+1)\times(a[i+1]-a[i]),f[i+1][j][1]+(p-len+1)\times(a[j]-a[i]));$ $f[i][j][1]=min(f[i][j-1][1]+(p-len+1)\times(a[j]-a[j-1]),f[i][j-1][0]+(p-len+1)\times(a[j]-a[i]));$ $len$为$j-i+1$，即当前采集的露水数 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int n,m,a[4000],f[400][400][2],t[400][400][2],ans;int main()&#123;// freopen("water.in","r",stdin);// freopen("water.out","w",stdout); n=read();m=read(); for (int i=1;i&lt;=n;i++) a[i]=read(); a[++n]=0;//由于从0出发，故添加一个点为0 sort(a+1,a+1+n);//排序应该不难理解 int z=lower_bound(a+1,a+1+n,0)-a;//找出排序后0在的位置 for (int p=1;p&lt;=n;p++)&#123;//枚举p memset(f,0x3f,sizeof(f)); f[z][z][0]=0;f[z][z][1]=0;//初始化 for (int len=2;len&lt;=p;len++) for (int i=1;i&lt;=n-len+1;i++)&#123; int j=i+len-1; f[i][j][0]=min(f[i+1][j][0]+(p-len+1)*(a[i+1]-a[i]),f[i+1][j][1]+(p-len+1)*(a[j]-a[i])); f[i][j][1]=min(f[i][j-1][1]+(p-len+1)*(a[j]-a[j-1]),f[i][j-1][0]+(p-len+1)*(a[j]-a[i]));//状态转移方程 ans=max(ans,(len-1)*m-min(f[i][j][1],f[i][j][0]));统计答案 &#125; &#125; cout&lt;&lt;ans;&#125;]]></content>
      <tags>
        <tag>区间$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4085 【[USACO17DEC]Haybale Feast】]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P4085%20%E3%80%90%5BUSACO17DEC%5DHaybale%20Feast%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到题解里巨佬们都写线段树、树状数组、ST表、分块、堆……等数据结构，但是复杂度都至少是$nlogn$的，于是我写了个尺取法+单调队列的方法，时间复杂度$O(n)$ 单调队列维护区间中$si$~$sj$的最大值,这里运用到了一点贪心策略，如果两个区间有包含关系，那么大的区间最大值一定$\geqslant$小的区间最大值，所以对于每一个$i$，我们去前面找第一个$head$，使$sum_{i,j}\geqslant m$ 如图所示，我们选择$5$作为$head$而不是前面的$11$、$2$、$3$、$4$，是因为区间更长，就像在一个数列中加入了另一些数，另一些数中可能有大于原数列的最大值，因为要求最大值的最小值，故不是最优。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;//快读int a[300000],b[300000],p[300000],head=1,head1=1,tail1=0,ans=2100000000;ll sum,m;inline ll Min(int a,int b)&#123; if (a&gt;b)return b; else return a;&#125;int main()&#123; int n=read(); scanf("%lld",&amp;m); for (int i=1;i&lt;=n;i++) a[i]=read(),b[i]=read(); for (int i=1;i&lt;=n;i++)&#123; sum+=a[i]; while (head&lt;=i&amp;&amp;sum-a[head]&gt;=m)&#123; sum-=a[head];head++;//这里注意要先减再head++，尺取法与单调队列在这里都容易出错 &#125; while (head1&lt;=tail1&amp;&amp;p[head1]&lt;head) head1++;//若队首位置小于区间左端，则出队 while (head1&lt;=tail1&amp;&amp;b[i]&gt;=b[p[tail1]]) tail1--;//若新加入的数大于队尾，则队尾出队 p[++tail1]=i;//放入队列 if (sum&gt;=m)ans=Min(ans,b[p[head1]]); &#125; printf("%lld",ans);&#125;]]></content>
      <tags>
        <tag>尺取法</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
</search>
