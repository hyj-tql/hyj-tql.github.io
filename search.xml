<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解 P2048 【[NOI2010]超级钢琴】]]></title>
    <url>%2F2020%2F02%2F20%2F%E9%A2%98%E8%A7%A3%20P2048%20%E3%80%90%5BNOI2010%5D%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给$n$个数，求数字和前$k$大的区间的和 $Solution$我们考虑先找全局最大值，再删去全局最大值，找次大值，然后删去，直到找到第$k$大值。 枚举左端点，此时可行的右端点是一个区间$[i+L-1,min(i+R-1,n)]$,可以搞一个结构体$\left( i,i+L-1,min(i+R-1,n),\max\limits_{j=i+L-1}^{min(i+R-1,n)}sum[j],loc\right),loc$表示$max\;sum[j]$的位置$j,$然后把它扔到堆里，堆中比较$\max\limits_{j=i+L-1}^{min(i+R-1,n)}sum[j]-sum[i-1]$ 全局最大值取堆顶${x,l,r,mx,loc}$,然后弹出，放入$\left(x,l,loc-1,\max\limits_{j=l}^{loc-1}sum[j],nloc_1\right)$和$\left(x,loc+1,r,\max\limits_{j=loc+1}^{r}sum[j],nloc_2\right)$ 这个东西显然是对的 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 500200using namespace std;int lg[N],n,m,L,R;ll ans,sum[N];struct node&#123; int v,loc; friend bool operator &lt;(node a,node b)&#123; return a.v&lt;b.v; &#125;&#125;f[N][21];struct rec&#123; int x,l,r;node v; friend bool operator &lt;(rec a,rec b)&#123; return a.v.v-sum[a.x-1]&lt;b.v.v-sum[b.x-1]; &#125;&#125;;priority_queue&lt;rec&gt;q;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;node query(int l,int r)&#123; int s=lg[r-l+1]; return max(f[l][s],f[r-(1&lt;&lt;s)+1][s]);&#125;signed main()&#123; n=read(),m=read(),L=read(),R=read();lg[0]=-1; for (int i=1;i&lt;=n;++i) f[i][0]=(node)&#123;sum[i]=sum[i-1]+read(),i&#125;,lg[i]=lg[i&gt;&gt;1]+1; for (int j=1;j&lt;=20;++j) for (int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); for (int i=1;i&lt;=n;++i) if (i+L-1&lt;=n) q.push((rec)&#123;i,i+L-1,min(i+R-1,n),query(i+L-1,min(i+R-1,n))&#125;); while (m--)&#123; rec u=q.top();q.pop(); if (u.l&lt;u.v.loc)q.push((rec)&#123;u.x,u.l,u.v.loc-1,query(u.l,u.v.loc-1)&#125;); if (u.v.loc&lt;u.r)q.push((rec)&#123;u.x,u.v.loc+1,u.r,query(u.v.loc+1,u.r)&#125;); ans+=u.v.v-sum[u.x-1]; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>$st$表</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1009E 【Intercity Travelling】]]></title>
    <url>%2F2019%2F10%2F13%2F%E9%A2%98%E8%A7%A3%20CF1009E%20%E3%80%90Intercity%20Travelling%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$你要从$A$到$B$，需要走$n$步。若你已走了$s$步，那么你再走一步的代价将为$a[s+1]$。 在走完每一步后有$\frac{1}{2}$的概率休息，休息后$s$将变为$0$。 求出你从$A$到$B$的代价的期望$p$乘上$2^{n-1}$对$998244353$取模的结果。 $Solution$由于乘了$2^{n-1},$所以答案即是所有情况走的代价之和 考虑一个复杂度为$O(n^2)$的$dp,$设$f[i]$表示走了$i$步后的答案。 显然，$f[i]=\sum\limits_{i=1}^{i-1}(f[j]+2^{j-1}\times sum_{i-j})+sum_i$ 然后发现这个式子很难优化所以对它进行推导 $f[i]=\sum\limits_{j=1}^{i-1}(f[j]+2^{j-1}\times sum[i-j])+sum[i]$ $f[i]=(\sum\limits_{j=1}^{i-1}f[j])+[\sum\limits_{j=1}^{i-1}(2^{j-1}\times sum_[i-j])]+sum[i]$ $f[i]=(\sum\limits_{j=1}^{i-1}f[j])+[\sum\limits_{j=1}^{i-1}(sum[j]\times2^{i-1-j})]+sum[i]$ $f[i]=(\sum\limits_{j=1}^{i-1}f[j])+[\sum\limits_{j=1}^{i-1}(a[i]\times\sum\limits_{k=0}^{i-1-j}2^k)]+sum[i]$ $f[i]=(\sum\limits_{j=1}^{i-1}f[j])+\sum\limits_{j=1}^{i-1}[a[i]\times (2^{i-j}-1)]+sum[i]$ $f[i]=(\sum\limits_{j=1}^{i-1}f[j])+\sum\limits_{j=1}^{i-1}[a[i]\times 2^{i-j}]-sum[i-1]+sum[i]$ $f[i]=(\sum\limits_{j=1}^{i-1}f[j])+\sum\limits_{j=1}^{i-1}[a[i]\times 2^{i-j}]+a[i]$ $f[i]=(\sum\limits_{j=1}^{i-1}f[j])+\sum\limits_{j=1}^{i}[a[i]\times 2^{i-j}]$ 设$g[i]=\sum\limits_{j=1}^{i-1}f[j],h[i]=\sum\limits_{j=1}^{i}[a[i]\times 2^{i-j}]$ $g[i]=g[i-1]+f[i],h[i]=h[i-1]\times 2+a[i]$ 然后就可以无脑递推了 $Code$123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 1000007#define mod 998244353using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,x,h,f,g;signed main()&#123; n=read(); for (int i=1;i&lt;=n;++i)&#123; x=read(); h=((h&lt;&lt;1)+x)%mod;f=(g+h)%mod;g=(g+f)%mod; &#125; printf("%d\n",f); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 BZOJ4401]]></title>
    <url>%2F2019%2F10%2F09%2F%E9%A2%98%E8%A7%A3%20BZOJ4401%2F</url>
    <content type="text"><![CDATA[$Description$把一棵树分成几块，使得每个块中的点数都相同，问有多少种块的大小能满足该条件 $Solution$考虑一个性质$:$对于一个块的大小$s,$当且仅当有$\frac{n}{s}$个节点的$size($即子树大小$)$为$s$ 的倍数。 证明$:$ 假设$size$为$s$的倍数的节点为$a$节点 先证明一棵树中$a$节点的个数不会超过$\frac{n}{s}$个。采取反证法，假设一棵树中$a$节点有$\frac{n}{s}+1$个，那么我们可以先构造出一颗有$\frac{n}{s}+1($大于$\frac{n}{s}+1$个节点的情况可以以此类推$)$个节点的树，假设这些点都是$a$节点，然后通过加入$n-(\frac{n}{s}+1)$个点$($可以加在边上$)$来满足条件，不断找叶子节点，在它下面连一颗大小为$s-1$的树,然后我们可以删去这个节点和它的子树，因为它对上面的祖先$\%s$的余数已经没有影响了。我们发现，对于每一个$a$节点，我们都需要$s-1$个新增节点。那么总的新增节点数就是$(\frac{n}{s}+1)\times (s-1)=n-s-(\frac{n}{s}+1),$再加上原先的$a$节点数即总节点数为$n+s&gt;n$，所以一棵树中$a$节点的个数不会超过$\frac{n}{s}$个。 再证明为什么有$\frac{n}{s}$个$a$节点就可以构造，我们只需要每次找到一个$size==s$的$a$节点然后将它和它的子树分成一个块然后在树上删除这个块即可。每次至少能找出一个$size==s$的$a$节点。因为如果每个$a$节点的$size$都至少为$2\times s,$那么假设$a$节点的$size$最小为$2\times s($大于$2\times s$的可以以此类推$),$那么删去这个$size==2\times s$的节点和它的子树，那么剩下的树的$a$节点数不会超过$\frac{n-2\times s}{s}$个，再加上这个删去的节点，$a$节点的数量只有$\frac{n}{s}-1$个所以每次至少能找出一个$size==s$的$a$节点，也就可以顺利构造了。 小于$\frac{n}{s}$个$a$节点用上面的构造方法模拟一下就知道显然不可行$($没有$size==s$的$a$节点你是没办法继续分块的$)$。 然后就很无脑了，先$dfs$求出每个点的$size,$然后全扔桶里面，然后从$1\sim n$枚举块的大小，$O(\frac{n}{i})$计算$a$节点的个数。 复杂度就是调和级数$O(nlogn)$ $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 1002302using namespace std;struct edge&#123; int to,next;&#125;e[N&lt;&lt;1];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt,head[N],size[N],n,ma[N],ans;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; size[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs(v,u); size[u]+=size[v]; &#125;&#125;signed main()&#123; n=read(); for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; dfs(1,0); for (int i=1;i&lt;=n;++i)++ma[size[i]]; for (int i=1;i&lt;=n;++i) if (n%i==0)&#123; int res=0; for (int j=i;j&lt;=n;j+=i) res+=ma[j]; ans+=(res==n/i); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>调和级数</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT2134 【Zigzag MST】]]></title>
    <url>%2F2019%2F09%2F22%2F%E9%A2%98%E8%A7%A3%20AT2134%20%E3%80%90Zigzag%20MST%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$对一张$n$个点的图做$Q$次加边操作,每次给定$A_i,B_i,C_i,$然后按顺序连边$(A_i,B_i,C_i),(B_i,A_i+1,C_i+1),(A_i+1,B_i+1,C_i+2)$等等，求给定图的最小生成树$.(A_i,B_i,C_i$等点编号均为对$n$取模的意义下$)$给定初始的$n,q,A_i,B_i,C_i;$ $(N,Q\leqslant 200000,0\leqslant A_i,B_i&lt;N,1\leqslant C_i\leqslant 10^9)$ $Solution$经过简单思考，我们发现，对于一次加边操作，最多加入$2\times n$条边，因为第$2\times n+1$条边为$((A_i+n)\%n,((B_i+n)\%n,d+2\times n)$即$(A_i,B_i,d+2\times n),$由于求最小生成树，往后的边加入就没有意义了。 所以总边数为$N\times Q$,然而这个复杂度依然无法接受 对于一次连边,假设连$(A_i,B_i,C_i),$那么第二条边就要连$(B_i,A_i+1,C_i+1),$由于此时$A_i$和$B_i$已经联通$(B_i,A_i+1,C_i+1)$其实等价于$(A_i,A_i+1,C_i+1)$ 于是我们可以发现，每次连边操作就相当于连$(A_i,B_i,C_i)$ $((A_i+d-1)\%n+1,(A_i+d)\%n+1,C_i+2\times d+1)$ $((B_i+d-1)\%n+1,(B_i+d)\%n+1,C_i+2\times d+2)(0\leqslant d&lt;n)$ 虽然这并没有改变每次加边$O(n)$的复杂度 但是我们发现$(A_i+1,A_i+2)$的边权等于$(A_i,A_i+1)$的边权$+2$ 于是我们设一个数组$g,$使得$g[i]$表示$(i,i\%n+1)$这条边的最小边权$($开始时设为$inf),$接着对于一次连边我们连上$(A_i,B_i,C_i),$再将1g[u]=min(g[u],d+1);g[v]=min(g[v],d+2); 然后我们只需要再用$g[i]$更新$g[i\%n+1]$即可，由于更新的节点顺序呈环形，所以需要更新两遍 1g[i%n+1]=min(g[i%n+1],g[i]+2); 最后再连上$(i,i\%n+1,g[i])$就可以将将边数降低到$O(n)$级别，然后直接跑$Kruskal$即可 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define re register#define N 301200#define pii pair&lt;int,int&gt;#define mp make_pair#define fi first#define se second#define mod 1000000007using namespace std;struct edge&#123; int u,v,d;&#125;e[N&lt;&lt;1];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int f[N],g[N],ans,n,Q,cnt;inline bool cmp(edge a,edge b)&#123; return a.d&lt;b.d;&#125;int find(int k)&#123;return f[k]==k?k:f[k]=find(f[k]);&#125;void Kr()&#123; sort(e+1,e+1+cnt,cmp); for (int i=1,t=0;i&lt;=cnt;++i)&#123; int x=find(e[i].u),y=find(e[i].v); if (x==y)continue; f[x]=y; ++t;ans+=e[i].d; if (t==n-1)break; &#125;&#125;signed main()&#123; n=read(),Q=read(); memset(g,0x3f,sizeof(g)); while (Q--)&#123; int u=read()+1,v=read()+1,d=read(); e[++cnt]=(edge)&#123;u,v,d&#125;; g[u]=min(g[u],d+1);g[v]=min(g[v],d+2); &#125; for (int i=1;i&lt;=n;++i) g[i%n+1]=min(g[i%n+1],g[i]+2),f[i]=i; for (int i=1;i&lt;=n;++i) g[i%n+1]=min(g[i%n+1],g[i]+2); for (int i=1;i&lt;=n;++i)e[++cnt]=(edge)&#123;i,i%n+1,g[i]&#125;; Kr(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>连边优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 模拟赛]]></title>
    <url>%2F2019%2F09%2F22%2F%E9%A2%98%E8%A7%A3%20%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[$T1$对于$20\%$的数据，状压暴力 对于$50\%$的数据，网络流,但是出题人没写过 对于$100\%$的数据 转换成图论问题，对物质和变换规则建点，对于一种变换规则，需要$L$种物质，缺一不可，类似于拓扑排序的感觉，而在一种变换规则成立后，它又会带来$R$种物质，类似于$bfs$的感觉，所以不能只用$bfs$或拓扑排序，所以，只需要两个一起用就行了极其无脑 $T2$看到二叉搜索树，应该很容易想到对树进行中序遍历。这样问题就变成了对一个序列$A_i,$修改数量最少的元素，使得这个数列严格递增 对于$30\%$的数据$,2^n$枚举那些点改变，然后贪心 对于$50\%$的数据,给求最长不下降子序列只会$O(n^2)$的选手准备的，即正解中的求最长不下降子序列$O(nlogn)$改成$O(n^2)$. 对于$100\%$的数据 一个比较$naive$的想法就是对这个序列求最长上升子序列$x,$然后$n-x$即是答案。 这显然是错误的 然后我们考虑一个奇技淫巧,将每个$A_i-$$=i,$然后求最长不下降子序列 举个栗子$:2\;\; 9\;\;3\;\;9\;\;4\;\;8\;\;5,$按照上面的做法得出的最长上升子序列为$2~3~4~5$或$2~3~4~8$,得出的修改次数为$3,$但是显然答案为$5.$ 而我们修改后的序列为$1\;\;7\;\;0\;\;5\;\;-1\;\;2\;\;-2$ 这样修改后可以做到第$i$个位置最少要比第$i+1$个位置少$，1，$而$i$最少要比$i+2$的位置少$2$. $T3$对于$Subtask~1:$ $1.$枚举两个点，路径中一个个节点统计 $2.n^2$枚举两个点，然后用树剖判断判断是否可行 复杂度$O(n^2log^2n)$ 对于$Subtask~2:$ 将正解的扫描线改成暴力修改 复杂度$O(n^2)$ 对于$Subtask~3:$ 尺取法 复杂度$O(n)$ 对于$Subtask~4:$ 由于每种颜色最多只有$20$个节点。我们枚举一对颜色相同的节点，分别设为$x,y$. 对于$x,y$的情况分成两类$($下面默认$dep_x&lt;dep_y):$ $1.x$不是$y$的祖先 那么所有两端分别位于$x$的子树与$y$的子树中的路径都是不合法的。 $2.x$是$y$的祖先 那么不合法路径的一段位于$y$的子树,另一端位于$y$所在$x$的儿子的子树中。 如果用一个矩阵表示的话，枚举一对颜色相同的节点就相当于对一个矩形染色。 最后没有染色的就是合法路径，再根据题目限制去重一下即是最终答案。 矩阵求并用扫描线即可 总结出题人估计难度 $\color{limegreen}{绿}$,$\color{limegreen}{绿}$,$\color{blueViolet}{紫}$. 本次比赛难度类似$NOIPday1$,而且暴力分很足 但是由于没有送分题，所以平均分不会很高 对于$T1,$估计有$6 \sim 10$个人$A$掉，平均分大概在$35 \sim 60$之间,因为$20\%$的数据很容易，网络流估计有$6$个左右的人写出来 对于$T2$，估计有$5 \sim 10$个人$A$掉，平均分大概在$30\sim 50 $之间,因为出题人觉得转成中序遍历应该有少部分人想不到，但是想到的话$30$分应该稳拿，即使想不到也还有链的情况可以写。 对于$T3$,估计有$2\sim 5$个人$A$掉,平均分大概在$30\sim 50$之间，因为$25\%$的暴力很无脑，$15\%$的链的情况也不难想，并且原题挺有名的 $1.$赠送分$20+30+25=75$ $2.$普通暴力神仙$50+30+25=105$ $3.$高级暴力神仙$100+50+40=140$ $4.$平均分$70+40+40-10($平均写萎分$)=140.$ $5.AK$神仙$100+100+100=300$ 原题$:$ $T1:$https://www.luogu.org/problem/P4957 $T2:$别人博客里嫖的思想，应该没有原题 $T3:$https://loj.ac/problem/6276]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>拓扑排序</tag>
        <tag>$bfs$</tag>
        <tag>图论</tag>
        <tag>二叉搜索树</tag>
        <tag>最长上升子序列</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 loj2349「JOI 2018 Final」团子制作]]></title>
    <url>%2F2019%2F08%2F29%2F%E9%A2%98%E8%A7%A3%20loj2349%E3%80%8CJOI%202018%20Final%E3%80%8D%E5%9B%A2%E5%AD%90%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[$Description$你是一个制作团子的师傅，现在，你正想用竹签把团子串成一串。 团子被放置在长为$N$行，宽为$M$列的隔开的格子里，每个格子里都放着一个团子。每个团子的颜色是红、绿与白中的一种。 你可以选择三个从左到右，或者从上到下的连续的格子，把格子中的团子串成一串，按照这个顺序，一串团子串上正好会有三个团子。 现在，你希望尽可能多做些颜色按照红绿白顺序的团子串，并且团子在串上的顺序必须与从格子中取出的顺序相同。需要注意的是，同一个团子只能被串在一串团子串上。 你最多能制作多少串团子串呢？ 给出放置在每个格子上的团子的颜色，你需要计算最多能制作的团子串的数量。团子串的颜色必须按照红、绿、白的顺序。 $Solution$很有意思的$DP,$考虑团子串中间的$G$不在同一对角线的团子串不会互相影响，所以在对角线上进行$DP.$对于一条对角线，我们从左下向右上$DP,f_{i,0/1}$表示当前对角线从左下到右上第$i$个团子可以与左右或上下的团子构成团子串$,0/1$表示跟左右/上下构成团子串。 $f_{i,j}$只能由$f_{k,t}(0\leqslant k&lt; i,t=0/1)$或$f_{i-1,j}$转移过来。 转移很好想，但是难想在考虑到不在同一对角线的团子串不会互相影响。 $Code$12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 3012using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N][N];int n,m,f[N][2],ans;int calc(int x,int y)&#123; return (s[x-1][y]=='R'&amp;&amp;s[x][y]=='G'&amp;&amp;s[x+1][y]=='W')&lt;&lt;1|(s[x][y-1]=='R'&amp;&amp;s[x][y]=='G'&amp;&amp;s[x][y+1]=='W');&#125;signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=n;++i)scanf("%s",s[i]+1); for (int i=1,j=1;i&lt;=n+m-1;++i,j=1)&#123; int mx=0; for (int x=min(i,n),y=max(1,i-n+1);x&amp;&amp;y&lt;=m;--x,++y)&#123; int opt=calc(x,y);++j;f[j][0]=f[j][1]=0; mx=max(mx,max(f[j-2][0],f[j-2][1])); if (opt&amp;1)f[j][0]=max(f[j-1][0],mx)+1; if (opt&amp;2)f[j][1]=max(f[j-1][1],mx)+1; &#125; ans+=max(mx,max(max(f[j-1][0],f[j][0]),max(f[j-1][1],f[j][1]))); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 Codeforces Round]]></title>
    <url>%2F2019%2F08%2F17%2F%E9%A2%98%E8%A7%A3%20Codeforces%20Round%20%23579%20(Div.%203)%2F</url>
    <content type="text"><![CDATA[比赛链接$:$点击进入 A Circle of Students$Description$$T$组询问，每组询问给出$n$个数字，问这$n$个数字能否顺时针或逆时针围成圆环。 $Solution$直接模拟即可$,$但是我是用计算差分数组$($假设第$n$个数字的下一个数字为第$1$个数字$)$ 如果差分数组中$n$个数含有$n-1$个$1$或者$-1,$那么输出$YES,$否则输出$NO.$ $Code$1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 101800using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int a[N],n,c[N];bool check()&#123; a[n+1]=a[1]; for (int i=1;i&lt;=n;++i)c[i]=a[i+1]-a[i]; int cnt=0; for (int i=1;i&lt;=n;++i) cnt+=(c[i]==1); if (cnt==n-1)return 1; cnt=0; for (int i=1;i&lt;=n;++i) cnt+=(c[i]==-1); if (cnt==n-1)return 1; return 0;&#125;signed main()&#123; int T=read(); while (T--)&#123; n=read(); for (int i=1;i&lt;=n;++i)a[i]=read(); puts(check()?"YES":"NO"); &#125; return 0;&#125; B Equal Rectangles$Description$$q$组输入，每组输入给出一个整数$n$，然后输入$4\times n$个木棍长度。判断这些木棍能否构成$n$个面积相同的矩形。 $Solution$把这些木棍长度先映射到桶里去，如果有一个桶中木棍的个数是奇数，那么直接退出输出$NO$。由于一对长度相同的木棍是成对出现的，所以要把两个相同的木棍长度只保留一个，然后确定矩形的面积，显然是这些木棍长度的最小值乘最大值。然后一一判断即可 $Code$1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 101800using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int a[N],n,c[N],b[N];bool check()&#123; int tot=0;memset(b,0,sizeof(b)); for (int i=1;i&lt;=n&lt;&lt;2;++i)++b[a[i]]; for (int i=1;i&lt;=1e4;++i)&#123; if (b[i]&amp;1) return 0; for (;b[i];b[i]-=2)&#123; c[++tot]=i; &#125; &#125; int v=c[1]*c[n&lt;&lt;1]; for (int i=2;i&lt;=n;++i) if (c[i]*c[(n&lt;&lt;1)-i+1]!=v) return 0; return 1;&#125;signed main()&#123; int T=read(); while (T--)&#123; n=read(); for (int i=1;i&lt;=n&lt;&lt;2;++i)a[i]=read(); puts(check()?"YES":"NO"); &#125; return 0;&#125; C Common Divisors$Description$给出$n$个正整数，找出能整除这$n$个数的正整数个数。 $Solution$即求最大公约数的因子个数 $Code$12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define re register#define N 1001800using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int a[N],n,c[N],b[N],v,ans=1;int gcd(int a,int b)&#123;return b?gcd(b,a%b):a;&#125;signed main()&#123; n=read(); for (int i=1;i&lt;=n;++i) v=gcd(v,read()); for (int i=2;i&lt;=1e6;++i)&#123; while (v%i==0)&#123; ++c[i];v/=i; &#125; ans*=c[i]+1; &#125; if (v!=1)ans*=2; printf("%lld\n",ans); return 0;&#125; D1 Remove the Substring (easy version)$Description$给出两个字符串$s$和t，求最大可以在在字符串s中删除连续几个字符后t仍然可以为s的子串$($不要求连续$)$。 $Solution$不会，用$D2$代码交的 $Code$见$D2$代码 D2 Remove the Substring (hard version)$Description$见$D1$题面 $Solution$先预处理出$c[i]$表示$s$中第一个能匹配到$\,t[i]$的位置 再把$s$和$t$反转,再计算一遍$c[i],$记为$f[i]$ 答案即是$\max\limits_{i=0}^{m}(n-f[i]-c[m-i])$ $Code$123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 301800using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N],t[N];int ans,p[N],q[N],c[N],f[N],d[N];signed main()&#123; scanf("%s",s+1); scanf("%s",t+1); int n=strlen(s+1),m=strlen(t+1);d[t[1]]=1; for (int i=1;i&lt;=n;++i)&#123; p[i]=d[s[i]]; d[t[p[i]+1]]=max(d[t[p[i]+1]],p[i]+1); if (p[i]&amp;&amp;!c[p[i]])c[p[i]]=i; &#125; reverse(s+1,s+1+n);reverse(t+1,t+1+m); memset(d,0,sizeof(d));d[t[1]]=1; for (int i=1;i&lt;=n;++i)&#123; q[i]=d[s[i]]; d[t[q[i]+1]]=max(d[t[q[i]+1]],q[i]+1); if (q[i]&amp;&amp;!f[q[i]])f[q[i]]=i; &#125; for (int i=0;i&lt;=m;++i)&#123; ans=max(n-f[i]-c[m-i],ans); &#125; printf("%d\n",ans); return 0;&#125; E Boxers$Description$有$n$个拳击手，给出他们的体重$a_i$，每个拳击手的体重可以$+1$或$-1($体重必须是正整数$)，$询问最多能选出几个体重不同的拳击手。 $Solution$先从大到小排序.如果$a_i+1$未选则选,然后如果$a_i$未选则选,最后如果$a_i-1$未选则选.很显然的贪心 $Code$12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 301800using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,a[N],vis[N],ans;signed main()&#123; n=read(); for (int i=1;i&lt;=n;++i)a[i]=read(); sort(a+1,a+1+n); for (int i=n;i;--i)&#123; if (!vis[a[i]+1])&#123; ++ans; vis[a[i]+1]=1;continue; &#125; if (!vis[a[i]])&#123; ++ans; vis[a[i]]=1;continue; &#125; if (!vis[a[i]-1]&amp;&amp;a[i]&gt;1)&#123; ++ans; vis[a[i]-1]=1;continue; &#125; &#125; printf("%d\n",ans); return 0;&#125; F1 Complete the Projects (easy version)$Description$给定$n$个项目，和一个初始权值$r$。每个项目有两个数值构成，$a$表示要进行这个项目的最低权值需求，$b$表示进行完这个项目后权值将会变化的数值。询问能否通过调整项目顺序完成所有的项目。 $Solution$将项目分成两类.一类为$b$是非负的,另一类$b$是负的. 对于第一类,按照$a$从小到大排序即可.这个贪心很显然 对于第二类,按照$a+b$从大到小排序即可 证明$:$ 显然,只需证明当$a_1+b_1&gt;a_2+b_2$时,如果①②顺序不行的话②①也不行. ①②不行只有两种情况 $1.$①时不行,那么$r&lt;a_1$ ∵$b_2&lt;0$ ∴②①顺序到①时$r+b_2&lt;a_1$ ∴这种情况下如果①②顺序不行的话②①也不行 $2.$②时不行,那么$r+b_1&lt;a_2$ 由$a_1+b_1&gt;a_2+b_2$得$b_2&lt;b_1+a_1-a_2$ ∴$r+b_2&lt;r+b_1+a_1-a_2&lt;a_2-a_2+a_1=a_1$ ∴这种情况下如果①②顺序不行的话②①也不行 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 301800using namespace std;struct node&#123; int a,b;&#125;p[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline bool cmp1(node a,node b)&#123; return a.b&gt;b.b;&#125;inline bool cmp2(node a,node b)&#123; return a.a&lt;b.a;&#125;inline bool cmp3(node a,node b)&#123; return a.a+a.b&gt;b.a+b.b;&#125;int n,m,loc;signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=n;++i)p[i].a=read(),p[i].b=read(); sort(p+1,p+1+n,cmp1); for (int i=n;i;--i) if (p[i].b&gt;=0)&#123; loc=i;break; &#125; sort(p+1,p+loc+1,cmp2); for (int i=loc+1;i&lt;=n;++i)p[i].a=max(p[i].a,-p[i].b); sort(p+loc+1,p+1+n,cmp3); for (int i=1;i&lt;=n;++i)&#123; if (m&lt;p[i].a)&#123;puts("NO");return 0;&#125; m+=p[i].b; &#125; puts("YES"); return 0;&#125; F2 Complete the Projects (hard version)$Description$和$F1$基本一样，就是询问变成了通过调整最多能做几个项目。 $Solution$和$F1$一样分成$b&gt;=0$和$b&lt;0$的项目讨论 对于$b&gt;=0$的情况,按照$a$排序.能取多少取多少 对于$b&lt;0$的情况用类似$01$背包的方法. 将$r$看成背包容量,单个项目的体积是$b$,价值为$1$,$f[i][j]$表示到第$i$个项目,当前$r$为$j$最多可以做几个项目. 但是还有一个问题,$01$背包对于物品的顺序是没有关系的,但是在这个问题中显然是有关系的,所以在$DP$前需要先对项目按照$a+b$从大到小排序.$($原因见$F1$题解$)$ $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 301800using namespace std;struct node&#123; int a,b;&#125;p[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline bool cmp1(node a,node b)&#123; return a.b&gt;b.b;&#125;inline bool cmp2(node a,node b)&#123; return a.a&lt;b.a;&#125;inline bool cmp3(node a,node b)&#123; return a.a+a.b&gt;b.a+b.b;&#125;int n,m,loc,ans1=-1,ans2,f[102][60300];signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=n;++i)p[i].a=read(),p[i].b=read(); sort(p+1,p+1+n,cmp1); for (int i=n;i;--i) if (p[i].b&gt;=0)&#123; loc=i;break; &#125; sort(p+1,p+loc+1,cmp2); for (int i=loc+1;i&lt;=n;++i)p[i].a=max(p[i].a,-p[i].b); sort(p+loc+1,p+1+n,cmp3); for (int i=1;i&lt;=loc;++i)&#123; if (m&lt;p[i].a)&#123; ans1=i-1;break; &#125; m+=p[i].b; &#125; if (ans1==-1)ans1=loc; for (int i=1+loc;i&lt;=n;++i)&#123; memcpy(f[i+1],f[i],sizeof(f[i+1])); for (int j=p[i].a;j&lt;=m;++j)&#123; f[i+1][j+p[i].b]=max(f[i+1][j+p[i].b],f[i][j]+1); ans2=max(ans2,f[i+1][j+p[i].b]); &#125; &#125; printf("%d\n",ans1+ans2); return 0;&#125;]]></content>
      <tags>
        <tag>背包</tag>
        <tag>$DP$</tag>
        <tag>贪心</tag>
        <tag>模拟</tag>
        <tag>差分</tag>
        <tag>排序</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF685B 【Kay and Snowflake】]]></title>
    <url>%2F2019%2F07%2F31%2F%E9%A2%98%E8%A7%A3%20CF685B%20%E3%80%90Kay%20and%20Snowflake%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给出一棵树$($根是$1$$号节点 )$和$q$个询问,对于每个询问$v_i,$要求回答以$v_i$为根的子树的重心 $Solution$先预处理出每个点$u$作为根时的答案，记为$ans[u],$最后$O(1)$回答。 记$u$的重儿子$($即$size$最大的儿子$)$为$son[u]$ 考虑一个性质:如果以当前节点$u$为根$,size[son[u]]&lt;=\frac{size[u]}{2},$所以$,ans[u]$只有可能是$u$自己或者在$son[u]$的子树中。 是$u$自己的情况根据$size[son[u]]$判断一下即可。 在$son[u]$的子树中的情况。因为$size[u]&gt;size[son[u]],$所以$ans[u]$一定在$ans[son[u]]$的上方，因此我们只需要每次从以$son[u]$为根的子树的重心向上跳即可。 由于重心只会向上跳，所以跳的次数就是树高,所以总复杂度为$O(n)$ $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 405400#define mod 1000000007using namespace std;struct edge&#123; int to,next;&#125;e[N&lt;&lt;2];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ans[N],fa[N],mx,loc,size[N],son[N],n,q,head[N],cnt=1;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u)&#123; size[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; dfs(v); size[u]+=size[v]; if (size[v]&gt;size[son[u]])son[u]=v; &#125; if ((size[son[u]]&lt;&lt;1)&gt;size[u])&#123; int x=ans[son[u]]; while (((size[u]-size[x])&lt;&lt;1)&gt;size[u])x=fa[x]; ans[u]=x; &#125;else ans[u]=u;&#125;signed main()&#123; n=read(),q=read(); for (int i=2;i&lt;=n;++i)fa[i]=read(),add(fa[i],i); dfs(1); while (q--)&#123; int x=read(); printf("%d\n",ans[x]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF453C 【Little Pony and Summer Sun Celebration】]]></title>
    <url>%2F2019%2F07%2F31%2F%E9%A2%98%E8%A7%A3%20CF453C%20%E3%80%90Little%20Pony%20and%20Summer%20Sun%20Celebration%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Desciption$给一个无向图$,n$个点$m$条边，给定一个$01$序列，如果$a[i]=1,$要求走到这个点奇数次$,$否则，要求走到这个点偶数次$,$请你任选起点$,$输出满足要求的经过点的序列和序列长度$,$序列长度不能超过$4n$ $Solution$先判断是否有解，如果图不连通，且两个块中都有要求走过奇数次的点，就无解。 我们可以将$a$序列作为初始状态，每经过一次$i$号点，相当于$a[i]~\hat{}=1,$目标是使$a$序列全部变成$0$ 选定一个要求走过奇数次的点作为$root,$每个点只走一次，最后回到$root,$那么走过的就是一棵树。 走的路程就相当于对这棵树进行$dfs$遍历，注意:回溯的过程也算一次经过.所以叶子节点只经过一次，其它节点经过$($儿子数量$+1)$次, 对于一个点，在回溯时，如果$a[i]$还是1，就要进行震荡操作，震荡操作是指对于点$i$回溯到$fa[i]$时，从$fa[i]$走到$i$再走回$fa[i]$的过程，经过这一操作，效果是$a[i]~\hat{}=1,a[fa[i]]~\hat{}=1$ 如果$root$需要震荡,我们可以不回溯到$root$，这样就相当于$a[root]^=1$ $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define re register#define N 405400#define mod 1000000007using namespace std;struct edge&#123; int to,next;&#125;e[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int s,ans[N],vis[N],tot,d[N],n,m,head[N],cnt;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; ans[++tot]=u;vis[u]=1;d[u]^=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (vis[v])continue; dfs(v,u);ans[++tot]=u;d[u]^=1; &#125; if (d[u])&#123; ans[++tot]=fa;ans[++tot]=u;d[fa]^=1;d[u]^=1; &#125;&#125;signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; for (int i=1;i&lt;=n;++i)&#123; d[i]=read();if (d[i])s=i; &#125; dfs(s,0); for (int i=1;i&lt;=n;++i) if (d[i])&#123; puts("-1");return 0; &#125; if (tot&gt;1&amp;&amp;!ans[tot-1])tot-=3; printf("%d\n",tot); for (int i=1;i&lt;=tot;++i)printf("%d ",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF490F 【Treeland Tour】]]></title>
    <url>%2F2019%2F07%2F31%2F%E9%A2%98%E8%A7%A3%20CF490F%20%E3%80%90Treeland%20Tour%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给定一棵带点权树，求树上最长上升子序列的长度 $Solution$以下的$lis$和$lds$均表示从当前点$u$的某个子树节点权值为开头$,w_u$为结尾的$lis$或$lds,m$表示所有节点中最大的权值 对于每个点维护一棵动态开点权值线段树，线段树中下标$i$存储以$~i~$这个数为结尾的$lis$和$~lds($最长上升子序列和最长下降子序列$),$利用线段树合并更新 那么如何更新答案呢$?$ $1.$在$dfs$时 ，假设当前$dfs$到的点是$u,$在$u$的儿子中找两个儿子$v_1,v_2$。在$v_1$的线段树下标$(1\sim (w_{u}-1))$范围内找最长的$lis$,在$v_2$的线段树下标$((w_{u}+1)\sim m)$范围内找最长的$lds$,将两者相加并$+1$更新答案$(+1$是为了加上当前点$u),$ $2.$在$dfs$时，还有一种情况没有被算到，就是当前节点$u$的权值$w_{u}$不在答案序列中，由$u$的两棵子树中选取，这种情况需要在线段树合并时更新答案。 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 801200using namespace std;struct edge&#123; int to,next;&#125;e[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,m,w[N],a[N],tot,lc[N],rc[N],mx[2][N],ans,rt[N],head[N],cnt;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void change(int &amp;k,int l,int r,int x,int d,int id)&#123; if (!k)k=++tot; if (l==r)&#123; mx[id][k]=max(mx[id][k],d); return; &#125; int mid=(l+r)&gt;&gt;1; if (x&lt;=mid)change(lc[k],l,mid,x,d,id); else change(rc[k],mid+1,r,x,d,id); mx[id][k]=max(mx[id][lc[k]],mx[id][rc[k]]);&#125;int query(int k,int l,int r,int x,int y,int id)&#123; if (!k)return 0; if (x&lt;=l&amp;&amp;r&lt;=y) return mx[id][k]; int mid=(l+r)&gt;&gt;1; if (x&lt;=mid&amp;&amp;mid&lt;y)return max(query(lc[k],l,mid,x,y,id),query(rc[k],mid+1,r,x,y,id)); if (x&lt;=mid)return query(lc[k],l,mid,x,y,id); return query(rc[k],mid+1,r,x,y,id);&#125;int merge(int x,int y)&#123; if (!x||!y)return x|y; mx[0][x]=max(mx[0][x],mx[0][y]); mx[1][x]=max(mx[1][x],mx[1][y]); ans=max(ans,max(mx[0][lc[x]]+mx[1][rc[y]],mx[1][rc[x]]+mx[0][lc[y]])); lc[x]=merge(lc[x],lc[y]);rc[x]=merge(rc[x],rc[y]); return x;&#125;void dfs(int u,int fa)&#123; int mxlis=0,mxlds=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs(v,u); int vlis=query(rt[v],1,m,1,w[u]-1,0); int vlds=query(rt[v],1,m,w[u]+1,m,1); ans=max(ans,max(mxlis+vlds,vlis+mxlds)+1); mxlis=max(mxlis,vlis);mxlds=max(mxlds,vlds); rt[u]=merge(rt[u],rt[v]); &#125; change(rt[u],1,m,w[u],mxlis+1,0); change(rt[u],1,m,w[u],mxlds+1,1);&#125;signed main()&#123; n=read(); for (int i=1;i&lt;=n;++i)a[i]=w[i]=read(); sort(a+1,a+1+n);m=unique(a+1,a+1+n)-a-1; for (int i=1;i&lt;=n;++i)w[i]=lower_bound(a+1,a+1+m,w[i])-a; for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; dfs(1,0); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>线段树合并</tag>
        <tag>$lis$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF555E 【Case of Computer Network】]]></title>
    <url>%2F2019%2F07%2F30%2F%E9%A2%98%E8%A7%A3%20CF555E%20%E3%80%90Case%20of%20Computer%20Network%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给定一个$n$个点$,m$条边的无向图。有$q$条有向路线分别从$s_i$到达$t_i$。 现在你要给无向图的每条边分配一个方向。问是否存在一种分配答案使得每条路线的$s_i$和$t_i$都满足能够从$s_i$走到$~t_i$。 $Solution$很容易想到将这个无向图进行边双缩点 考虑边双性质:同一边双联通分量的任意两点至少存在两条不存在同一条边的路径。 所有每对于一个边双，它内部的边一定可以通过分配方向来使得每对点之间都可以互相走到。 缩点后原图就变成了一个森林(原图可能不是一个连通图)。 对于森林中的每一个点，把在同一个树上的所有点用并查集并起来，最后查询时如果有一条线路中的$s_i$和$t_i$不在一棵树上，那么就输出$No$ 我们可以对每个点$u$维护两个标记$up$和$down,$表示$u-fa$这条边的方向是$u\rightarrow fa(up)$还是$u\leftarrow fa(down)(fa$是$u$的父亲$)$如果一个节点同时拥有两个标记则无解。 先考虑暴力实现$:$将$s_i$到$lca$的路径上$($不包括$lca)$的点打上一个$up$的标记,将$lca$到$t_i$的点打上一个$down$的标记$($不包括$lca)$ 我们发现这个东西显然是可以用树上差分优化的 关于树上差分的实现$:$将$s_i$的$up$标记打上一个$+1$,$t_i$的$down$标记上打上一个$+1$标记,在$lca$的$up$和$down$的标记分别打上一个$-1$标记。最后只需在树遍历回溯时加上子节点的标记并判断是否有一个点同时拥有两个标记即可 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 400203using namespace std;struct edge&#123; int dis,to,next;&#125;e[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int vis[N],dep[N],fa[N],f[N][23],num,n,m,c[N],col,up[N],dn[N],q,u[N],v[N],cnt=1,head[N],dfn[N],low[N],st[N],top;int find(int k)&#123; return fa[k]==k?k:fa[k]=find(fa[k]);&#125;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125; void Tarjan(int u)&#123; dfn[u]=low[u]=++num; st[++top]=u; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (vis[i])continue; vis[i]=vis[i^1]=1; if (!dfn[v])&#123; Tarjan(v); low[u]=min(low[u],low[v]); &#125;else if (!c[v]) low[u]=min(low[u],dfn[v]); &#125; if (dfn[u]==low[u])&#123; ++col; do&#123; c[st[top--]]=col; &#125;while (st[top+1]!=u); &#125;&#125;void dfs1(int u,int fa)&#123; f[u][0]=fa;dep[u]=dep[fa]+1; for (int i=1;i&lt;=20;++i) f[u][i]=f[f[u][i-1]][i-1]; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs1(v,u); &#125;&#125;void dfs(int u,int fa)&#123; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs(v,u); up[u]+=up[v];dn[u]+=dn[v]; &#125; if (up[u]&amp;&amp;dn[u])&#123;puts("No");exit(0);&#125;&#125;int LCA(int x,int y)&#123; if (dep[x]&lt;dep[y])swap(x,y); for (int i=20;i&gt;=0;--i)&#123; if (dep[f[x][i]]&gt;=dep[y])x=f[x][i]; if (x==y)return x; &#125; for (int i=20;i&gt;=0;--i) if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;signed main()&#123; n=read(),m=read(),q=read(); for (int i=1;i&lt;=m;++i)&#123; u[i]=read(),v[i]=read(); add(u[i],v[i]);add(v[i],u[i]); &#125; for (int i=1;i&lt;=n;++i) if (!dfn[i]) Tarjan(i); memset(head,0,sizeof(head));cnt=1; for (int i=1;i&lt;=col;++i)fa[i]=i; for (int i=1;i&lt;=m;++i) if (c[u[i]]!=c[v[i]]) add(c[u[i]],c[v[i]]),add(c[v[i]],c[u[i]]),fa[find(c[u[i]])]=find(c[v[i]]); for (int i=1;i&lt;=col;++i) if (!dep[i]) dfs1(i,0); while (q--)&#123; int s=c[read()],t=c[read()],lca=LCA(s,t); if (s==t)continue; if (find(s)!=find(t))&#123;puts("No");return 0;&#125; --up[lca];++up[s];--dn[lca];++dn[t]; &#125; for (int i=1;i&lt;=col;++i) if (find(i)==i) dfs(i,0); puts("Yes"); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>$Tarjan$</tag>
        <tag>边双联通分量</tag>
        <tag>树上差分</tag>
        <tag>$lca$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2761 【软件补丁问题】]]></title>
    <url>%2F2019%2F07%2F30%2F%E9%A2%98%E8%A7%A3%20P2761%20%E3%80%90%E8%BD%AF%E4%BB%B6%E8%A1%A5%E4%B8%81%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Dscription$$T$公司发现其研制的一个软件中有$n$个错误，随即为该软件发放了一批共 $m$个补丁程序。每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。 换句话说，对于每一个补丁$i$，都有 2 个与之相应的错误集合$B1_i$和 $B2_i,$使得仅当软件包含$B1_i$中的所有错误，而不包含$B2_i$中的任何错误时，才可以使用补丁$i$。补丁$i$将修复软件中的某些错误$F1_i,$而同时加入另一些错误$F2_i.$另外，每个补丁都耗费一定的时间。 试设计一个算法，利用$T$公司提供的$m$个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的$n$个错误和$m$个补丁程序，找到总耗时最少的软件修复方案。 $Solution$一个很显然的状压$DP,f_s$表示当从初始状态到病毒状态为$s$时的最小耗时.转移考虑利用最短路 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 4000050using namespace std;struct edge&#123; int dis,to,next;&#125;e[N&lt;&lt;2];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N];int w[N],cnt,head[N],dis[N],inque[N],n,m,b1[N],b2[N],f1[N],f2[N];void spfa(int s)&#123; memset(dis,0x3f,sizeof(dis)); dis[s]=0; queue&lt;int&gt;q;q.push(s); while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=1;i&lt;=m;++i)&#123; if ((u&amp;b1[i])==b1[i]&amp;&amp;(u&amp;b2[i])==0)&#123; int v=u&amp;(((1&lt;&lt;n)-1)^f1[i])|f2[i]; if (dis[v]&gt;dis[u]+w[i])&#123; dis[v]=dis[u]+w[i]; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; &#125;&#125;signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=m;++i)&#123; w[i]=read(); scanf("%s",s+1); for (int j=1;j&lt;=n;++j)&#123; if (s[j]=='+') b1[i]|=(1&lt;&lt;j-1); if (s[j]=='-') b2[i]|=(1&lt;&lt;j-1); &#125; scanf("%s",s+1); for (int j=1;j&lt;=n;++j)&#123; if (s[j]=='-') f1[i]|=(1&lt;&lt;j-1); if (s[j]=='+') f2[i]|=(1&lt;&lt;j-1); &#125; &#125; spfa((1&lt;&lt;n)-1); printf("%d\n",dis[0]&gt;=inf?0:dis[0]); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>网络流$24$题</tag>
        <tag>状压$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3556 【[POI2013]MOR-Tales of seafaring】]]></title>
    <url>%2F2019%2F06%2F30%2F%E9%A2%98%E8%A7%A3%20P3556%20%E3%80%90%5BPOI2013%5DMOR-Tales%20of%20seafaring%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给$n$个点$m$条边无向图，每次询问两个点之间是否有长度为$d$的路径（不一定是简单路径） $Solution$设这两个点分别为$x,y$ 如果$x,y$之间有一条奇偶性与$d$相同且长度$\leqslant d$的路径，那么结果就是$TAK,$否则则是$NIE.$ 证明$:$对于一条边$(a,b)$,可以花费$2$的长度,从$a$到$b$，再从$b$到$a$.那么对于一条长度$\leqslant d$且奇偶性与$d$相同的路径, 我们可以在一条边上反复横跳以能够刚好以$d$的长度到达终点。 由于边权为$1,$所以求最短路可以用$bfs$ $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 100057using namespace std;struct edge&#123; int to,next;&#125;e[N];struct node&#123; int y,d,id;&#125;;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,m,Q,dis[N],cnt,head[N];bool ans[1050596];vector&lt;node&gt;v[N];inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].next=head[v]; head[v]=cnt;&#125;void bfs(int s)&#123; queue&lt;int&gt;q; q.push(s); for (int i=1;i&lt;=n+n;++i)dis[i]=0; while (!q.empty())&#123; int u=q.front();q.pop(); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (dis[v])continue; dis[v]=dis[u]+1; q.push(v); &#125; &#125; for (int i=0;i&lt;v[s].size();++i)&#123; node p=v[s][i]; int t=dis[p.y+(p.d&amp;1)*n]; ans[p.id]=(t&lt;=p.d&amp;&amp;t&amp;&amp;((t&amp;1)==(p.d&amp;1))); &#125;&#125;signed main()&#123; n=read(),m=read(),Q=read(); for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); add(u+n,v);add(u,v+n); &#125; for (int i=1;i&lt;=Q;++i)&#123; int x=read(),y=read(),d=read(); v[x].push_back((node)&#123;y,d,i&#125;); &#125; for (int i=1;i&lt;=n;++i) bfs(i); for (int i=1;i&lt;=Q;++i) puts(ans[i]?"TAK":"NIE"); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>$bfs$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2429 【制杖题】]]></title>
    <url>%2F2019%2F06%2F30%2F%E9%A2%98%E8%A7%A3%20P2429%20%E3%80%90%E5%88%B6%E6%9D%96%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$求不大于$m$的、 质因数集与给定质数集有交集的自然数之和。 $Solution$考虑容斥。统计所有$a_i$的倍数，然后减去两两之间的乘积，再加上三个之间的乘积$\cdots,$这个过程可以用状压实现。 对于当前状态$s,$根据$s$中$1$的个数确定状态$s$对答案的贡献是加还是减。然后计算一个$res$表示$s$中所有$1$位置上$a_i$的乘积。将答案$+/-$上$\sum\limits_{i=1}^{m/res}i\times res,z$这个式子可以化简为$$\frac{(m/res)\times(m\times res+1)}{2}\times res$$ $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define re register#define N 200057#define mod 376544743#define inv2 188272372using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int w[N],ans;signed main()&#123; int n=read(),m=read(); for (int i=1;i&lt;=n;++i)w[i]=read(); if (n*m&lt;=1e7)&#123; for (int i=1;i&lt;=m;++i)&#123; int flag=0; for (int j=1;j&lt;=n;++j) if (i%w[j]==0)&#123; flag=1; break; &#125; if (flag)ans=(ans+i)%mod; &#125; printf("%d\n",ans); return 0; &#125; for (int s=1;s&lt;(1&lt;&lt;n);++s)&#123; int res=1,cnt=0; for (int j=1;j&lt;=n;++j) if (s&amp;(1&lt;&lt;(j-1))) res*=w[j],++cnt; int t=m/res; if (cnt&amp;1)ans=(ans+res*t%mod*(t+1)%mod*inv2%mod)%mod; else ans=(ans-res*t%mod*(t+1)%mod*inv2%mod)%mod; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>容斥</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3953 【逛公园】]]></title>
    <url>%2F2019%2F06%2F30%2F%E9%A2%98%E8%A7%A3%20P3953%20%E3%80%90%E9%80%9B%E5%85%AC%E5%9B%AD%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$设$d$为$1\sim n$号点的最短路，问有多少长度不超过$d+K$的$1\sim n$路线。 $Solution$设$dis1_{a.\,b}$为$a$到$b$的最短路，$dis_{a,b}$为$a$到$b$的路线 设$f[u][j]$为$dis[u][n]\leqslant dis1[u][n]+j$的方案数，这里把$j$称为“多余的路” 答案就是$f[1][K]$ 考虑一条边$(u,v,w)$ 走这条边的话，$(dis1[v][n]+w-dis1[u][n])$即是多余的路，当前的$f[u][j]$可以被$f[v]j-(dis1[v][n]+w-dis1[u][n])&lt;=K)$更新 以上可以用跑一边反图，然后记忆化搜索实现 那么对于有$0$环这种情况怎么办呢，记一个$vis$数组，如果当前的$(u,k)$已经访问过了$($即$vis[u][k]==1)$,则直接返回$-1$即可 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define re register#define N 600000using namespace std;struct edge&#123; int u,to,dis,next;&#125;e[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,m,k,cnt,head[N],ans[10],tot,vis[100007][56],dis[N],inque[N],f[100007][56],mod,u[N],v[N],w[N];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].u=u; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt;&#125;void spfa(int s)&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (dis[v]&gt;dis[u]+e[i].dis)&#123; dis[v]=dis[u]+e[i].dis; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125;&#125;int dfs(int u,int k)&#123; if (vis[u][k])return -1; if (f[u][k])return f[u][k]; int t,w;vis[u][k]=1; if (u==n)f[u][k]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if ((t=(k-(dis[v]+e[i].dis-dis[u])))&gt;=0)&#123; if ((w=dfs(v,t))==-1)return f[u][k]=-1; f[u][k]=(f[u][k]+w)%mod; &#125; &#125; vis[u][k]=0; return f[u][k];&#125;signed main()&#123; int T=read(); while (T--)&#123; memset(f,0,sizeof(f));memset(vis,0,sizeof(vis)); n=read(),m=read(),k=read(),mod=read(); memset(head,0,sizeof(head));cnt=0; for (int i=1;i&lt;=m;++i)&#123; u[i]=read(),v[i]=read(),w[i]=read(); add(v[i],u[i],w[i]); &#125; spfa(n); memset(head,0,sizeof(head));cnt=0; for (int i=1;i&lt;=m;++i) add(u[i],v[i],w[i]); ans[++tot]=dfs(1,k); &#125; for (int i=1;i&lt;=tot;++i)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3043 【[USACO12JAN]牛联盟Bovine Alliance】]]></title>
    <url>%2F2019%2F06%2F29%2F%E9%A2%98%E8%A7%A3%20P3043%20%E3%80%90%5BUSACO12JAN%5D%E7%89%9B%E8%81%94%E7%9B%9FBovine%20Alliance%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给出$n$个点$m$条边的图,每条边找一个配对的点，要求边$(u,v)$配对的点是$u$或$v,$且每个点最多只能被一条边配对，求不同方案数 $ps:$题面的翻译不太准确，上面的翻译来自讨论,并稍加补充 $Solution$先给出一组$hack$数据 12345678910input:8 61 21 32 31 42 43 4ouput:0 有好几篇题解会被$hack,$原因是没有判在一个联通块中边数大于点数的情况 我们先$dfs$找出每个联通块，并算出这个联通块中的点数$po$与边数$ed,$然后分类讨论，最后利用乘法原理乘起来 $1.po&gt;ed:$由于是联通块，所以只能是$po=ed+1$,即是一棵树。这种情况下我们在$po$个点中找$ed$个点去匹配，无论怎么选都是合法的，所以贡献即是$C_{po}^{ed}=C_{po}^{po-1}=po$ $2.po==ed:$即一个环的情况，只有顺时针选和逆时针选两种情况，所以贡献即是$2$ $3.po&lt;ed:$这种情况下无论怎么选都不合法，所以贡献为$0$ $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define mod 1000000007#define N 200700using namespace std;struct edge&#123; int to,next; &#125;e[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt,head[N],vis[N],po,ed,ans=1;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u)&#123; vis[u]=1; ++po; for (int i=head[u];i;i=e[i].next,++ed)&#123; int v=e[i].to; if (!vis[v]) dfs(v); &#125;&#125;signed main()&#123; int n=read(),m=read(); for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; for (int i=1;i&lt;=n;++i) if (!vis[i])&#123; po=ed=0; dfs(i); ed/=2; if (po&gt;ed)ans=ans*po%mod; if (po==ed)ans=ans*2%mod; if (po&lt;ed)ans=0; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>分类讨论</tag>
        <tag>$dfs$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2757 【[国家集训队]等差子序列】&& CF452F Permutation]]></title>
    <url>%2F2019%2F06%2F20%2F%E9%A2%98%E8%A7%A3%20P2757%20%E3%80%90%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E7%AD%89%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%91%26%26%20CF452F%20Permutation%2F</url>
    <content type="text"><![CDATA[$Description$给你一个$1$到$n$的排列，你需要判断该排列内部是否存在一个$3$个元素的子序列(可以不连续)，使得这个子序列是等差序列。 $Solution$思路一$:bitset$优化暴力枚举中间的数$,$判断一下这个数的对称的两侧$,$如果一侧的数出现了但是另一侧的没出现。那么一定存在一个可行方案 思路二$:$线段树维护$hash$值从左到右，设当前数$w_j$为中间那一个,那么有以下两种情况 显然对于$l\sim j$与$r\sim j$如果有一位不相等（也就是它们的值不相等）那么就成立，因为一个在前面出现过了，另一个在后面还没出现过。 如上图中我们假设$c_a,c_b$不相等$($设$c_a=1,c_b=0)$,那么$a$在$w_j$之前就出现过$($即原序列中在$w_j$前$),$而$b$在$w_j$之后出现$($即原序列中在$w_j$后$)$。 $Code$$bitset$优化暴力 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 560000using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,a[N];bool check()&#123; bitset&lt;10060&gt;b,c;b.reset(); for (int i=1;i&lt;=n;++i)c.set(i); for (int i=1;i&lt;=n;++i)&#123; b.set(a[i]);c.reset(n-a[i]+1); if (((b&gt;&gt;(a[i]+1))&amp;(c&gt;&gt;(n-a[i]+1+1))).any())&#123; return 1; &#125; &#125; return 0;&#125;signed main()&#123; int T=read(); while (T--)&#123; n=read(); for (int i=1;i&lt;=n;++i)a[i]=read(); if (check())&#123;puts("Y");continue;&#125; reverse(a+1,a+1+n); if (check())puts("Y"); else puts("N"); &#125; return 0;&#125; 线段树维护$hash$值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define re register#define N 1200000#define base 131#define mod 998244353#define ls(k) (k&lt;&lt;1)#define rs(k) (k&lt;&lt;1|1)#define pushup(k) a[k]=a[ls(k)]+a[rs(k)],b[k]=b[rs(k)]+b[ls(k)]using namespace std;int po[N];struct node&#123; int val,len; inline void init()&#123;val=0,len=0;&#125;; friend node operator +(node a,node b)&#123; return (node)&#123;(a.val*po[b.len]%mod+b.val)%mod,a.len+b.len&#125;; &#125;&#125;a[N],b[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;void build(int k,int l,int r)&#123; if (l==r)&#123; a[k]=b[k]=(node)&#123;0,1&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; build(ls(k),l,mid); build(rs(k),mid+1,r); pushup(k);&#125;void change(int k,int l,int r,int x)&#123; if (l==r)&#123; a[k]=b[k]=(node)&#123;1,1&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; if (x&lt;=mid)change(ls(k),l,mid,x); else change(rs(k),mid+1,r,x); pushup(k);&#125;node query1(int k,int l,int r,int x,int y)&#123; if (x&lt;=l&amp;&amp;r&lt;=y) return a[k]; int mid=(l+r)&gt;&gt;1;node res;res.init(); if (x&lt;=mid)res=res+query1(ls(k),l,mid,x,y); if (mid&lt;y) res=res+query1(rs(k),mid+1,r,x,y); return res;&#125;node query2(int k,int l,int r,int x,int y)&#123; if (x&lt;=l&amp;&amp;r&lt;=y) return b[k]; int mid=(l+r)&gt;&gt;1;node res;res.init(); if (mid&lt;y) res=res+query2(rs(k),mid+1,r,x,y); if (x&lt;=mid)res=res+query2(ls(k),l,mid,x,y); return res;&#125;signed main()&#123; po[0]=1; int n=read(),flag=0; for (int i=1;i&lt;=n;++i)po[i]=po[i-1]*base%mod; build(1,1,n); for (int i=1;i&lt;=n;++i)&#123; int x=read(); if (flag)continue; change(1,1,n,x); int len=min(x-1,n-x); if (len&lt;=0)continue; if (query1(1,1,n,x-len,x-1).val!=query2(1,1,n,x+1,x+len).val)&#123;flag=1;continue;&#125; &#125; puts(flag?"YES":"NO"); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>$bitset$</tag>
        <tag>$hash$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1175E 【Minimal Segment Cover】]]></title>
    <url>%2F2019%2F06%2F20%2F%E9%A2%98%E8%A7%A3%20CF1175E%20%E3%80%90Minimal%20Segment%20Cover%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给出$n$个形如$[l,r]$的线段。$m$次询问，每次询问区间$[x,y],$问至少选出几条线段，使得区间$[x,y]$的任何一个部位都被至少一条线段覆盖。 $Solution$考虑贪心，首先设询问区间为$[x,y],$你选的所有$[l,r]$中最左边的一个$l$必然$\leqslant x($有且仅有一个$),$所以对于这个区间，它对答案的贡献取决于它的$r,$所以我们希望它在满足$l\leqslant x$的情况下$~r$更大，那么取完第一个这个问题就变成了一个$[r+1,y]$的子问题了，直到选取的$r\geqslant y$为止。 但是这个复杂度是$O(nm),$考虑倍增，每次向右跳$2^i$条线段，那么复杂度就变成$O(n~log~m)$了。 $Code$1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define re register#define N 560000using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,m,to[N],f[N][22],mx;signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=n;++i)&#123; int x=read(),y=read(); to[x]=max(to[x],y); mx=max(mx,y); &#125; for (int i=0;i&lt;=mx;++i)f[i][0]=to[i]=max(to[i],to[i-1]); for (int j=1;j&lt;=20;++j) for (int i=0;i&lt;=mx;++i) f[i][j]=f[f[i][j-1]][j-1]; while (m--)&#123; int x=read(),y=read(),ans=0; for (int i=20;i&gt;=0;--i)&#123; if (f[x][i]&lt;y&amp;&amp;f[x][i]&gt;x) x=f[x][i],ans+=(1&lt;&lt;i); &#125; if (to[x]&gt;=y)printf("%d\n",ans+1); else puts("-1"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3582 【[POI2015]KIN】]]></title>
    <url>%2F2019%2F06%2F15%2F%E9%A2%98%E8%A7%A3%20P3582%20%E3%80%90%5BPOI2015%5DKIN%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$共有$m$部电影，编号为$1\sim m$，第$i$部电影的好看值为$w_{i}$。在$n$天之中(从$1\sim n$编号）每天会放映一部电影，第$i$天放映的是第$~f_{i}~$部。你可以选择$l,r(1\leqslant l\leqslant r\leqslant n)$，并观看第$l,l+1,\cdots,r$天内所有的电影。如果同一部电影你观看多于一次，你会感到无聊，于是无法获得这部电影的好看值。所以你希望最大化观看且仅观看过一次的电影的好看值的总和。 $Solution$枚举右端点$r$，维护一个序列$c,$其中$c_l$表示$l\sim r$的好看值。对于一个位置$i$的好看值$w_i$，把他上一次出现的位置记做$pre_{i}$。由于如果有一个好看值$w_i$出现两次及以上，那么$w_i$的贡献为$0$,只有出现一次时才有贡献，显然只有在$pre_i+1\sim i$才会出现一次，所以当前$r$枚举到$i,c_{pre_i+1}\sim c_{i}+=w_i,$另外， 对于一个$~i~,pre_{pre_{i}}+1\sim pre_{i}$在上一个$j(w_{j}==w_{i})$时加上了一个$w_i$,但是对于$i,pre_{pre_{i}}+1\sim pre_{i}$区间中$w_i$的贡献为$0$,所以还有减去 这些操作考虑用线段树维护 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define re register#define M 4000600#define N 1000600#define ls(k) (k&lt;&lt;1)#define rs(k) (k&lt;&lt;1|1)using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ans,mx[M],tag[M],n,m,a[N],ma[N],pre[N],w[N];inline void pushup(int k)&#123; mx[k]=max(mx[ls(k)],mx[rs(k)]);&#125;inline void add(int k,int d)&#123; tag[k]+=d; mx[k]+=d;&#125;void pushdown(int k)&#123; add(ls(k),tag[k]);add(rs(k),tag[k]); tag[k]=0;&#125;void change(int k,int l,int r,int x,int y,int d)&#123; if (x&lt;=l&amp;&amp;r&lt;=y)&#123; add(k,d); return; &#125; int mid=l+r&gt;&gt;1; if (tag[k])pushdown(k); if (x&lt;=mid)change(ls(k),l,mid,x,y,d); if (mid&lt;y) change(rs(k),mid+1,r,x,y,d); pushup(k);&#125;int query(int k,int l,int r,int x,int y)&#123; if (x&lt;=l&amp;&amp;r&lt;=y) return mx[k]; int mid=l+r&gt;&gt;1,res=0; if (tag[k])pushdown(k); if (x&lt;=mid)res=max(res,query(ls(k),l,mid,x,y)); if (mid&lt;y) res=max(res,query(rs(k),mid+1,r,x,y)); return res;&#125;signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=n;++i)a[i]=read(); for (int i=1;i&lt;=m;++i)w[i]=read(); for (int i=1;i&lt;=n;++i) pre[i]=ma[a[i]],ma[a[i]]=i; for (int i=1;i&lt;=n;++i)&#123; change(1,1,n,pre[i]+1,i,w[a[i]]); if (pre[i])change(1,1,n,pre[pre[i]]+1,pre[i],-w[a[i]]); ans=max(ans,query(1,1,n,1,i)); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1019D 【Large Triangle】]]></title>
    <url>%2F2019%2F06%2F13%2F%E9%A2%98%E8%A7%A3%20CF1019D%20%E3%80%90Large%20Triangle%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给出$N$个点，是否存在$3$个点，它们组成的三角形面积为$S$。 $Solution$如果确定了三角形的一条边，我们可以将整个坐标系旋转一下，使这条边成为新的$y$轴，这时候我们只要分别对$y$轴的两边分别进行二分即可 我们发现：可以先预处理一下每两个点之间的直线，记录一下起点终点和斜率。 首先所有点按$x$坐标从小到大排序。然后对直线进行极角排序。 当我们处理到直线$AB$时,$AB$就成为了$y$轴，且$A,B$是相邻的(它们距离$y$轴距离都为$0)($假设$A$位置在$B$的上面）.然后到下一条直线时，由于斜率从小到大，所以是把整个图顺时针旋转了一点点，直到下一条直线成为$y$轴。那么这个时候把$A,B$在序列中的位置交换一下就行了。因为如果有别的点对相对顺序改变，那么这个点对的斜率一定介于这两条直线之间。下面口胡一下。 假设现在我们以$l_1$为$y$轴。有一组点对，$P$和$Q$，它们相对于$l_1$的横坐标分别是$a$和$b$，其中$a&lt;b$。 然后我们看到比$l_1$斜率更小的第一条直线$l_2$。首先，可以保证，$A$和$B$一定在直线$l_2$的同侧。因为如果$A$和$B$在$l_2$的异侧，那$ABCD$这四个点一定可以生成一条斜率介于$l_1$和$l_2$之间的直线(画一画就知道了)，而我们是把斜率排了序，保证了不会有这种情况出现。现在，将整个图再顺时针旋转一点点，使$l_2$成为新的y轴。那么可以保证，$A$和$B$的相对顺序一定是改变了的，而且是把$A$和$B$的排位交换了一下。(可以脑补一下$AB$在$CD$下侧的情况，是同理的).这时候，我们看到$PQ$，在新的y轴下，$P$的横坐标是$c,Q$的横坐标是$d$，假设$c&gt;d$，那么$PQ$的斜率一定比$l_2$的斜率要大，因为$PQ$逆时针旋转一点点就与$l_2$平行。 对于旋转过后排位会变化的点对(除$AB$外)，一定会满足$PQ$的条件$:a&lt;b$且$c&gt;d$。但是我们发现它的斜率介于$l_1$和$l_2$之间，然鹅比$l_1$斜率更小的第一条直线是$l_2$，不是$PQ$，与前提矛盾，所以不存在这样的$PQ$。 那么就可以保证从$l_1$旋转到$l_2$时，受影响的就只有$l_1$上的两个点。 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define re register#define N 40000#define M 4000500#define eps 1e-4using namespace std;struct point&#123; int x,y; friend point operator -(point a,point b)&#123; return (point)&#123;a.x-b.x,a.y-b.y&#125;; &#125; friend int operator ^(point a,point b)&#123; return abs(a.x*b.y-b.x*a.y); &#125;&#125;p[N];struct node&#123; int u,v; double d;&#125;a[M];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline bool cmp(point a,point b)&#123; if (a.x!=b.x)return a.x&lt;b.x; return a.y&lt;b.y;&#125;inline bool cmp1(node a,node b)&#123; return a.d&lt;b.d;&#125;inline int area(point a,point b,point c)&#123; return abs(((b-a)^(c-a)));&#125;int n,id[N],pos[N],tot,S;signed main()&#123; n=read();S=read()*2; for (int i=1;i&lt;=n;++i)p[i].x=read(),p[i].y=read(),id[i]=pos[i]=i; sort(p+1,p+1+n,cmp); for (int i=1;i&lt;=n;++i) for (int j=1+i;j&lt;=n;++j) a[++tot]=(node)&#123;i,j,atan2((double)(p[j]-p[i]).y,(double)(p[j]-p[i]).x)&#125;; sort(a+1,a+1+tot,cmp1); for (int i=1;i&lt;=tot;++i)&#123; int x=a[i].u,y=a[i].v; if (pos[x]&gt;pos[y])swap(x,y); int l=1,r=pos[x]-1,ans=0; while (l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if (area(p[id[mid]],p[x],p[y])&gt;=S)ans=mid,l=mid+1; else r=mid-1; &#125; if (area(p[id[ans]],p[x],p[y])==S)&#123; puts("Yes"); printf("%lld %lld\n%lld %lld\n%lld %lld\n",p[id[ans]].x,p[id[ans]].y,p[x].x,p[x].y,p[y].x,p[y].y); return 0; &#125; l=pos[y]+1,r=n,ans=0; while (l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if (area(p[id[mid]],p[x],p[y])&gt;=S)ans=mid,r=mid-1; else l=mid+1; &#125; if (area(p[id[ans]],p[x],p[y])==S)&#123; puts("Yes"); printf("%lld %lld\n%lld %lld\n%lld %lld\n",p[id[ans]].x,p[id[ans]].y,p[x].x,p[x].y,p[y].x,p[y].y); return 0; &#125; swap(pos[x],pos[y]); swap(id[pos[x]],id[pos[y]]); &#125; puts("No"); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>极角排序</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3476 【[POI2008]TRO-Triangles】]]></title>
    <url>%2F2019%2F06%2F13%2F%E9%A2%98%E8%A7%A3%20P3476%20%E3%80%90%5BPOI2008%5DTRO-Triangles%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给定平面上的一些点，求这些点能组成的所有三角形的面积之和 $Solution$以下向量的叉积运算用$\;\,\hat{}\;\,$符号表示 $\sum S_{\triangle}$为$\sum\limits_{i&lt;j&lt;k}|(\vec{j}-\vec{i})~\hat{}~(\vec{k}-\vec{i})|$ 我们先枚举$i$,并求出其他每个点以$i$为原点的坐标 这样对于每个点$~i~$要求的就变成了$\sum\limits_{i&lt;j&lt;k}\left|\vec{j}\;\,\hat{}\;\,\vec{k}\right|$，我们发现有个绝对值很难处理，于是我们想让绝对值中间的叉积运算为正。 $\vec{i}\;\,\hat{}\;\,\vec{j}$只有当$~\vec{i}~$在$~\vec{j}$逆时针方向是才会是正的，所以我们在枚举$~i~$后对所有的的向量进行极角排序，原式的绝对值就消去了。 这样原式就变成了$\sum\limits_{i&lt;j&lt;k}(\vec{j}\;\,\hat{}\;\,\vec{k})$ 再把叉积化成一般形式$:\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}\sum\limits_{k=j+1}^{n}(x_{j}\times y_{k}-y_{j}\times x_{k} )$ $\qquad\qquad\qquad\quad\;\;\,=\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}(x_{j}\times \sum\limits_{k=j+1}^{n} y_{k}-y_{j}\times\sum\limits_{k=j+1}^{n} x_{k} )$ 发现可以用后缀和维护 复杂度$O(n^2logn)$ $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 200900#define sqr(x) ((x)*(x))#define eps 1e-6using namespace std;struct point&#123; int x,y; friend point operator -(point a,point b)&#123; return (point)&#123;b.x-a.x,b.y-a.y&#125;; &#125; friend int operator ^(point a,point b)&#123; return a.x*b.y-a.y*b.x; &#125;&#125;p[N],q[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline bool cmp(point a,point b)&#123; return (a^b)&gt;0;&#125;inline bool cmp1(point a,point b)&#123; if (a.x!=b.x)return a.x&lt;b.x; return a.y&lt;b.y;&#125;int ans;signed main()&#123; int n=read(); for (int i=1;i&lt;=n;++i)p[i].x=read(),p[i].y=read(); sort(p+1,p+1+n,cmp1); for (int i=1;i&lt;=n;++i)&#123; int tot=0; for (int j=i+1;j&lt;=n;++j)q[++tot]=p[j]-p[i]; sort(q+1,q+1+tot,cmp); int sum1=0,sum2=0; for (int j=tot;j;--j)&#123; sum1+=q[j].x,sum2+=q[j].y; ans+=q[j].x*sum2-q[j].y*sum1; &#125; &#125; printf("%lld.%d\n",ans&gt;&gt;1,(ans&amp;1)*5);; return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>极角排序</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5400 【[CTS2019]随机立方体】]]></title>
    <url>%2F2019%2F06%2F12%2F%E9%A2%98%E8%A7%A3%20P5400%20%E3%80%90%5BCTS2019%5D%E9%9A%8F%E6%9C%BA%E7%AB%8B%E6%96%B9%E4%BD%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有一个$n\times m\times l$的立方体，立方体中每个格子上都有一个数，如果某个格子上的数比三维坐标至少有一维相同的其他格子上的数都要大的话，我们就称它是极大的。 现在将$1\sim n\times m\times l$这$n\times m\times l$个数等概率随机填入$n\times m\times l$个格子（即任意数字出现在任意格子上的概率均相等），使得每个数恰出现一次，求恰有$k$个极大的数的概率。答案对$998244353$取模。 $Solution$考虑容斥 以下把$n\times m\times l$的立方体中$1\times 1\times 1$的单位立方体称为’块‘ 设$N=n\times m\times l$ 设$f_{i}$表示至少有$i$个极大的数的方案数 $b_{i}~$表示选出$i~$个三维坐标都不相同的点的方案数。($i~$个极大的数) $g_{i}~$表示和$i~$个极大的数中任意一个至少有一维坐标相同的点的个数。 $h_{i}~$表示将$g_{i}~$个数字分配给$g_{i}$的个点的合法分配的方案数。(合法指的是$i~$个极大的数可以同时存在) $f_{i}=C_{N}^{g_{i}} \times b_{i} \times h_{i} \times(N-g_{i}) !$ 我们先来考虑$b_{i}~:$ 如果在$(a,b,c)$钦定了一个极大数，那么$x=a,y=b,z=c$三个平面都不能填极大数了，即原问题变成了一个$(n-1)\times(m-1)\times(l-1)$ 所以$:$ $b_{i}=\dfrac{1}{i!}~\prod\limits_{j=0}^{i-1}(n-j) \times(m-j) \times(l-j)$ 考虑$g_{i}:$ 显然$:g_{i}=N-(n-i) \times(m-i) \times(l-i)($所有块减去所有三维坐标与$i$个极大的数完全不相同的块的个数$)$ 考虑$h_{i}$怎么算： 可以发现，这个东西一下子求不来，可以考虑一下递推的方法。 我们先把$g_{i}$个数中最大的数值(这个最大的数值一定是极大数)拿出来，填到对应位置，然后剩下的$g_{i}-g_{i-1}-1$个位置(即这个数值会影响到的所有的块，$g_{i-1}$即不会影响到的块,$-1$即减去自身)，每个位置可以随便选择一个数，方案数为$(g_{i}-g_{i-1}-1)!=\frac{(g_{i}-1)!}{g_{i-1}!}$，然后我们可以发现，剩下的数的填充就是子问题$h_{i-1}$ $h_{i}=\frac{\left(g_{i}-1\right) !}{g_{i-1} !} \times h_{i-1}$ $\quad\,=\prod_{j=0}^{i-1} \frac{\left(g_{j+1}-1\right) !}{g_{j} !} $ 注意$:$这个式子是不考虑大小顺序的，所以最后所有的$h_{i}$都要乘上$i!$(注意$:$不能在算的时候乘，会影响后面$h_{i}~$的计算的) 将所有的东西带回去 $f_{i}~=C_{N}^{g_{i}} \times b_{i} \times h_{i} \times(N-g_{i})!$ $\quad\,\,=\frac{N!}{(N-g_{i}) ! g_{i} !} \times b_{i} \times i!\times \prod_{j=1}^{i} \frac{(g_{j}-1)!}{g_{j-1} !} \times(N-g_{i}) !$ 我们发现最后算概率的时候要乘上$\frac{1}{N!}$ $f_{i}~=\frac{i!}{g_{i}!} \times b_{i} \times \prod_{j=1}^{i} \frac{(g_{j}-1) !}{g_{j-1}!}$ $\quad\,\,=i! \times b_{i}\times \prod_{j=1}^{i} \frac{(g_{j}-1) !}{g_{j}!}$ $\quad\,\,=i! \times b_{i} \prod_{j=1}^{i} \frac{1}{g_{j}}$ 由于 $f_{i}=\sum\limits_{j=i}^{min (n, m, l)} ans_{j}C_{j}^{i}$ 最后二项式反演一下有： $ans_{i}=\sum\limits_{i=k}^{\min (n, m, l)}\times (-1)^{i-k}\times C_{i}^{k}\times f_{i}$但这样只能得到$80$分 ，我们预处理出来$g_{i}$的前缀积，求最后一项的逆元后可以逆推每一个前缀积的逆元，如当前$1\sim i$的前缀积的逆元为$inv$,那么想得到$1\sim (i-1)$的前缀积，只需将$inv\times i$即可 以下内容为二项式反演证明$:$ $g_{i}=\sum\limits_{j=1}^{i}C_i^j f_{j}$ $f_{i}=\sum\limits_{j=1}^{i}(-1)^{i-j}~ C_{i}^{j}~g_{j}$ 证明等式成立相当于证明对于等式右边而言，所有$f_{k}$的系数为$[i==k]$ 则$f_{k}$的系数为$\sum\limits_{j=k}^{i}(-1)^{i-j}~C_{i}^{j}~C_{j}^{k}$ 化简: $\sum\limits_{j=k}^{i}(-1)^{i-j} \frac{i !}{j !(i-j) !} \frac{j !}{k !(j-k) !}$ 消去$j!$,提出$\frac{i !}{k !}$ $\left(\sum\limits_{j=k}^{i}(-1)^{i-j} \frac{1}{(i-j) !(j-k) !}\right) \frac{i !}{k !}$ 乘$(i-k)!$，除$(i-k)!$ $\left(\sum\limits_{j=k}^{i}(-1)^{i-j} \frac{(i-k) !}{(i-j) !(j-k) !}\right) \frac{i !}{k !(i-k) !}$ $\left(\sum_{j=k}^{i}(-1)^{i-j}~C_{i-k}^{j-k}\right)C_{i}^{k}.$ $\sum\limits_{j=k}^{i}(-1)^{i-j}~C_{i-k}^{j-k}=[i==k]$ 如果成立,则$:$当$i==k$时，$C_{i}^{k}==1$,所以系数为$1$,当$i!=k$时，前一个式子为$0$，所以系数为$0$ 证明$:$当$i!=k$时，前一个式子为$0$ 当$i-k$为奇数时，相当于有$i−k+1$个数相加(分别对应取$0$个，取$1$个…取$i - k$个)，一共偶数个，其中第一项与最后一项异号，第二项与倒数第二项异号。。。根据组合数的对称性，和为$0$。 当$i-k$为偶数时，相当于证$:$ $C_{i}^{0}-C_{i}^{1}+C_{i}^{2}-\cdots -C_{i}^{i-1}+C_{i}^{i}=0$ 用杨辉三角证明(好像二项式定理也可以证) 原式$=C_{i-1}^{0}-(C_{i-1}^{0}+C_{i-1}^{1})+(C_{i-1}^{1}+C_{i-1}^{2})-\cdots-(C_{i-1}^{i-2}+C_{i-1}^{i-1})+C_{i-1}^{i-1}$ 发现最后全抵消掉了，所有原式$=0$ $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define mod 998244353#define N 5000070using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ksm(int x,int p)&#123; int res=1; while (p)&#123; if (p&amp;1)res=res*x%mod; x=x*x%mod;p&gt;&gt;=1; &#125; return res;&#125;int jc[N],invc[N],inv[N],g[N],f[N];inline int C(int m,int n)&#123; return jc[m]*invc[n]%mod*invc[m-n]%mod;&#125;signed main()&#123; int T=read();jc[0]=1; for (int i=1;i&lt;=N-70;++i)jc[i]=jc[i-1]*i%mod; invc[N-70]=ksm(jc[N-70],mod-2); for (int i=N-71;i&gt;=0;--i) invc[i]=invc[i+1]*(i+1)%mod; while (T--)&#123; int n=read(),m=read(),l=read(),k=read(),ans=0,v=1; int t=min(n,min(m,l)); if (k&gt;t)&#123;puts("0");continue;&#125; for (int i=1;i&lt;=t;++i)&#123; g[i]=(n*m%mod*l%mod-(n-i)*(m-i)%mod*(l-i)%mod+mod)%mod; v=v*g[i]%mod; &#125; inv[t]=ksm(v,mod-2); for (int i=t-1;i&gt;=0;--i)&#123; inv[i]=inv[i+1]*g[i+1]%mod; &#125; v=1; for (int i=0;i&lt;t;++i)&#123; v=v*(n-i)%mod*(m-i)%mod*(l-i)%mod; f[i+1]=v*inv[i+1]%mod; &#125; for (int i=k;i&lt;=t;++i)&#123; if ((i-k)&amp;1) ans=(ans-C(i,k)*f[i]%mod+mod)%mod; else ans=(ans+C(i,k)*f[i]%mod)%mod; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>容斥</tag>
        <tag>组合数</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1132E 【Knapsack】]]></title>
    <url>%2F2019%2F06%2F11%2F%E9%A2%98%E8%A7%A3%20CF1132E%20%E3%80%90Knapsack%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$你有一个容量为$W$的背包，和$8$种物品，重量分别为$1\sim 8$的整数，分别有$cnt_1,cnt_2\cdots cnt_8$ 个。求背包中最多能装上多大的重量。 $Solution$由于$W$很大，我们首先可以选出一些肯定会放在最终背包里面的物品，我们假设把背包分成很多个容量为$840$的背包，我们可以知道的是，每种物品都可以单独装满这个背包，因为$840$是$1\sim 8$的最小公倍数，之后我们只要把所有能凑成的$840$的物品丢进最终的答案，最后每种物品剩余的个数肯定是$&lt;840$的，最后这些物品的总重量是小于$840\times8$的，我们只需要用一个容量为$840\times8$的背包对剩下的这些物品进行背包就可以了。 若要对第$i$种物品选$c_i$个，那么把$c_i$分解成$\frac{L}{i}\times p_i+q_i(0\leqslant q_i &lt;\frac{L}{i})$ 具体实现时把最后剩下的物品当作容量，把$p_i$当成价值 最后统计取$max$ $Code$12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 600600using namespace std;const int L=840,n=8;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int c[N],f[10][N],ans;signed main()&#123; int W=read(),res=0; for (int i=1;i&lt;=n;++i)&#123; c[i]=read(); res+=c[i]*i; &#125; if (res&lt;=W)&#123;printf("%lld\n",res);return 0;&#125; memset(f,-1,sizeof(f)); f[0][0]=0; for (int i=1;i&lt;=n;++i)&#123; int mx=min(c[i],L/i); for (int j=0;j&lt;=L*n;++j) if (f[i-1][j]!=-1) for (int k=0;k&lt;=mx;++k) f[i][j+k*i]=max(f[i][j+k*i],f[i-1][j]+(c[i]-k)/(L/i)); &#125; int ans=0; for (int i=0;i&lt;=min(W,L*n);++i) if (f[n][i]!=-1) ans=max(ans,i+L*min(f[n][i],(W-i)/L)); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 BZOJ2238 Mst]]></title>
    <url>%2F2019%2F06%2F08%2F%E9%A2%98%E8%A7%A3%20BZOJ2238%20Mst%2F</url>
    <content type="text"><![CDATA[$Description$给出一个$N$个点$M$条边的无向带权图，以及$Q$个询问，每次询问在图中删掉一条边后图的最小生成树。(各询问间独立，每次询问不对之后的询问产生影响，即被删掉的边在下一条询问中依然存在) $Solution$我们先做好图的最小生成树。 如果删除的边不在最小生成树上，那答案就是最小生成树，直接输出即可。 此时要找能够代替删去的边的一条权值最小的边。用这条边代替删去的边后就是新的最小生成树了。 那怎么代替呢？ 我们把最小生成树的样子画个图看看 再删去一条边 是不是就变成了两个部分 我们要找的就是所有能使两个连通块连通的非树边。这样的非树边就能够代替删去的边重新使树连通。 那怎么找一条权值最小的边$?$ 现在反过来想，一条非树边可以代替哪些边$?$ 一条非树边可以代替其两端点在树上的简单路径之间的所有边 画一下图即可，如果删去边不在简单路径上，那么删去边的两端一定在同一个部分(即无法在异侧) 然后对于每条非树边，用它的值去更新它两端点构成的简单路径上的边，用树链剖分优化复杂度 先预处理出最小生成树，然后将这棵最小生成树进行树链剖分，每一条边记录能够代替它的、权值最小的非树边的长度。对于每条非树边，利用树剖更新其两端点在树上的简单路径之间的所有边记录的最小值。查询时直接查询删除的边上存储的最小值即可。 实际代码可以将边的信息存在其儿子节点上，简化代码复杂度 有两种情况要特判$Not connected:$ 原图不连通，对于所有询问都输出$Not connected($树链剖分只是维护用其它边替换一条边的情况，如果原图不连通的话，不但生成树会建错，而且替换了边树也不连通$);$ 原图连通，但删去这条边后没有边能替它连通两个块，此时树链剖分上询问这条边所得到的值应该是没更新过的初值，即$inf$。因此判断这个询问值如果是$inf$就输出$Not connected$即可。 还有一些细节代码中有注释 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define ls(k) (k&lt;&lt;1)#define rs(k) (k&lt;&lt;1|1)#define N 1000600using namespace std;struct node&#123; int u,v,d,id;&#125;p[N];struct edge&#123; int to,next;&#125;e[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,m;int f[N],vis[N],num[N];int cnt,head[N];int mn[N],tag[N];int size[N],fa[N],top[N],son[N],dep[N],id[N],a[N],tot;int find(int k)&#123; return f[k]==k?k:f[k]=find(f[k]);&#125;inline void Add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;inline bool cmp(node a,node b)&#123; return a.d&lt;b.d;&#125;inline void pushup(int k)&#123; mn[k]=min(mn[ls(k)],mn[rs(k)]); &#125;void add(int k,int d)&#123; tag[k]=min(tag[k],d); mn[k]=min(mn[k],d);&#125;void pushdown(int k)&#123; add(ls(k),tag[k]); add(rs(k),tag[k]); tag[k]=inf;&#125;void build(int k,int l,int r)&#123; tag[k]=mn[k]=inf; if (l==r) return; int mid=l+r&gt;&gt;1; build(ls(k),l,mid); build(rs(k),mid+1,r);&#125;void change(int k,int l,int r,int x,int y,int d)&#123; if (x&lt;=l&amp;&amp;r&lt;=y)&#123; add(k,d); return; &#125; int mid=l+r&gt;&gt;1; if (tag[k]!=inf)pushdown(k); if (x&lt;=mid)change(ls(k),l,mid,x,y,d); if (mid&lt;y) change(rs(k),mid+1,r,x,y,d); pushup(k);&#125;int query(int k,int l,int r,int x,int y)&#123; if (x&lt;=l&amp;&amp;r&lt;=y) return mn[k]; int mid=l+r&gt;&gt;1,res=inf; if (tag[k]!=inf)pushdown(k); if (x&lt;=mid)res=min(res,query(ls(k),l,mid,x,y)); if (mid&lt;y) res=min(res,query(rs(k),mid+1,r,x,y)); return res;&#125;int Kr()&#123; for (int i=1;i&lt;=n;++i)f[i]=i; int res=0,cnt=0; for (int i=1;i&lt;=m&amp;&amp;cnt&lt;n-1;++i)&#123; int x=find(p[i].u),y=find(p[i].v); if (x==y)continue; f[x]=y; Add(p[i].u,p[i].v); Add(p[i].v,p[i].u); ++cnt;res+=p[i].d;vis[p[i].id]=1; &#125; if (cnt!=n-1)return -1; return res;&#125;void dfs1(int u)&#123; size[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa[u])continue; dep[v]=dep[u]+1;fa[v]=u; dfs1(v); size[u]+=size[v]; if (!son[u]||size[v]&gt;size[son[u]])son[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; id[u]=++tot; a[tot]=u; if (son[u])dfs2(son[u],tp); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa[u]||v==son[u])continue; dfs2(v,v); &#125;&#125;void updata(int x,int y,int d)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]])swap(x,y); change(1,1,n,id[top[x]],id[x],d); x=fa[top[x]]; &#125; if (dep[x]&gt;dep[y])swap(x,y); change(1,1,n,id[x]+1,id[y],d);//当前的x即使原先x,y两点的lca，由于边的权值存在子节点上，所以lca是不能取的 &#125;int query1(int x,int y)&#123; int res=inf; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]])swap(x,y); res=min(res,query(1,1,n,id[top[x]],id[x])); x=fa[top[x]]; &#125; if (dep[x]&gt;dep[y])swap(x,y); return min(res,query(1,1,n,id[x]+1,id[y]));&#125;signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=m;++i)p[i].u=read(),p[i].v=read(),p[i].d=read(),p[i].id=i; int q=read(); sort(p+1,p+1+m,cmp); for (int i=1;i&lt;=m;++i)num[p[i].id]=i; int res=Kr(); if (res==-1)&#123;while (q--)&#123;puts("Not connected");&#125;return 0;&#125; dfs1(1);dfs2(1,1); build(1,1,n); for (int i=1;i&lt;=m;++i) if (!vis[p[i].id]) updata(p[i].u,p[i].v,p[i].d); while (q--)&#123; int k=read(); if (!vis[k])&#123;printf("%d\n",res);continue;&#125; int ans=query1(p[num[k]].u,p[num[k]].v); if (ans==inf)puts("Not connected"); else printf("%d\n",res-p[num[k]].d+ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1858 【多人背包】]]></title>
    <url>%2F2019%2F06%2F08%2F%E9%A2%98%E8%A7%A3%20P1858%20%E3%80%90%E5%A4%9A%E4%BA%BA%E8%83%8C%E5%8C%85%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$求$01$背包前$k$优解的价值和 $Solution$简单的背包问题。我们知道$01$背包的转移条件是$f_{j}=max(f_{j},f_{j-v_{i}}+w_{i})$，也就是说$f_{j}$只会由$f_{j}$与$f_{j-v_{i}}$转移过来，我们考虑多加一维$k$优解，那么显然，$f_{j,k}$优解依然从$f_{j,p}(1\leqslant p\leqslant k)$与$f_{j-v_{i},p}(1\leqslant p\leqslant k)$转移过来。由于$k$很小，我们只需要用$f_{j,p}$与$f_{j-v_{i},p}$暴力判断第$k$优解更新答案即可。值得注意的是，这里的背包必须装满 $Code$1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define N 60000using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int v[N],f[N][50],w[N],t[N],ans;signed main()&#123; int k=read(),V=read(),n=read(); for (int i=1;i&lt;=n;++i)v[i]=read(),w[i]=read(); for (int i=0;i&lt;=n;++i) for (int j=0;j&lt;=V;++j) f[i][j]=-inf; f[0][1]=0; for (int i=1;i&lt;=n;++i) for (int j=V;j&gt;=v[i];--j)&#123; int l1=1,l2=1,cnt=0; while (cnt&lt;=k)&#123; if (f[j][l1]&gt;f[j-v[i]][l2]+w[i]) t[++cnt]=f[j][l1++]; else t[++cnt]=f[j-v[i]][l2++]+w[i]; &#125; for (int p=1;p&lt;=k;++p)f[j][p]=t[p]; &#125; for (int i=1;i&lt;=k;++i)ans+=f[V][i]; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2045 【方格取数加强版】]]></title>
    <url>%2F2019%2F06%2F08%2F%E9%A2%98%E8%A7%A3%20P2045%20%E3%80%90%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E5%8A%A0%E5%BC%BA%E7%89%88%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给出一个$n\times n$的矩阵,每一格有一个非负整数$a_{i,j},(a_i,j\leqslant 1000)$现在从$(1,1)$出发,可以往右或者往下走,最后到达$(n,n),$每达到一格,把该格子的数取出来,该格子的数就变成$0$,这样一共走$K$次,现在要求$K$次所达到的方格的数的和最大 $Solution$源点$s$和汇点$t$分别连向$(1,1),(n,n),$容量为$k$，费用为$0$，仅表示一共可以走k次；对于方格中的每个点i，进行拆点，分别为$i_{1}~$和$i_{2}$。$i_1~$和$i_{2}~$之间连两条边，一条容量为$1$，费用为$a_{i,j}$，表示每个点的数只可以取一次；另一条容量为$\infty$，费用为$0$，仅表示可以经过无数次；对于在其下方或右边点的点，连一条容量为$\infty$，费用为$0$的边 最后跑最大费用最大流即可 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define pb push_back#define N 40000using namespace std;struct edge&#123; int to,dis,w,next;&#125;e[1007000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,head[N],dis[N],n,m,flow[N],pre[N],pri[N],rt,in[N],leaf[N],inque[N],k,vis[N],x[N],y[N],a[N],b[N],cur[N],cost,w[N],s,t;inline void add(int u,int v,int d,int w)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].w=-w; e[cnt].next=head[v]; head[v]=cnt;&#125;bool spfa()&#123; for (int i=s;i&lt;=t;++i)dis[i]=-inf; memset(flow,0x3f,sizeof(flow)); queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&lt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; pre[v]=u;pri[v]=i; flow[v]=min(flow[u],e[i].dis); if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]&gt;-inf;&#125;inline int Dinic()&#123; int res=0; while (spfa())&#123; res+=flow[t]; cost+=flow[t]*dis[t]; for (int now=t;now!=s;now=pre[now])&#123; e[pri[now]].dis-=flow[t]; e[pri[now]^1].dis+=flow[t]; &#125; &#125; return res;&#125;inline int id(int x,int y)&#123; return (x-1)*n+y;&#125;signed main()&#123; n=read(),k=read();s=0,m=n*n,t=m+m+1; add(s,id(1,1),k,0);add(id(n,n)+m,t,k,0); for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j)&#123; add(id(i,j),id(i,j)+m,1,read()); add(id(i,j),id(i,j)+m,inf,0); if (j!=n)add(id(i,j)+m,id(i,j+1),inf,0); if (i!=n)add(id(i,j)+m,id(i+1,j),inf,0); &#125; Dinic(); printf("%d\n",cost); return 0;&#125;]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极角排序]]></title>
    <url>%2F2019%2F06%2F08%2F%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[方法$1:$利用$atan2()$函数按极角从小到大排序。 $atan2(double~y,double~x)$其中$y$代表已知点的$Y$坐标，同理$x$ ,返回值见下图，它的值域相应的也就是$-\pi\sim \pi$了 $atan2$转换到$\left[0,2\pi\right)$表示的是与$x$轴正方向的逆时针夹角，这样转换的好处是便于计算两条线之间的夹角。 第二种转换是用于对直线进行极角排序的。 123456bool cmp(point a,point b)&#123; if(atan2(a.y,a.x)!=atan2(b.y,b.x)) return atan2(a.y,a.x)&lt;atan2(b.y,b.x); return a.x&lt;b.x;&#125;//不转换 方法$2:$利用叉积。 123friend double operator ^(Point a,Point b)&#123; return a.x*b.y-b.x*a.y;&#125; 若叉积$&gt;0$，则向量$a$在向量$b$的顺时针方向,叉积$&lt;0$，则向量$a$在向量$b$的逆时针方向12345bool cmp(point a,point b) &#123; if((a^b)==0) return a.x&lt;b.x; else return (a^b)&gt;0;&#125; 排序效果同单个$atan2()$ 方法比较一般情况下用叉积(精度高),但是$atan2()$更加灵活。]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意多边形的面积公式]]></title>
    <url>%2F2019%2F06%2F07%2F%E4%BB%BB%E6%84%8F%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前置芝士$:$向量及其的基本运算，如叉积(叉积运算下面用符号^表示)。 对于一个已知三点坐标的三角形，其面积是可以算出来的。 设点$c$为原点$(0,0)$ $S_{\Delta}=\frac{|\vec{a}|\times |\vec{b}|\times\sin (\theta)}{2}=\frac{\vec{a}~\hat{}~\vec{b}}{2}=\frac{\left|x_{1}\times y_{2}-x_{2}\times y_{1}\right|}{2}$ 对于任意多边形 $S=\frac{\left| \sum_{1}^{n-1}(x[i]\times y[i+1]-x[i+1]\times y[i])+x[n]\times y[1]-x[1]\times y[n]\right|}{2}$ $ps:$注意绝对值不要忘。 来张图 在网上并没有找到什么严格的证明，但是如果自己手玩过就会发现这样做是对的。 其中标出的$a$部分(不包括多边形本身)被重复算了两次，一次加，一次减，而多边形本身只被算了一次，符合题意。 如果点的坐标不是按顺序依次给出的又该怎么办呢？ $1.$所给多边形为凹包(或者不给说明，凸包和凹包都有可能)： 如果点不是按照顺序依次给出的，那么所构成的多边形一定不唯一（画画就明了），所以点一定是按顺序给出的 $2.$所给多边形为凸包： 我们可以先将点按极角排序，就可套用公式了,(凸包的点极角排序后多边形的顶点是依次有序的,且多边形一定是唯一的) 例题P2785 物理1（phsic1）- 磁通量 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 2000900#define sqr(x) ((x)*(x))#define eps 1e-6using namespace std;struct point&#123; double x,y; friend point operator -(point a,point b)&#123; return (point)&#123;b.x-a.x,b.y-a.y&#125;; &#125; friend double operator ^(point a,point b)&#123; return a.x*b.y-a.y*b.x; &#125;&#125;p[N],s;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline bool cmp(point a,point b)&#123; return ((a-s)^(b-s))&gt;0;&#125;double ans,b;signed main()&#123; int n=read();scanf("%lf",&amp;b); scanf("%lf%lf",&amp;p[0].x,&amp;p[0].y); for (int i=1;i&lt;n;++i)scanf("%lf%lf",&amp;p[i].x,&amp;p[i].y); for (int i=0;i&lt;n-1;++i)ans+=(p[i]^p[i+1]); ans+=p[n-1]^p[0]; printf("%.4lf\n",ans*b*0.5); return 0;&#125;]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3153 【[CQOI2009]跳舞】]]></title>
    <url>%2F2019%2F06%2F03%2F%E9%A2%98%E8%A7%A3%20P3153%20%E3%80%90%5BCQOI2009%5D%E8%B7%B3%E8%88%9E%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$一次舞会有$n$个男孩和$n$个女孩。每首曲子开始时，所有男孩和女孩恰好配成$n$对跳交谊舞。每个男孩都不会和同一个女孩跳两首（或更多）舞曲。有一些男孩女孩相互喜欢，而其他相互不喜欢（不会”单向喜欢“）。每个男孩最多只愿意和$k$个不喜欢的女孩跳舞，而每个女孩也最多只愿意和$k$个不喜欢的男孩跳舞。给出每对男孩女孩是否相互喜欢的信息，舞会最多能有几首舞曲？ $Solution$二分答案$ans$ 把每个人$i~$拆成喜欢对方$i_1~$和不喜欢对方$i_2~$两个点 从源点$s$向$i_1~$连容量为$ans$的边，表示限制$ans$支舞曲 再从$i_1~$连向$i_2~$连边，容量为$k$ 这样的话就解决了这个问题 接下来就很好办了 若男生$i$和女生$j$互相喜欢 $i_1$连向$j_1$ 若男生$i$和女生$j$互相不喜欢 $i_2$连向$j_2$ 而女生之间的连边类似于男生 （你就想，如果这个图反过来是一样的，所以怎么连边就很清晰了） 这个时候跑最大流 求出来的就是最大的匹配数 如果最大流恰好等于$ans\times n$ 也就是恰好$ans\times n$组匹配，意味着可行 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 200000#define pb push_backusing namespace std;struct edge&#123; int dis,to,next;&#125;e[1000700];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,ma[2007][2007],head[N],dep[N],inque[N],cur[N],n,k,p,s,t;char ss[N];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].next=head[v]; head[v]=cnt;&#125;bool bfs()&#123; memset(dep,0,sizeof(dep)); queue&lt;int&gt;q;q.push(s); dep[s]=1; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;!dep[v])&#123; dep[v]=dep[u]+1; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int mn)&#123; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]==dep[u]+1) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; if (used==mn)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (bfs())&#123; for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; return res;&#125;bool check(int mid)&#123; memset(head,0,sizeof(head));cnt=1; for (int i=1;i&lt;=n;++i)&#123; add(s,i,mid);add(i+n+n,t,mid);add(i,i+n,k);add(i+n*3,i+n+n,k); for (int j=1;j&lt;=n;++j) if (ma[i][j]) add(i,j+n+n,1); else add(i+n,j+n*3,1); &#125; return Dinic()==mid*n;&#125;signed main()&#123; n=read(),k=read();s=0,t=n*4+1; for (int i=1;i&lt;=n;++i)&#123; scanf("%s",ss+1); for (int j=1;j&lt;=n;++j) ma[i][j]=ss[j]=='Y'; &#125; int l=1,r=3000,ans=0; while (l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if (check(mid))ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 UVA12125 【March of the Penguins】]]></title>
    <url>%2F2019%2F06%2F02%2F%E9%A2%98%E8%A7%A3%20UVA12125%20%E3%80%90March%20of%20the%20Penguins%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给定一些冰块，每个冰块上有一些企鹅，每个冰块有一个可以从当前冰块跳出的次数限制，每个冰块位于一个坐标，现在每个企鹅跳跃力为$d$，问所有企鹅能否跳到一点上，如果可以输出所有落脚冰块，如果没有方案就打印$-1$ $Solution$对于每个点$i$进行拆点,分成$i_1~$和$i_2~$，中间连一条容量为能跳出次数的边，从源点$s$连向$i_1~$，流量为每个点的企鹅数，然后$n^2$枚举点，如果两个点$i,j$距离$\leqslant d$，那么分别从$i_1~$连向$j_2~,j_1~$连向$i_2~$,容量为$inf$，接着枚举汇点$t$(因为每个点都可能成为企鹅的集合点)，将$t_1$作为汇点,接着跑最大流，看看是否满流，如果满流了就记录答案，最后判断一下是否有答案，没有答案输出$-1$即可 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define pb push_back#define N 40000using namespace std;struct edge&#123; int to,dis,w,next;&#125;e[1007000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,head[N],dep[N],n,inque[N],vis[N],x[N],y[N],a[N],b[N],cur[N],cost,w[N],s,t;inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].next=head[v]; head[v]=cnt;&#125;bool bfs()&#123; memset(dep,0,sizeof(dep)); queue&lt;int&gt;q;q.push(s); dep[s]=1; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;!dep[v])&#123; dep[v]=dep[u]+1; if (!inque[v])q.push(v),inque[v]=1; &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int mn)&#123; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if (dep[v]==dep[u]+1&amp;&amp;e[i].dis) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; if (used==mn)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (bfs())&#123; for (int i=0;i&lt;=2*n;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; return res;&#125;double d;inline bool check(int a,int b)&#123; double res=sqrt(1.0*((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]))); if (res-d&lt;1e-6)return 1; return 0;&#125;void link()&#123; memset(head,0,sizeof(head));cnt=1; for (int i=1;i&lt;=n;++i) add(s,i,a[i]),add(i,i+n,b[i]); for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) if (i!=j&amp;&amp;check(i,j)) add(j+n,i,inf);&#125;signed main()&#123; int T=read(); while (T--)&#123; memset(head,0,sizeof(head));cnt=1;int tot=0,mx=0; n=read();scanf("%lf",&amp;d); s=0; for (int i=1;i&lt;=n;++i) x[i]=read(),y[i]=read(),a[i]=read(),b[i]=read(),mx+=a[i]; for (int i=1;i&lt;=n;++i)&#123; t=i; link(); if (Dinic()==mx)&#123; ++tot; if (tot==1)printf("%d",i-1); else printf(" %d",i-1); &#125; &#125; if (!tot)puts("-1"); else puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 UVA1486 【Transportation】]]></title>
    <url>%2F2019%2F06%2F02%2F%E9%A2%98%E8%A7%A3%20UVA1486%20%E3%80%90Transportation%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$某国有$n(n\leqslant 100)$座城市，由$m(m\leqslant 5000)$条单向道路相连。你希望从城市$1$运送$k(k\leqslant 100)$单位货物到城市$n$，这些道路并不安全，有很多强盗，所以你需要雇佣保镖来做护卫。每条道路都有一个危险系$a_i(a_i\leqslant 100),$如果你带着$x$个单位的货物通过，需要给保镖$a_i\times x^{2}$的佣金，保镖才会保证你的安全。每条道路都有一个限制，最多能运送$c_i(c_i\leqslant 5)$的货物。现在问，在能完成运送$x$个单位的货物到$n$号城市的情况下最小的花费，如果送不到，则输出$-1$。 $Solution$很容易看出是费用流的做法，但是我们发现对于不同的流的大小,费用并不相同。由于题目给出$c_i\leqslant 5$,我们考虑拆边。 我们将每条边拆成$c_i$条边，分别标成$e_{i,1\sim c_{i,j}}$. 对于一条边$i$。 我们把$e_{i,1}$的费用设成$a_i\times 1=a_i\times (1^2-0^2)$ 把$e_{i,2}$的费用设成$a_i\times 3=a_i\times (2^2-1^2)$ 把$e_{i,3}$的费用设成$a_i\times 5=a_i\times (3^2-2^2)$ 把$e_{i,4}$的费用设成$a_i\times 7=a_i\times (4^2-3^2)$ 把$e_{i,5}$的费用设成$a_i\times 9=a_i\times (5^2-4^2)$ 我们开始模拟边$i$的每种流量对应的费用,设$w_i~$为边$i$的费用。 假设流量为$0$,费用显然$=0$,符合题意 假设流量为$1$,费用显然$=w_{e_{i,1}}$ $\qquad\qquad\qquad\qquad\, =a_{i}\times 1$ $\qquad\qquad\qquad\qquad\, =a_{i}\times 1^2$ 假设流量为$2$,费用显然$=w_{e_{i,1}}$$+w_{e_{i,2}}$ $\qquad\qquad\qquad\qquad\, =a_{i}\times 1+a_i\times 3$ $\qquad\qquad\qquad\qquad\, =a_{i}\times 2^2$ 假设流量为$3$,费用显然$=w_{e_{i,1}}+w_{e_{i,2}}+w_{e_{i,3}}$ $\qquad\qquad\qquad\qquad\, =a_{i}\times 1+a_i\times 3+a_i\times 5$ $\qquad\qquad\qquad\qquad\, =a_{i}\times 3^2$ 假设流量为$4$,费用显然$=w_{e_{i,1}}+w_{e_{i,2}}+w_{e_{i,3}}+w_{e_{i,4}}$ $\qquad\qquad\qquad\qquad\, =a_{i}\times 1+a_i\times 3+a_i\times 5+a_i\times 7$ $\qquad\qquad\qquad\qquad\, =a_{i}\times 4^2$ 假设流量为$5$,费用显然$=w_{e_{i,1}}+w_{e_{i,2}}+w_{e_{i,3}}+w_{e_{i,4}}+w_{e_{i,5}}$ $\qquad\qquad\qquad\qquad\, =a_{i}\times 1+a_i\times 3+a_i\times 5+a_i\times 7+a_i\times 9$ $\qquad\qquad\qquad\qquad\, =a_{i}\times 5^2$ 这样拆边显然是对的。然后源点$s$连点$1$,容量为$k$,费用为$0$,点$n$连汇点$t$,容量为$k$,费用为$0$,其他边进行拆边，最后跑最小费用最大流即可。 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define N 400000using namespace std;struct node&#123; int to,dis,w,next;&#125;e[1070000];const int d[]=&#123;0,1,3,5,7,9&#125;;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,head[N],flow[N],pre[N],pri[N],inque[N],dis[N],cost,n,m,k,s,t;inline void add(int u,int v,int d,int w)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].w=-w; e[cnt].next=head[v]; head[v]=cnt;&#125;bool spfa()&#123; memset(dis,0x3f,sizeof(dis)); memset(flow,0x3f,sizeof(flow)); queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; pre[v]=u;pri[v]=i;flow[v]=min(flow[u],e[i].dis); if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;int mcmf()&#123; int res=0; while (spfa())&#123; res+=flow[t]; cost+=flow[t]*dis[t]; for (int now=t;now!=s;now=pre[now])&#123; e[pri[now]].dis-=flow[t]; e[pri[now]^1].dis+=flow[t]; &#125; &#125; return res;&#125;int main()&#123; while (scanf("%d%d%d",&amp;n,&amp;m,&amp;k)!=EOF)&#123; s=0,t=n+1; memset(head,0,sizeof(head));cnt=1;cost=0; for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),a=read(),c=read(); for (int i=1;i&lt;=c;++i) add(u,v,1,a*d[i]); &#125; add(s,1,k,0);add(n,t,k,0); printf("%d\n",mcmf()==k?cost:-1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>奇技淫巧</tag>
        <tag>费用流</tag>
        <tag>拆边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 UVA1345 【Jamie's Contact Groups】]]></title>
    <url>%2F2019%2F06%2F02%2F%E9%A2%98%E8%A7%A3%20UVA1345%20%E3%80%90Jamie's%20Contact%20Groups%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有$N$个人,$M$个分组，初始时每个人可能属于若干组，从每组中删除一些人，使每个人属于一组，且人数最多的组的人数最少 $Solution$容易想到二分答案.设二分答案为$mid$,从源点$s$向$N$个人连边，容量为$1$，表示此人只能选择一组。对每个人，向他们可以属于的组连边，容量为$1$，由于流进来的流量为$1$，所以最后也只能从一条容量为$1$的边出去，即选择一个组,对每个组，向汇点$t$连边，容量为$mid$，这表示该组人数不能超过$mid$，因此，从该点流向汇点的流量即为该组人数。最后，判断最大流是否等于$N$，即判断是否每个人都有分组 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define N 400000using namespace std;struct node&#123; int to,dis,next;&#125;e[1070000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int d[2000][2000],c[N],cur[N],cnt=1,head[N],inque[N],dep[N],n,m,s,t;inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].next=head[v]; head[v]=cnt;&#125;inline bool bfs()&#123; memset(dep,0,sizeof(dep)); dep[s]=1; queue&lt;int&gt;q;q.push(s); while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;!dep[v])&#123; dep[v]=dep[u]+1; if (!inque[v])&#123; q.push(v);inque[v]=1; &#125; &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int mn)&#123; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]==dep[u]+1) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; if (used==mn)break; &#125; &#125; return used;&#125;inline int Dinic()&#123; int res=0; while (bfs())&#123; for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; return res;&#125;bool check(int mid)&#123; memset(head,0,sizeof(head));cnt=1; for (int i=1;i&lt;=n;++i)add(s,i,1); for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=c[i];++j) add(i,1+d[i][j]+n,1); for (int j=1;j&lt;=m;++j)add(j+n,t,mid); return Dinic()==n;&#125;char ss[N];int main()&#123; while (1)&#123; n=read(),m=read();s=0,t=n+m+1; if (!n&amp;&amp;!m)return 0; memset(c,0,sizeof(c)); for (int i=1;i&lt;=n;++i)&#123; scanf("%s",ss); while (getchar()!='\n') scanf("%d",&amp;d[i][++c[i]]); &#125; int l=0,r=1200,ans=0; while (l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if (check(mid))r=mid-1,ans=mid; else l=mid+1; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2754 【[CTSC1999]家园】]]></title>
    <url>%2F2019%2F06%2F02%2F%E9%A2%98%E8%A7%A3%20P2754%20%E3%80%90%5BCTSC1999%5D%E5%AE%B6%E5%9B%AD%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$现有$n$个太空站位于地球与月球之间，且有$m$艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而每艘太空船$i$只可容纳$h_i~$个人。每艘太空船将周期性地停靠一系列的太空站，例如$:(1,3,4)$表示该太空船将周期性地停靠太空站$134,134,134\cdots$。每一艘太空船从一个太空站驶往任一太空站耗时均为$1$。人们只能在太空船停靠太空站(或月球、地球)时上、下船。 初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。 对于给定的太空船的信息，找到让所有人尽快地全部转移到月球上的运输方案。 $Solution$用并查集判断是否有解法。将一艘飞船可以到达的所有星球并查集连起来，最后如果地球和月球无法连接，则无解。 然后枚举答案。 考虑按时间分层拆点。令$t$时刻的$i$号站为$c_{t,i}$。 那么枚举的答案每增加1，就需要新建一层地球和太空站的点。 源点$s$向每一层的地球连一条容量为$inf$的边，每个空间站向下一时间的该空间站连一条容量为$inf$的边，代表时间的转移。 每个飞船现在在哪个星球，下一秒会飞到哪一个星球都可以计算得到，所以直接连边，容量为飞船载人量。 月球就是汇点，且每层图中没有月球。 然后跑最大流，如果最大流$\geqslant$需要转移的人数了，那么当前$ans$就是答案。 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define pb push_back#define N 1070000using namespace std;struct edge&#123; int to,dis,w,next;&#125;e[1007000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int res,cr,f[N],h[N],r[N],d[3000][3000],flow[N],pri[N],pre[N],p,w[N],cnt=1,head[N],dep[N],inque[N],vis[N],cur[N],cost,n,m,k,s,t;inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].next=head[v]; head[v]=cnt;&#125;bool bfs()&#123; memset(dep,0,sizeof(dep)); queue&lt;int&gt;q;q.push(s); dep[s]=1; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;!dep[v])&#123; dep[v]=dep[u]+1; if (!inque[v])q.push(v),inque[v]=1; &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int mn)&#123; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if (dep[v]==dep[u]+1&amp;&amp;e[i].dis) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; if (used==mn)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (bfs())&#123; for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; return res;&#125;int find(int k)&#123;return f[k]==k?k:f[k]=find(f[k]);&#125;inline int id(int x,int y)&#123; return (x-1)*(n+1)+y;&#125;signed main()&#123; n=read(),m=read(),k=read(),s=0,t=1e6+3; for (int i=1;i&lt;=n+2;++i)f[i]=i; for (int i=1;i&lt;=m;++i)&#123; h[i]=read(),r[i]=read(); for (int j=1;j&lt;=r[i];++j)&#123; d[i][j]=read(); if (d[i][j]==0)d[i][j]=n+1; if (d[i][j]==-1)d[i][j]=n+2; if (j!=1)f[find(d[i][j])]=find(d[i][j-1]); &#125; &#125; if (find(n+1)!=find(n+2))&#123;puts("0");return 0;&#125; for (int ans=1;;++ans)&#123; add(s,id(ans,n+1),inf); if (ans!=1) for (int i=1;i&lt;=n+1;++i)&#123; add(id(ans-1,i),id(ans,i),inf); &#125; for (int i=1;i&lt;=m;++i)&#123; int a=d[i][(ans-1)%r[i]+1],b=d[i][ans%r[i]+1]; if (a==n+2)a=t;else a=id(ans,a); if (b==n+2)b=t;else b=id(ans+1,b); add(a,b,h[i]); &#125; res+=Dinic(); if (res&gt;=k)&#123;cout&lt;&lt;ans&lt;&lt;endl;return 0;&#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>网络流$24$题</tag>
        <tag>分层图网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2050 【[NOI2012]美食节】]]></title>
    <url>%2F2019%2F06%2F01%2F%E9%A2%98%E8%A7%A3%20P2050%20%E3%80%90%5BNOI2012%5D%E7%BE%8E%E9%A3%9F%E8%8A%82%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有$n$个厨师$m$道菜，每种菜有$p_i$个人点，每个厨师$j$烧第$i$道菜要$t_{i,j}$分钟，所有人等菜时间之和为多少？ $Solution$P2053 [SCOI2007]修车的加强版 我们就按照那题的方法建图 对于每个菜$i$ $S \stackrel{p_{i}, 0}{\longrightarrow}i$ 然后建$n$层点，每层点有$m$个点，第$i$层的第$j$个点表示第$j$个厨师做第倒数$i$道菜,记为$c_{i,j}$。 $c_{i,j} \stackrel{1, 0}{\longrightarrow}t$ 假设第$j$个厨师做第倒数$k$道菜，那么对于菜$i$，向其连一条流量为$1$，费用为$k\times t_{i,j}$的边。这表示第$j$个厨师做的倒数第$k$道菜是菜$i$，那么就要做$t_{i,j}$这么长的时间，有$k$个人要等这么长的时间。 $i \stackrel{1,k\times t_{i,j}}{\longrightarrow}c_{j,k}$ 然后，我们会发现，这样写会$T$成傻$*$ 然后我们就必须进行优化 我们发现一个性质，如果经过$c_{i,j}$的流为$0$,那么经过$c_{i+1,j}\sim c_{n,j}$的流也一定为$0$.也就是说这些点根本不用建。 于是我们先建$n$个菜和第一层点，并连接第一层点和$t$,跑一边$spfa$ 一旦一条增广路被用掉了（也就是$c_{j,k}$被用掉了），那么我们就把$c_{j,k+1}$加上去，再跑$spfa$ 所以我们考虑用$EK$写费用流，因为$EK$一次只找一条增广路，与题意相符，且跑费用流的效率和$Dinic$差不多快(我也不知道为什么)。 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define pb push_back#define N 400000using namespace std;struct edge&#123; int to,dis,w,next;&#125;e[1007000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cr,flow[N],lxy=1,pri[N],pre[N],ma[500][500],a[N],p,w[N],cnt=1,head[N],dis[N],inque[N],vis[N],cur[N],cost,n,m,s,t;inline void add(int u,int v,int d,int w)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].w=-w; e[cnt].next=head[v]; head[v]=cnt;&#125;inline int id(int x,int y)&#123; return n+(x-1)*p+y;&#125;inline int chushi(int k)&#123; return (k-n-1)/p+1;&#125;inline int waittime(int k)&#123; return (k-n-1)%p+1;&#125;bool spfa()&#123; queue&lt;int&gt;q; q.push(s);memset(flow,0x3f,sizeof(flow)); memset(dis,0x3f,sizeof(dis));dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; pre[v]=u;pri[v]=i;flow[v]=min(flow[u],e[i].dis); if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]!=inf;&#125;inline int mcmf()&#123; int res=0; while (spfa())&#123; res+=flow[t]; cost+=flow[t]*dis[t]; for (int now=t;now!=s;now=pre[now])&#123; e[pri[now]].dis-=flow[t]; e[pri[now]^1].dis+=flow[t]; &#125; int lxy=pre[t]; add(lxy+1,t,1,0);//向终点连边 for (int i=1;i&lt;=n;++i)&#123;++cr; add(i,lxy+1,1,ma[i][chushi(lxy+1)]*waittime(lxy+1)); &#125; &#125; return res;&#125;signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=n;++i)w[i]=read(),p+=w[i],add(s,i,w[i],0); s=0,t=n+p*m+1; for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=m;++j)&#123; ma[i][j]=read(); add(i,id(j,1),1,ma[i][j]); &#125; for (int i=1;i&lt;=m;++i) add(id(i,1),t,1,0); mcmf(); printf("%d\n",cost); return 0;&#125;]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>分层图网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3980 【[NOI2008]志愿者招募】]]></title>
    <url>%2F2019%2F06%2F01%2F%E9%A2%98%E8%A7%A3%20P3980%20%E3%80%90%5BNOI2008%5D%E5%BF%97%E6%84%BF%E8%80%85%E6%8B%9B%E5%8B%9F%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有$n$天，每天需要$a_i$个志愿者,一共有$m$类志愿者可以招募。其中第$i$类可以从第$s_i$天工作到第$t_i$天，招募费用是每人$c_i$元。 $Solution$边$(a,b)$表示边的容量为$a$费用为$b$ 对于某一天为$i$ $i \stackrel{inf-a_{i}, 0}{\longrightarrow}i+1$ 对于某一种志愿者$j$ $s_i \stackrel{inf,c_{i}}{\longrightarrow}t_i+1$ 此外 $S \stackrel{inf,0}{\longrightarrow}1$ $n+1 \stackrel{inf,0}{\longrightarrow}T$ 求最小费用最大流即可。 那么为什么要这么连边呢$?$ 首先我们考虑，这样连最大流肯定$=inf$,由于求的是最小费用最大流，所以流会尽量往$i {\longrightarrow}i+1$这一类边走，但是由于这类边的边权为$inf-a_i$,所以必定至少有$a_i$的流往$s_i{\longrightarrow}t_i+1$这类边流，这就满足题意了。 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define pb push_back#define N 40000using namespace std;struct edge&#123; int to,dis,w,next;&#125;e[1007000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,head[N],dis[N],inque[N],vis[N],cur[N],cost,w[N],s,t;inline void add(int u,int v,int d,int w)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].w=-w; e[cnt].next=head[v]; head[v]=cnt;&#125;bool spfa()&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;int dfs(int u,int mn)&#123; vis[u]=1; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; cost+=e[i].w*mi; if (mn==used)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (spfa())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,0,sizeof(vis)); for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; &#125; return res;&#125;signed main()&#123; int n=read(),m=read();s=0,t=n+2; for (int i=1;i&lt;=n;++i) w[i]=read(); add(s,1,inf,0),add(n+1,t,inf,0); for (int i=1;i&lt;=n;++i)add(i,i+1,inf-w[i],0); for (int i=1;i&lt;=m;++i)&#123; int a=read(),b=read(),d=read(); add(a,b+1,inf,d); &#125; Dinic(); printf("%d\n",cost); return 0;&#125;]]></content>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2604 【[ZJOI2010]网络扩容】]]></title>
    <url>%2F2019%2F06%2F01%2F%E9%A2%98%E8%A7%A3%20P2604%20%E3%80%90%5BZJOI2010%5D%E7%BD%91%E7%BB%9C%E6%89%A9%E5%AE%B9%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给你一张有向图。每条边有一个容量$c$和一个扩容费用$w$。每将这条边的容量扩大$1$就需要$w$的费用。 求$1 \sim n$的最大流和将最大流扩大$k$的最小费用。 $Solution$对于第一问，直接求最大流即可 考虑对于残量网络中的每条边$e$，在图上连一条流量为$\infty$，费用为$w_e$的边。 然后从$s$连一条边到$1$，容量为$k$，以保证扩容流量正好是$k$。 只要再求一遍$s$到$n$的最小费用最大流就好了。 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 30000using namespace std;struct edge&#123; int dis,w,to,next;&#125;e[1000067];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int u[N],v[N],d[N],cnt=1,cur[N],head[N],dis[N],dep[N],vis[N],inque[N],cost,n,m,k,s,t,w[N],c[400][400];inline void add(int u,int v,int d,int w)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; e[cnt].w=w; head[u]=cnt; e[++cnt].to=u; e[cnt].next=head[v]; e[cnt].dis=0; e[cnt].w=-w; head[v]=cnt;&#125;bool spfa()&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;int dfs(int u,int mn)&#123; vis[u]=1; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; cost+=mi*e[i].w; if (mn==used)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (spfa())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,0,sizeof(vis)); memcpy(cur,head,sizeof(cur)); res+=dfs(s,inf); &#125; &#125; return res;&#125;signed main()&#123; n=read(),m=read(),k=read();s=1;t=n; for (int i=1;i&lt;=m;++i)&#123; u[i]=read(),v[i]=read(),d[i]=read(),w[i]=read(); add(u[i],v[i],d[i],0); &#125; printf("%d ",Dinic()); s=0;add(s,1,k,0); for (int i=1;i&lt;=m;++i) add(u[i],v[i],k,w[i]);Dinic(); printf("%d\n",cost); return 0;&#125;]]></content>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4015 【运输问题】]]></title>
    <url>%2F2019%2F06%2F01%2F%E9%A2%98%E8%A7%A3%20P4015%20%E3%80%90%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$$n$个仓库$m$个商店.$i$仓库有$a_i$单位货物，$i$商店需要$b_i$单位货物。$i$仓库到$j$商店的运费是$c_{i,j} /\text{单位}$。问最小运输费用和最大运输费用。 $Solution$费用流水题 对于每个仓库$i$,每个商店$j$ $s \stackrel{a_{i}, 0}{\longrightarrow}i$ $i \stackrel{inf, c_{i,j}}{\longrightarrow}i$ $j \stackrel{b_{i}, 0}{\longrightarrow}t$ 分别跑最小费用最大流和最大费用最大流即可 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 2000using namespace std;struct edge&#123; int dis,w,to,next;&#125;e[1000067];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,head[N],dis[N],vis[N],inque[N],cost,n,m,s,t,a[N],b[N],c[N][N];inline void add(int u,int v,int d,int w)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; e[cnt].w=w; head[u]=cnt; e[++cnt].to=u; e[cnt].next=head[v]; e[cnt].dis=0; e[cnt].w=-w; head[v]=cnt;&#125;bool spfa1()&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]!=inf;&#125;bool spfa2()&#123; for (int i=s;i&lt;=t;++i)dis[i]=-inf; queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&lt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]!=-inf;&#125;int dfs(int u,int mn)&#123; vis[u]=1; if (u==t)return mn; int used=0,mi; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; cost+=mi*e[i].w; if (used==mn)break; &#125; &#125; return used;&#125;void Dinic1()&#123; while (spfa1())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,0,sizeof(vis)); dfs(s,inf); &#125; &#125;&#125;void Dinic2()&#123; while (spfa2())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,0,sizeof(vis)); dfs(s,inf); &#125; &#125;&#125;signed main()&#123; n=read(),m=read(),s=0,t=n+m+1; for (int i=1;i&lt;=n;++i)a[i]=read(),add(s,i,a[i],0); for (int i=1;i&lt;=m;++i)b[i]=read(),add(i+n,t,b[i],0); for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=m;++j) c[i][j]=read(),add(i,j+n,inf,c[i][j]); Dinic1(); printf("%d\n",cost); memset(head,0,sizeof(head));cnt=1;cost=0; for (int i=1;i&lt;=n;++i)add(s,i,a[i],0); for (int i=1;i&lt;=m;++i)add(i+n,t,b[i],0); for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=m;++j) add(i,j+n,inf,c[i][j]); Dinic2(); printf("%d\n",cost); return 0;&#125;]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>网络流$24$题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2770 【航空路线问题】]]></title>
    <url>%2F2019%2F05%2F31%2F%E9%A2%98%E8%A7%A3%20P2770%20%E3%80%90%E8%88%AA%E7%A9%BA%E8%B7%AF%E7%BA%BF%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$求两条途径点数尽可能多的从$1$到$n$的不相交路线（$1,n$除外） $Solution$对于每个点$a~$拆成$a_1~$和$a_2$两个点，两个点之间的容量为$1$，边权为$1$，（因为每个点只能选一次，每选一个点可以对答案造成$1$的贡献） （若$a$为$1$或$n$容量应为$2$，因为这两个点可以选$2$次） 对于每条从$u$到$v$的边，从$u_2$向$v_1$建一条容量为$1$，边权为$0$的边（因为每条边只能选一次，选边并不会对答案造成影响） 最后从源点$s$向$a_1$建一条容量为$2$，边权为$0$,的边 从$n_2$向汇点建一条容量为$2$，边权为$0$的边 跑最大费用最大流即可 对于输出城市,进行两遍$dfs$， 第一次$dfs$找到一条$1$到$n$所有边的$flow$都为$0$的路径正序输出， 第二次$dfs$找到另一条$1$到$n$所有边的$flow$都为$0$的路径倒序输出（这次$n$不输出） $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 30000using namespace std;struct edge&#123; int dis,w,to,next;&#125;e[1000067];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,cur[N],head[N],dis[N],dep[N],vis[N],inque[N],cost,n,m,s,t,w[N],c[400][400];inline void add(int u,int v,int d,int w)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; e[cnt].w=w; head[u]=cnt; e[++cnt].to=u; e[cnt].next=head[v]; e[cnt].dis=0; e[cnt].w=-w; head[v]=cnt;&#125;bool spfa()&#123; for (int i=s;i&lt;=t;++i)dis[i]=-inf; queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&lt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]&gt;-inf;&#125;int dfs(int u,int mn)&#123; vis[u]=1; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; cost+=mi*e[i].w; if (mn==used)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (spfa())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,0,sizeof(vis)); for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; &#125; return res;&#125;string ss[107],s1,s2;map&lt;string,int&gt;ma;void dfs1(int u)&#123; cout&lt;&lt;ss[u-n]&lt;&lt;endl;vis[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v&lt;=n&amp;&amp;!e[i].dis&amp;&amp;!vis[v+n])&#123; dfs1(v+n); break; &#125; &#125;&#125;void dfs2(int u)&#123; vis[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v&lt;=n&amp;&amp;!e[i].dis&amp;&amp;!vis[v+n])&#123; dfs2(v+n); break; &#125; &#125; cout&lt;&lt;ss[u-n]&lt;&lt;endl;&#125;signed main()&#123; n=read(),m=read(),s=0,t=n+n+1;int flag=0; for (int i=1;i&lt;=n;++i)cin&gt;&gt;ss[i],ma[ss[i]]=i,add(i,i+n,1+(i==1||i==n),1); for (int i=1;i&lt;=m;++i)&#123; cin&gt;&gt;s1&gt;&gt;s2; int a=ma[s1],b=ma[s2]; if(a&gt;b)swap(a,b); if (a==1&amp;&amp;b==n)flag=1; add(a+n,b,1,0); &#125; add(s,1,2,0);add(n+n,t,2,0); int ans=Dinic(); if (!ans||(ans==1&amp;&amp;!flag))&#123;puts("No Solution!");return 0;&#125; if (ans==1&amp;&amp;flag)&#123;puts("2");cout&lt;&lt;ss[1]&lt;&lt;'\n'&lt;&lt;ss[n]&lt;&lt;'\n'&lt;&lt;ss[1]&lt;&lt;'\n';return 0;&#125; printf("%d\n",cost-2);//1,n被重复算了两次 memset(vis,0,sizeof(vis)); dfs1(1+n);dfs2(1+n); return 0;&#125;]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>网络流$24$题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1251 【餐巾计划问题】]]></title>
    <url>%2F2019%2F05%2F31%2F%E9%A2%98%E8%A7%A3%20P1251%20%E3%80%90%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$一个餐厅在相继的$N$天里,每天需用的餐巾数不尽相同。假设第$i$天需要 $r_i$块餐巾$(i=1,2,\cdots ,N)$。餐厅可以购买新的餐巾,每块餐巾的费用为$p$分;或者把旧餐巾送到快洗部,洗一块需$m$天,其费用为$f$分;或者送到慢洗部,洗一块需$n$天$(n&gt;m)$,其费用为$s$分$(s&lt;f)$。 每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和,要满足当天的需求量。 试设计一个算法为餐厅合理地安排好$N$天中餐巾使用计划,使总的花费最小。编程找出一个最佳餐巾使用计划。 $Solution$考虑费用流 其中$x \xrightarrow{a, b} y$代表从$u$向$v$连接一条流量为$x$，费用为$y$的有向边。 首先，我们将每天进行拆点，将一天拆成早上$a_1$和晚上$a_2$，每天晚上会收到脏餐巾（来源：当天早上用完的餐巾，在这道题中可理解为从源点$s$获得），每天早上又会受到干净的餐巾（来源：购买、快洗店、慢洗店）。 从源点$s$向每一天晚上连一条流量为当天所用餐巾$r_i$，费用为$0$的边，表示每天晚上$a_2$从源点$s$获得条脏餐巾。(由于我们把脏毛巾和干净毛巾看作不同的东西，所以不能从$a_1$转移过来),即$S \xrightarrow{r_i, 0} a_2$ 每天早上要使用$r_i$块干净餐巾。所以连接$a_1 \xrightarrow{r_i, 0} T$ 每天早上可以买任意多块餐巾。所以连接$S \xrightarrow{+\infty, p}$ 快洗部用$m$天将任意多块餐巾洗干净。所以连接$i \xrightarrow{+\infty, f} (i + m)$ 慢洗部用$n$天将任意多块餐巾洗干净。所以连接$i \xrightarrow{+\infty, s} (i + n)$。 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f3f3f3f#define NN 20000using namespace std;struct edge&#123; int dis,w,to,next;&#125;e[1000067];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,cur[NN],head[NN],dis[NN],vis[NN],inque[NN],cost,n,m,s,t,w[NN];inline void add(int u,int v,int d,int w)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; e[cnt].w=w; head[u]=cnt; e[++cnt].to=u; e[cnt].next=head[v]; e[cnt].dis=0; e[cnt].w=-w; head[v]=cnt;&#125;bool spfa()&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;int dfs(int u,int mn)&#123; vis[u]=1; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; cost+=mi*e[i].w; if (mn==used)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (spfa())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,0,sizeof(vis)); for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; &#125; return res;&#125;signed main()&#123;// freopen("kkk.cpp","r",stdin); int n=read();s=0,t=n+n+1; for (int i=1;i&lt;=n;++i)w[i]=read(); int P=read(),M=read(),F=read(),N=read(),S=read(); for (int i=1;i&lt;=n;++i)&#123; add(s,i+n,w[i],0);//每天晚上得到早上用剩的w[i]块脏餐巾 add(i,t,w[i],0);//每天早上需要w[i]块干净餐巾 if (i+M&lt;=n)add(i+n,i+M,inf,F);//第i天晚上送快洗部，第i+M天早上拿到干净餐巾 if (i+N&lt;=n)add(i+n,i+N,inf,S);//第i天晚上送慢洗部，第i+N天早上拿到干净餐巾 if (i!=n)add(i+n,i+1+n,inf,0);//保存到下一天 add(s,i,inf,P);//购买新餐巾 &#125; Dinic(); printf("%lld\n",cost); return 0;&#125;]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>网络流$24$题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2153 【[SDOI2009]晨跑】]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%A2%98%E8%A7%A3%20P2153%20%E3%80%90%5BSDOI2009%5D%E6%99%A8%E8%B7%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$$Elaxia$最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等 等，不过到目前为止，他坚持下来的只有晨跑。 现在给出一张学校附近的地图，这张地图中包含$N$个十字路口和$M$条街道，$Elaxia$只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia每天从寝室出发 跑到学校，保证寝室编号为$1$，学校编号为$N$.$Elaxia$的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以 在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路 口。$Elaxia$耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天 数尽量长。 除了练空手道，$Elaxia$其他时间都花在了学习和找$MM$上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。 存在$1\rightarrow n$的边存在。这种情况下，这条边只能走一次。 $Solution$边$(a,b)$表示容量为$a$,费用为$b$ 由于在一个周期内，除了$1$和$n$,一个点只能走一次,于是考虑拆点，将每个点$i$拆成$i_1~$和$i_2~$,对于$1_1$和$1_2$,$n_1$和$n_2$之间连$(inf,0)$,其余连$(1,0)$.并从$s$到$1_1$连$(inf,0)$,$n_2$到$~t$连$(inf,0)$ 对于每条读入的边(从$u$到$v$，边权为$d$)，从$u_2$到$v_1$连$(1,d)$ 最后跑费用流即可 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 2000using namespace std;struct edge&#123; int dis,w,to,next;&#125;e[1000067];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,cur[N],head[N],dis[N],vis[N],inque[N],cost,n,m,s,t,a[N],b[N],c[N][N];inline void add(int u,int v,int d,int w)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; e[cnt].w=w; head[u]=cnt; e[++cnt].to=u; e[cnt].next=head[v]; e[cnt].dis=0; e[cnt].w=-w; head[v]=cnt;&#125;bool spfa()&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]!=inf;&#125;int dfs(int u,int mn)&#123; vis[u]=1; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; cost+=mi*e[i].w; if (mn==used)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (spfa())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,0,sizeof(vis)); for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; &#125; return res;&#125;signed main()&#123; n=read(),m=read(),s=0,t=n+n+1; add(s,1,inf,0);add(n+n,t,inf,0);add(1,1+n,inf,0);add(n,n+n,inf,0); for (int i=2;i&lt;n;++i)add(i,i+n,1,0); for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),d=read(); add(u+n,v,1,d); &#125; printf("%d ",Dinic()); printf("%d\n",cost); return 0;&#125;]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1082G 【Petya and Graph】]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%A2%98%E8%A7%A3%20CF1082G%20%E3%80%90Petya%20and%20Graph%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$定义图权$=$图中边权总和$-$图中点权总和(空图的图权 $=0$)，求$n$个点 $m$条边的无向图最大权子图。 $Solution$显然，你选了一条边就必须选它两端的两个点，想到了什么$?$ 最大权闭合子图 有一个有向图，每一个点都有一个权值（可以为正或负或$0$），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。 这类问题如何解决$?$ 从源点$s$向每个正权点连一条容量为权值的边，每个负权点向汇点$t$连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。 这道题同理，$s$向(每条边的编号)连上权值为(这条边的贡献)的边 每条边$e$的编号向$e$两端的节点编号连边权为$inf$的边 每个节点向$t$连边权为节点贡献的边 跑一遍最大流即可 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 2000using namespace std;struct edge&#123; int dis,w,to,next;&#125;e[1000067];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,cur[N],head[N],dep[N],vis[N],inque[N],cost,n,m,s,t,a[N],b[N],c[N][N];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; head[u]=cnt; e[++cnt].to=u; e[cnt].next=head[v]; e[cnt].dis=0; head[v]=cnt;&#125;bool bfs()&#123; memset(dep,0,sizeof(dep)); queue&lt;int&gt;q;q.push(s); dep[s]=1; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;!dep[v])&#123; dep[v]=dep[u]+1; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int mn)&#123; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]==dep[u]+1) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; if (mn==used)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (bfs())&#123; for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; return res;&#125;signed main()&#123; n=read(),m=read(),s=0,t=n+m+1;int sum=0; for (int i=1;i&lt;=n;++i)add(i+m,t,read()); for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),d=read(); add(i,u+m,inf);add(i,v+m,inf); add(s,i,d);sum+=d; &#125; printf("%lld\n",sum-Dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大权闭合子图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4014 【分配问题】]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%A2%98%E8%A7%A3%20P4014%20%E3%80%90%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有 nn 件工作要分配给$n$个人做。第$i$个人做第$j$件工作产生的效益为 $c_{i,j}$。试设计一个将$n$件工作分配给$n$个人做的分配方案，使产生的总效益最大。 $Solution$一个人只能搭配一个任务，显然应该想到二分图，由于有权值，只需在二分图上跑费用流即可 以下边$(a,b)$表示容量为a,费用为$b$的边 首先从$s$向每个人连边$(1,0)$,再从每个任务向$t$连边$(1,0)$ 在每个人$i$与任务$j$之间连边$(1,c_{i,j})$ 分别跑最小费用最大流和最大费用最大流即可 最大费用最大流只需把$spfa$的最短路改成最长路即可 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 2000using namespace std;struct edge&#123; int dis,w,to,next;&#125;e[1000067];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,head[N],dis[N],vis[N],inque[N],cost,n,s,t,c[N][N];inline void add(int u,int v,int d,int w)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; e[cnt].w=w; head[u]=cnt; e[++cnt].to=u; e[cnt].next=head[v]; e[cnt].dis=0; e[cnt].w=-w; head[v]=cnt;&#125;bool spfa1()&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]!=inf;&#125;bool spfa2()&#123; for (int i=s;i&lt;=t;++i)dis[i]=-inf; queue&lt;int&gt;q;q.push(s); dis[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dis[v]&lt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dis[t]!=-inf;&#125;int dfs(int u,int mn)&#123; vis[u]=1; if (u==t)return mn; int used=0,mi; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; cost+=mi*e[i].w; if (used==mn)break; &#125; &#125; return used;&#125;void Dinic1()&#123; while (spfa1())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,0,sizeof(vis)); dfs(s,inf); &#125; &#125;&#125;void Dinic2()&#123; while (spfa2())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,0,sizeof(vis)); dfs(s,inf); &#125; &#125;&#125;signed main()&#123; n=read(),s=0,t=n+n+1; for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) c[i][j]=read(),add(i,j+n,1,c[i][j]); for (int i=1;i&lt;=n;++i) add(s,i,1,0),add(i+n,t,1,0); Dinic1(); printf("%d\n",cost); memset(head,0,sizeof(head));cnt=1;cost=0; for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) add(i,j+n,1,c[i][j]); for (int i=1;i&lt;=n;++i) add(s,i,1,0),add(i+n,t,1,0); Dinic2(); printf("%d\n",cost); return 0;&#125;]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>网络流$24$题</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3254 【圆桌问题】]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%A2%98%E8%A7%A3%20P3254%20%E3%80%90%E5%9C%86%E6%A1%8C%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$假设有来自$m$个不同单位的代表参加一次国际会议。每个单位的代表数分别为$r_i(1\leqslant i\leqslant m)$。 会议餐厅共有$n$张餐桌，每张餐桌可容纳$c_i(1\leqslant i\leqslant n)$个代表就餐。 为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试设计一个算法，给出满足要求的代表就餐方案。 对于给定的代表数和餐桌数以及餐桌容量，编程计算满足要求的代表就餐方案。 $Solution$贪心做法把桌子和单位的规模分别从大到小排个序(其实桌子拍不拍序没什么影响)。因为单位规模越大就越难满足，所以我们优先考虑他们; 而对于桌子你可以这样想，你桌子数量越多显然更容易满足题意，又因为小桌子很快会坐满而导致不能用，所以我们优先坐大桌子。 还有一种最大流的做法考虑对桌子和单位构点。从源点连容量为$r_i$的边到单位$i$，从餐桌$i$连容量为$c_i$的边到汇点。 注意到每个单位只能在每张桌子上放一个人。考虑从每个单位向每张桌子连一条容量为$1$的边。 如果最大流小于人数和则无解。 否则对于每个单位，枚举它的出边，输出满流边的终点即可。 $Code$只贴了贪心的代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define pb push_back#define N 400using namespace std;struct node&#123; int w,id;&#125;p[N],q[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;vector&lt;int&gt;v[400];inline bool cmp(node a,node b)&#123; return a.w&gt;b.w;&#125;int ans[N];signed main()&#123; int n=read(),m=read(); for (int i=1;i&lt;=n;++i)p[i].w=read(),p[i].id=i; for (int i=1;i&lt;=m;++i)q[i].w=read(),q[i].id=i; sort(p+1,p+1+n,cmp); sort(q+1,q+1+m,cmp); for (int i=1;i&lt;=n;++i)&#123; for (int j=1;j&lt;=p[i].w;++j)&#123; if (!q[j].w)&#123;puts("0");return 0;&#125; v[i].pb(q[j].id);--q[j].w; &#125; sort(q+1,q+1+m,cmp); ans[p[i].id]=i; &#125; puts("1"); for (int i=1;i&lt;=n;++i,puts("")) for (int j=0;j&lt;v[ans[i]].size();++j) printf("%d ",v[ans[i]][j]); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>贪心</tag>
        <tag>网络流$24$题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2766 【最长不下降子序列问题】]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%A2%98%E8%A7%A3%20P2766%20%E3%80%90%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给定正整数序列$a_1,a_2,\cdots ,a_n$。 $1.$计算其最长不下降子序列的长度$s$。 $2.$计算从给定的序列中最多可取出多少个长度为$s$的不下降子序列。 $3.$如果允许在取出的序列中多次使用$x_1$和$x_n$，则从给定序列中最多可取出多少个长度为$s$的不下降子序列。 $Solution$首先动态规划求出$f_{i}$，表示以第$i$位为开头的最长不下降子序列的长度，求出最长不下降子序列长度$W$。 把序列每位$i$拆成两个点$i_1$和$i_2$，从$i_1~$到$i_2~$连接一条容量为$1$的边。 如果序列第$i$位有$f_{i}=W$，从$s$到$i_{1}~$连接一条容量为$1$的有向边。 如果$f_i=1$，从$i_2~$到$~t~$连接一条容量为1的有向边。 如果$j&gt;i$且$a_i&lt;a_j$且$f_j+1=f_i$，从$i_2~$到$j_1~$连接一条容量为$1$的有向边。 第二问直接求最大流即可 对于第三问,要求$a_1$和$a_n$可以重复使用，只需取消这两个点相关边的流量限制即可，具体操作只需把$(1_1,1_2)(n_1,n_2)(s,1_1)(n_2,t)$四条边权值改成$inf$,再跑最大流即可 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define N 50000using namespace std;struct node&#123; int dis,to,next;&#125;e[1000055];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int res,w[N],f[N],ans,cnt=1,head[N],dep[N],inque[N],cur[N],n,m,s,t;inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].next=head[v]; head[v]=cnt;&#125;bool bfs()&#123; memset(dep,0,sizeof(dep)); queue&lt;int&gt;q;q.push(s); dep[s]=1; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;!dep[v])&#123; dep[v]=dep[u]+1; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int mn)&#123; if (u==t)return mn; int used=0,mi; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]==dep[u]+1) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; if (used==mn)break; &#125; &#125; return used;&#125;int Dinic()&#123; while (bfs())&#123; for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; return res;&#125;signed main()&#123; n=read(),s=0,t=n+n+1; for (int i=1;i&lt;=n;++i)w[i]=read(),f[i]=1;ans=1; for (int i=n-1;i;--i) for (int j=i+1;j&lt;=n;++j) if (w[j]&gt;=w[i]) ans=max(ans,f[i]=max(f[i],f[j]+1)); printf("%d\n",ans); if (ans==1)&#123;printf("%d\n%d\n",n,n);return 0;&#125; for (int i=1;i&lt;=n;++i)&#123; add(i,i+n,1); if (f[i]==ans)add(s,i,1); if (f[i]==1)add(i+n,t,1); for (int j=i+1;j&lt;=n;++j) if (f[j]+1==f[i]&amp;&amp;w[j]&gt;=w[i]) add(i+n,j,1); &#125; printf("%d\n",Dinic()); add(1,1+n,inf);add(n,n+n,inf); if (f[1]==ans)add(s,1,inf); if (f[1]==1)add(n+1,t,inf); if (f[n]==1)add(n+n,t,inf); printf("%d\n",Dinic());&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>网络流$24$题</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3355 【骑士共存问题】]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%A2%98%E8%A7%A3%20P3355%20%E3%80%90%E9%AA%91%E5%A3%AB%E5%85%B1%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$Description$求带障碍的$n\times n$的国际象棋棋盘可以放多少个马，使得两两之间互相不能攻击。 $Solution$将可以互相攻击的格子之间连一条边，然后求二分图的最大独立集即可。 二分图最大独立集$=$点数$-$最大匹配 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define N 50000using namespace std;struct node&#123; int dis,to,next;&#125;e[1000055];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int dx[]=&#123;-2,-2,-1,-1,1,1,2,2&#125;,dy[]=&#123;-1,1,-2,2,2,-2,-1,1&#125;,tot,id[207][207],ma[207][207],cnt=1,head[N],dep[N],inque[N],cur[N],n,m,s,t;inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].next=head[v]; head[v]=cnt;&#125;bool bfs()&#123; memset(dep,0,sizeof(dep)); queue&lt;int&gt;q;q.push(s);dep[s]=1; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (!dep[v]&amp;&amp;e[i].dis)&#123; dep[v]=dep[u]+1; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int mn)&#123; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]==dep[u]+1) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; if (used==mn)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (bfs())&#123; for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; return res;&#125;signed main()&#123; n=read(),m=read(),s=0,t=n*n-m+1; for (int i=1;i&lt;=m;++i)ma[read()][read()]=1; for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) if (!ma[i][j])&#123; id[i][j]=++tot; if ((i+j)&amp;1)add(s,id[i][j],1); else add(id[i][j],t,1); &#125; for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) if (!ma[i][j])&#123; for (int p=0;p&lt;8;++p)&#123; int x=i+dx[p],y=j+dy[p]; if (ma[x][y]||x&lt;1||y&lt;1||x&gt;n||y&gt;n)continue; if ((i+j)&amp;1) add(id[i][j],id[x][y],1); else add(id[x][y],id[i][j],1); &#125; &#125; printf("%d\n",n*n-m-Dinic());&#125;]]></content>
      <tags>
        <tag>网络流$24$题</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SP4063 【MPIGS - Sell Pigs】]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%A2%98%E8%A7%A3%20SP4063%20%E3%80%90MPIGS%20-%20Sell%20Pigs%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$$Mirko$在一个养猪场工作，养猪场有$M$个关着的猪圈，$Mirko$不能打开任何猪圈，因为他没钥匙。顾客一个接一个(顺序不能改变)地来到养猪场，他们各拥有一些猪圈的钥匙，想买若干猪。Mirko早就知道关于那天来农场的顾客的所有数据，他可以制定一个销售计划，以便尽可能增加出售的猪的数量。更明确地，整个过程如下：顾客来了，顾客用手里的钥匙打开猪圈了，$Mirko$把他要的猪(从当前打开着的猪圈中选出需要数量)卖给他，并且重排（当前开着的猪圈中的）剩余的猪， 注意，猪圈的容量无穷大。请尽可能最大化他能卖出的猪的数量,顾客来的顺序不可改变，顾客来后、调整完后猪圈门会关闭。 $Solution$在某个拥有$k$的钥匙的顾客$a$买过猪后， 在之后买猪的某个同样拥有钥匙$k$的顾客$b$也能买到$a$能买到的猪(因为$a$买剩下的猪可以在$a$买后调整到$k$中)。 所以，从$a$向$b$连边即可，流量为$inf$。 并且，如果$a$是第一个打开$k$的人，就将$a$和源点$s$连边，流量为$k$的初始猪的数量。 最后，将汇点$t$与每个顾客连边，流量为顾客最多能买的猪 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define N 2000using namespace std;struct node&#123; int dis,to,next;&#125;e[100055];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt=1,head[N],dep[N],inque[N],cur[N],n,m,s,t,w[N],la[N];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].next=head[v]; head[v]=cnt;&#125;bool bfs()&#123; memset(dep,0,sizeof(dep)); queue&lt;int&gt;q;q.push(s); dep[s]=1; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;!dep[v])&#123; dep[v]=dep[u]+1; if (!inque[v]) q.push(v),inque[v]=1; &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int mn)&#123; if(u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]==dep[u]+1) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi; if (used==mn)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (bfs())&#123; for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; return res;&#125;signed main()&#123; n=read(),m=read(),s=0,t=m+1; for (int i=1;i&lt;=n;++i)w[i]=read(); for (int i=1;i&lt;=m;++i)&#123; int k=read(); for (int j=1;j&lt;=k;++j)&#123; int d=read(); if (!la[d])add(s,i,w[d]); else add(la[d],i,inf); la[d]=i; &#125; int w=read(); add(i,t,w); &#125; printf("%d\n",Dinic());&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1613 【跑路】]]></title>
    <url>%2F2019%2F05%2F26%2F%E9%A2%98%E8%A7%A3%20P1613%20%E3%80%90%E8%B7%91%E8%B7%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有$n$个点，$m$条边，边权为一，每次都可以走$2^k$条边，问最多要走几次 $Solution$考虑倍增，设$f_{i,j,k}$表示$i$到$j$是否能以走$2^k$条边相互到达。 可以用$Floyd$的方法求出$f$数组。 求完后，若$f_{i,j,k}=1(0\leqslant k\leqslant 64)$,则连一条$i$到$j$的边权为$1$的边 最后再用$Floyd$求出$1$~$n$的最短路即可。 $Code$123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 100using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int d[N][N],f[N][N][N];signed main()&#123; int n=read(),m=read(); memset(d,0x3f,sizeof(d)); for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); f[u][v][0]=1;d[u][v]=1; &#125; for (int p=1;p&lt;=64;++p) for (int k=1;k&lt;=n;++k) for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) if (f[i][k][p-1]&amp;f[k][j][p-1]) f[i][j][p]=1,d[i][j]=1; for (int k=1;k&lt;=n;++k) for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); cout&lt;&lt;d[1][n]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>$Floyd$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3480 【[POI2009]KAM-Pebbles】]]></title>
    <url>%2F2019%2F05%2F26%2F%E9%A2%98%E8%A7%A3%20P3480%20%E3%80%90%5BPOI2009%5DKAM-Pebbles%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有$N$堆石子，除了第一堆外，每堆石子个数都不少于前一堆的石子个数。两人轮流操作每次操作可以从一堆石子中移走任意多石子，但是要保证操作后仍然满足初始时的条件谁没有石子可移时输掉游戏。问先手是否必胜。 $Solution$题目要求每堆石子个数都不少于前一堆的石子个数，可以理解为差分数组$c$必须每项都$\geqslant 0$,而每次操作在第$i$堆取了$k$个石子，就相当于$c_{i}-=k,c_{i+1}+=k$,这就类似于阶梯$nim$了，不过由于方向相反，所以阶梯$nim$要反着做 $Code$123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define N 300007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int c[N],w[N];signed main()&#123; int T=read(); while (T--)&#123; int n=read(),ans=0; for (int i=1;i&lt;=n;++i)w[i]=read(),c[i]=w[i]-w[i-1]; for (int i=n;i;--i) if ((n-i+1)&amp;1) ans^=c[i]; if (ans)puts("TAK"); else puts("NIE"); &#125;&#125;]]></content>
      <tags>
        <tag>巧妙转化</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3645 【[APIO2015]雅加达的摩天楼】]]></title>
    <url>%2F2019%2F05%2F26%2F%E9%A2%98%E8%A7%A3%20P3645%20%E3%80%90%5BAPIO2015%5D%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有$m$只$doge$分布在$n$个摩天大楼上。楼和$doge$都是从$0$开始编号。 每只$doge$初始位置$b[i]$，弹跳力$p[i]$。 它每一次跳会恰好跳$p[i]$个大楼。比如从$x$可以到$x±p[i]$。 现在，$0$号$doge$要把某信息传给$1$号$doge$。对于一只$doge$，若它尚未知道信息，就不能动。 对于一只$doge$，若它已经知道信息，可以选择把信息告诉处于同一位置的$doge$们，或者跳去别的位置。 求最少跳的步数。 $Solution$先考虑暴力 对于每一只$doge$，我们从$b[i]$ 连边到所有它可以跳到（可以跳好多步）的位置，边权为需要跳的次数。 从$b[0]$跑一下最短路即可。 但是，这样边数太多了。 那么考虑一下分块，把每一座摩天大楼拆成$O(\sqrt{n})$层，第$0$层表示原点,第$j$层代表一步能跳到$b[i]±j$的摩天大楼，如果某座摩天大楼的$p[i]&gt;size$则暴力从该摩天大楼的原点向$b[i]±j$的摩天大楼的原点连边，然后这一层每一个摩天大楼向它能到达的摩天大楼的相同层连双向边，并且每座摩天大楼的每一层都要向该摩天大楼的原点连边，可以保证边数在$n\sqrt{n}$级别左右(视$n,m$同阶) $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 6000020#define M 6000020using namespace std;struct edge&#123; int dis,to,next;&#125;e[M*9];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt,head[N],dis[N],inque[N],b[N],p[N],n,m;inline int id(int x,int y)&#123; return y*n+x;&#125;inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt;&#125;void spfa(int s)&#123; memset(dis,0x3f,sizeof(dis)); dis[s]=0;queue&lt;int&gt;q;q.push(s); while (!q.empty())&#123; int u=q.front();inque[u]=0;q.pop(); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (dis[v]&gt;dis[u]+e[i].dis)&#123; dis[v]=dis[u]+e[i].dis; if (!inque[v])q.push(v),inque[v]=1; &#125; &#125; &#125;&#125;signed main()&#123; n=read(),m=read();int size=sqrt(n/3); for (int i=0;i&lt;m;++i)&#123; b[i]=read(),p[i]=read(); if (p[i]&gt;size)&#123;//大于size的直接暴力连,边数最多m*sqrt(n)条 for (int d=1,j=b[i]-p[i];j&gt;=0;++d,j-=p[i]) add(id(b[i],0),id(j,0),d); for (int d=1,j=b[i]+p[i];j&lt;n;++d,j+=p[i]) add(id(b[i],0),id(j,0),d); &#125;else&#123; add(id(b[i],0),id(b[i],p[i]),0);//从每层原点向第p[i]层连边，表示b[i]这个摩天大楼可以跳到b[i]±j的摩天大楼 &#125; &#125; for (int j=1;j&lt;=size;++j)&#123; for (int i=0;i&lt;n;++i)&#123; if (i+j&lt;n) add(id(i,j),id(i+j,j),1); if (i-j&gt;=0)add(id(i,j),id(i-j,j),1); add(id(i,j),id(i,0),0); &#125; &#125; spfa(id(b[0],0)); if (dis[id(b[1],0)]&gt;=inf)puts("-1"); else printf("%d\n",dis[id(b[1],0)]); return 0;&#125;]]></content>
      <tags>
        <tag>连边优化</tag>
        <tag>分块</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3604 【美好的每一天】]]></title>
    <url>%2F2019%2F05%2F25%2F%E9%A2%98%E8%A7%A3%20P3604%20%E3%80%90%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$一个区间如果满足区间内的值重排之后可以成为一个回文串，则这个区间可以回归天空 当前有$m$个区间，要求每个区间中有多少个子区间可以回归天空 $Solution$很容易想到是莫队题，但是对于维护区间贡献很难处理。 由于区间内的字符都是小写字母，考虑用$2$的幂次表示，如$’a’$表示为$2^0$,$’b’$表示为$2^1$,$’z’$表示为$2^{25}$(用$2$的幂次表示的原因下会讲) 然后考虑一个区间$[l,r]$对答案有贡献当且仅当$a_{r}~xor~a_{l-1}=2^x$或$0$，其中$a_{i}$为异或前缀和 开一个计数数组$c$,其中$c_{i}$表示当前区间中异或前缀和的值为$i$的点的个数，统计答案时若当前枚举到的点$j$的异或前缀和为$a_{j}$，枚举$2$的所有幂次和$0$,$ans$直接加上(或减去)$c[a_{j}]+\sum\limits_{i=0}^{25}c[2^i~xor~a_{j}]$ 至于为什么区间内字符用$2$的幂次表示,换用别的编号呢$?$ 如果不用$2$的幂次表示,换用别的编号，那么即使$xor$起来$=0$也不能说明区间内的数能排列成回文串,如一个区间内三个数的的编号分别为$1,4,5$,即使它们异或起来也是$0$，但是它们显然不能构成回文串。 $PS:$当前维护$[l,r]$的信息时，$ans$应加上$[l-1,r-1]$的信息(若是减去则维护$[l-1,r]$的信息)，并且桶维护$[l-1,r]$的信息,因为当前枚举到的点是$r$。 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 60007using namespace std;struct node&#123; int l,r,num;&#125;q[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ans,block,n,m,w[N],a[N],Ans[N];unsigned short c[1&lt;&lt;26];char s[N];inline bool cmp(node a,node b)&#123; return (a.l/block)^(b.l/block)?a.l&lt;b.l:(((a.l/block)&amp;1)?a.r&lt;b.r:a.r&gt;b.r);&#125;inline void add(int k)&#123; for (int i=0;i&lt;26;++i) ans+=c[k^(1&lt;&lt;i)]; ans+=c[k]; ++c[k];&#125;inline void del(int k)&#123; for (int i=0;i&lt;26;++i) ans-=c[k^(1&lt;&lt;i)]; --c[k]; ans-=c[k];&#125;signed main()&#123; n=read(),m=read();block=(m&amp;&amp;n/sqrt(m*2/3))?n/sqrt(m*2/3):sqrt(n); scanf("%s",s+1); for (int i=1;i&lt;=n;++i)w[i]=(1&lt;&lt;(s[i]-'a')),a[i]=a[i-1]^w[i]; for (int i=1;i&lt;=m;++i)q[i].l=read()-1,q[i].r=read(),q[i].num=i; sort(q+1,q+1+m,cmp); int l=1,r=0; for (int i=1;i&lt;=m;++i)&#123; int ql=q[i].l,qr=q[i].r; while (l&gt;ql)add(a[--l]); while (r&lt;qr)add(a[++r]); while (l&lt;ql)del(a[l++]); while (r&gt;qr)del(a[r--]); Ans[q[i].num]=ans; &#125; for (int i=1;i&lt;=m;++i)printf("%d\n",Ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>莫队</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF366C 【Dima and Salad】]]></title>
    <url>%2F2019%2F05%2F25%2F%E9%A2%98%E8%A7%A3%20CF366C%20%E3%80%90Dima%20and%20Salad%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$有$n$个水果,每个水果有两个属性：美味值和卡路里值。现在选用若干个（至少$1$个）水果制作一份特殊的沙拉，沙拉的美味值为所选的水果的美味值的和，沙拉的卡路里值为所选水果的卡路里值的和。要保证沙拉的美味值恰好是卡路里值的$K$倍。请计算该沙拉美味值最大为多少。 $Solution$根据题意可得$\sum a_{i}-k\times\sum b_{i}=0$ 所以我们考虑将$a_{i}$作为价值，$a_{i}-k\times b_{i}$作为重量，进行背包转移即可，由于重量有可能是负数，所以应用$map$存储转移数组或是将下标强行加上一个大数。 $Code$123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 30007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int a[N],v[N],f[200][N],g[200][N];signed main()&#123; int n=read(),k=read(),m=100*n;memset(f,-0x7f,sizeof(f));memset(g,-0x7f,sizeof(g)); for (int i=1;i&lt;=n;++i)a[i]=read(); for (int i=1;i&lt;=n;++i)v[i]=a[i]-read()*k; f[0][m]=0; for (int i=1;i&lt;=n;++i) for (int j=0;j&lt;=2*m;++j) f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+a[i]); cout&lt;&lt;(f[n][m]!=0?f[n][m]:-1)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>背包</tag>
        <tag>巧妙转化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2414 【[NOI2011]阿狸的打字机】]]></title>
    <url>%2F2019%2F05%2F24%2F%E9%A2%98%E8%A7%A3%20P2414%20%E3%80%90%5BNOI2011%5D%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$打字机上只有$28$个按键，分别印有$26$个小写英文字母和$’B’$、$’P’$两个字母。这个打字机是这样工作的： 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。 按一下印有$’B’$的按键，打字机凹槽中最后一个字母会消失。 按一下印有$’P’$的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。 例如，阿狸输入$aPaPBbP$，纸上被打印的字符如下：$a aa ab$我们把纸上打印出来的字符串从$1$开始顺序编号，一直到$n$。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数$(x,y)($其中$1\leqslant x,y\leqslant n)$，打字机会显示第$x$个打印的字符串在第$y$个打印的字符串中出现了多少次。 $Solution:$先无脑搭出一只$AC$自动机再说，然后再考虑各档分的做法 $40$给每个串的结束位置都标记一下，给$AC$自动机中的每个节点记录一个父亲节点，然后对于每个串的结束位置都暴力往上跳，计算有几个被标记过的节点即可 $70(1)$这样对于每一个询问都要暴力往上跳 如果对于某个串有重复的多次询问 那么就会多很多次没有任何意义的计算 所以，可以离线把所有询问都按照$y$排序 $y$相同的询问将从$y$向上跳碰到的标记记录下来，最后一起统计 $70(2)$原来是$y$的某个节点往上跳能不能到达$x$ 现在反过来： $x$往下跳能够到达几个$y$的节点 如果把$y$这个字符串所有的节点全部打上一个$1$的标记 那么，每次就变成了求$x$结束位置的子树和 而一个点的子树在$dfs$序上一定是连续的一段 单点修改，区间查询，考虑用树状数组打标记 $100$每次把串插入进树状数组会导致很多的串会有重复 考虑对$Trie$进行$dfs$ 对于每个节点访问到的时候对它的$dfs$序打一个$+1$,结束的时候对它的$dfs$序打一个$-1$ 每次访问到一个结束节点的时候，一定是有且仅有这个结束节点对应的串的所有节点被打了标记，这样就可以直接回答这个串作为$y$的所有询问了 $Code$$40$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 500007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N];int tot,K,ch[N][26],fail[N],fa[N],w[N],ed[N];void build_fail()&#123; queue&lt;int&gt;q; for (int i=0;i&lt;26;++i)if (ch[0][i])q.push(ch[0][i]); while (!q.empty())&#123; int now=q.front();q.pop(); for (int i=0;i&lt;26;++i) if (ch[now][i]) fail[ch[now][i]]=ch[fail[now]][i],q.push(ch[now][i]); else ch[now][i]=ch[fail[now]][i]; &#125;&#125;int query(int x,int y)&#123; int res=0; for (int now=ed[y];now;now=fa[now]) for (int t=now;t;t=fail[t]) if (w[t]==x)&#123; ++res;break; &#125; return res;&#125;signed main()&#123; scanf("%s",s);int len=strlen(s); int now=0; for (int i=0;i&lt;len;++i)&#123; if (s[i]=='B')&#123; now=fa[now]; &#125;else if (s[i]=='P')&#123; ed[++K]=now;w[now]=K; &#125;else&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot,fa[tot]=now; now=ch[now][v]; &#125; &#125; build_fail(); int n=read(); for (int i=1;i&lt;=n;++i)&#123; int x=read(),y=read(); printf("%d\n",query(x,y)); &#125; return 0;&#125; $70(1)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 500007using namespace std;struct node&#123; int x,y,num;&#125;q[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N];int cnt[N],tot,K,ch[N][26],ans[N],fail[N],fa[N],w[N],ed[N];void build_fail()&#123; queue&lt;int&gt;q; for (int i=0;i&lt;26;++i)if (ch[0][i])q.push(ch[0][i]); while (!q.empty())&#123; int now=q.front();q.pop(); for (int i=0;i&lt;26;++i) if (ch[now][i]) fail[ch[now][i]]=ch[fail[now]][i],q.push(ch[now][i]); else ch[now][i]=ch[fail[now]][i]; &#125;&#125;int query(int y)&#123; int res=0; for (int now=ed[y];now;now=fa[now]) for (int t=now;t;t=fail[t])&#123; ++cnt[w[t]]; &#125; return res;&#125;inline bool cmp(node a,node b)&#123; return a.y&lt;b.y;&#125;signed main()&#123; scanf("%s",s);int len=strlen(s); int now=0; for (int i=0;i&lt;len;++i)&#123; if (s[i]=='B')&#123; now=fa[now]; &#125;else if (s[i]=='P')&#123; ed[++K]=now;w[now]=K; &#125;else&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot,fa[tot]=now; now=ch[now][v]; &#125; &#125; build_fail(); int n=read(); for (int i=1;i&lt;=n;++i)q[i].x=read(),q[i].y=read(),q[i].num=i; sort(q+1,q+1+n,cmp); for (int i=1,j=1;i&lt;=n;i=j)&#123; query(q[i].y); while (q[i].y==q[j].y)ans[q[j].num]=cnt[q[j].x],++j; memset(cnt,0,sizeof(cnt)); &#125; for (int i=1;i&lt;=n;++i)printf("%d\n",ans[i]); return 0;&#125; $70(2)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 500007using namespace std;struct node&#123; int x,y,num;&#125;q[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N];int cnt[N],tot,K,ch[N][26],ans[N],fail[N],fa[N],w[N],ed[N];void build_fail()&#123; queue&lt;int&gt;q; for (int i=0;i&lt;26;++i)if (ch[0][i])q.push(ch[0][i]); while (!q.empty())&#123; int now=q.front();q.pop(); for (int i=0;i&lt;26;++i) if (ch[now][i]) fail[ch[now][i]]=ch[fail[now]][i],q.push(ch[now][i]); else ch[now][i]=ch[fail[now]][i]; &#125;&#125;int query(int y)&#123; int res=0; for (int now=ed[y];now;now=fa[now]) for (int t=now;t;t=fail[t])&#123; ++cnt[w[t]]; &#125; return res;&#125;inline bool cmp(node a,node b)&#123; return a.y&lt;b.y;&#125;signed main()&#123; scanf("%s",s);int len=strlen(s); int now=0; for (int i=0;i&lt;len;++i)&#123; if (s[i]=='B')&#123; now=fa[now]; &#125;else if (s[i]=='P')&#123; ed[++K]=now;w[now]=K; &#125;else&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot,fa[tot]=now; now=ch[now][v]; &#125; &#125; build_fail(); int n=read(); for (int i=1;i&lt;=n;++i)q[i].x=read(),q[i].y=read(),q[i].num=i; sort(q+1,q+1+n,cmp); for (int i=1,j=1;i&lt;=n;i=j)&#123; query(q[i].y); while (q[i].y==q[j].y)ans[q[j].num]=cnt[q[j].x],++j; memset(cnt,0,sizeof(cnt)); &#125; for (int i=1;i&lt;=n;++i)printf("%d\n",ans[i]); return 0;&#125; $100$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 500007using namespace std;struct edge&#123; int to,next;&#125;e[N];struct node&#123; int x,y,num;&#125;q[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;char s[N];int ql[N],qr[N],cc[N][26],ttt,head[N],dfn[N],low[N],dfsnum,c[100007],cnt[N],tot,K,ch[N][26],ans[N],fail[N],fa[N],w[N],ed[N];void add(int x,int d)&#123;for (;x&lt;=dfsnum;x+=(x&amp;(-x)))c[x]+=d;&#125;int sum(int x)&#123;int res=0;for (;x;x&amp;=x-1)res+=c[x];return res;&#125;void build_fail()&#123; queue&lt;int&gt;q; for (int i=0;i&lt;26;++i)if (ch[0][i])q.push(ch[0][i]); while (!q.empty())&#123; int now=q.front();q.pop(); for (int i=0;i&lt;26;++i) if (ch[now][i]) fail[ch[now][i]]=ch[fail[now]][i],q.push(ch[now][i]); else ch[now][i]=ch[fail[now]][i]; &#125;&#125;int query(int y)&#123; int res=0; for (int now=ed[y];now;now=fa[now]) for (int t=now;t;t=fail[t])&#123; ++cnt[w[t]]; &#125; return res;&#125;void Dfs(int u)&#123; dfn[u]=++dfsnum; for (int i=head[u];i;i=e[i].next)Dfs(e[i].to); low[u]=dfsnum;&#125;inline void Add(int u,int v)&#123; e[++ttt].to=v; e[ttt].next=head[u]; head[u]=ttt;&#125;inline bool cmp(node a,node b)&#123; return a.y&lt;b.y;&#125;void dfs(int u)&#123; add(dfn[u],1); if (w[u]) for (int i=ql[w[u]];i&lt;=qr[w[u]];++i) ans[q[i].num]=sum(low[ed[q[i].x]])-sum(dfn[ed[q[i].x]]-1); for (int i=0;i&lt;26;++i) if (cc[u][i])&#123; dfs(cc[u][i]); &#125; add(dfn[u],-1);&#125;signed main()&#123; scanf("%s",s);int len=strlen(s); int now=0; for (int i=0;i&lt;len;++i)&#123; if (s[i]=='B')&#123; now=fa[now]; &#125;else if (s[i]=='P')&#123; ed[++K]=now;w[now]=K; &#125;else&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot,fa[tot]=now; now=ch[now][v]; &#125; &#125; for (int i=0;i&lt;=tot;++i) for (int j=0;j&lt;26;++j) cc[i][j]=ch[i][j]; build_fail(); for (int i=1;i&lt;=tot;++i)Add(fail[i],i);Dfs(0); int n=read(); for (int i=1;i&lt;=n;++i)q[i].x=read(),q[i].y=read(),q[i].num=i; sort(q+1,q+1+n,cmp); for (int i=1,j=1;i&lt;=n;i=j)&#123; ql[q[i].y]=i; while (q[i].y==q[j].y)++j; qr[q[i].y]=j-1; &#125; dfs(0); for (int i=1;i&lt;=n;++i)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>$AC$自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF596D 【Wilbur and Trees】]]></title>
    <url>%2F2019%2F05%2F24%2F%E9%A2%98%E8%A7%A3%20CF596D%20%E3%80%90Wilbur%20and%20Trees%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$太长了,不想解释(逃 $Solution:$容易发现,砍树是从两端开始砍的，因此两端会影响中间，而中间则不会影响到两端的树，因为砍到中间的时候，两端的树都已经砍过了.所以做$dp$的时候，例如正在处理区间$i$到$j$，我们不需要关注区间内的树是向哪边倒的，因为中间的树不会影响两端的，我们需要关注的是$i-1$和$j+1$位的地方的树，因为只有这些地方会对中间的树有影响，所以我们用$dp[i][j][0/1][0/1]$来表式$i-1$和$j+1$这两棵树的状态时，$i$到$j$之间的答案。若状态若为$0$，则表示向左侧倒，若为$1$，则表示向右侧倒。 接下来分类讨论: $1.$第$i$颗树向左倒，不会影响别的树 $2.$第$j$棵树向右倒，不会影响别的树 $3.$第$i$棵树向右倒，会影响到第$i$棵树右边的树 $(1)$第$i$棵树能把$(i+1)$~$j$之间的所有树都压倒 $(2)$第$i$棵树不能把$(i+1)$~$j$之间的所有树都压倒 $4.$第$j$棵树向左倒，会影响到前面的树 $(1)$第$j$棵树能把$i$~$(j-1)$之间的所有树都压倒 $(2)$第$j$棵树不能把$i$~$(j-1)$之间的所有树都压倒 采用记搜实现 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define N 2007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125; int loc[N],dl[N],dr[N],h,n;double f[N][N][2][2],p,q;double dfs(int l,int r,int x,int y)&#123; if (l&gt;r)return 0; if (f[l][r][x][y]!=-1)return f[l][r][x][y]; double res=0,L=min(h,loc[l]-loc[l-1]-x*h),R=min(h,loc[r+1]-loc[r]-(!y)*h); res+=0.5*p*(dfs(l+1,r,0,y)+L);//最左边向左倒 res+=0.5*q*(dfs(l,r-1,x,1)+R);//最右边向右倒 if (dl[r]&lt;=l)res+=0.5*p*(loc[r]-loc[l]+L); else res+=0.5*p*(dfs(l,dl[r]-1,x,0)+loc[r]-loc[dl[r]]+h);// 最右边的向左倒，且能覆盖整个区间的树 if (dr[l]&gt;=r)res+=0.5*q*(loc[r]-loc[l]+R); else res+=0.5*q*(dfs(dr[l]+1,r,1,y)+loc[dr[l]]-loc[l]+h);// 最左边的向右倒，且能覆盖整个区间的树 return f[l][r][x][y]=res;&#125;signed main()&#123; n=read();cin&gt;&gt;h&gt;&gt;p;q=1-p; for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) for (int x=0;x&lt;2;++x) for (int y=0;y&lt;2;++y) f[i][j][x][y]=-1.0; for (int i=1;i&lt;=n;++i)loc[i]=read(); sort(loc+1,loc+1+n);loc[0]=-inf;loc[n+1]=inf; dl[1]=1; for (int i=2;i&lt;=n;++i) if (loc[i]-loc[i-1]&lt;h)dl[i]=dl[i-1]; else dl[i]=i; dr[n]=n; for (int i=n-1;i;--i) if (loc[i+1]-loc[i]&lt;h)dr[i]=dr[i+1]; else dr[i]=i; //dl[i],dr[i]分别表示从i这棵树开始向左/右最多能覆盖到第dl[i]/dr[i]棵树 printf("%.9lf\n",dfs(1,n,0,1)); &#125;]]></content>
      <tags>
        <tag>概率期望$DP$</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4135 【作诗】]]></title>
    <url>%2F2019%2F05%2F24%2F%E9%A2%98%E8%A7%A3%20P4135%20%E3%80%90%E4%BD%9C%E8%AF%97%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$$N$个数，$M$组询问，每次问$[l,r]$中有多少个数出现正偶数次。 $Solution:$考虑分块 先设$:f[i][j]$表示$i$块到$j$块的有多少个数出现正偶数次; $sum[i][j]$表示前$i$块中，数值$j$的出现次数; 预处理$f$数组和$sum$数组,时间复杂度$O(n\sqrt n)$ 处理询问时，设$res$为最终答案,$A$为询问左端点所在块，$B$为询问右端点所在块，先把$res$初值设为$f[A+1][B-1]$,然后处理两侧的不完整块. 对于一个值$j$,它在第$A+1$个块到第$B-1$个块中出现的次数就是$sum[B-1][j]-sum[A][j]$(类似于前缀和) 在处理不完整块的时候,若当前点的下标为$j$,那么只需要判断$++cnt[w[j]]+sum[B-1][w[j]]-sum[A][w[j]]$的奇偶性,并特判一下$0$变$1$的情况,然后更改$res$的值即可. $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 100007#define S 323using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int size,num,w[N],ans,n,m,c,sum[S][N],cnt[N],belong[N],l[N],r[N],f[S][S];void build()&#123; size=sqrt(n);num=(n-1)/size+1; for (int i=1;i&lt;=n;++i)belong[i]=(i-1)/size+1; for (int i=1;i&lt;=num;++i)l[i]=(i-1)*size+1,r[i]=i*size;r[num]=n; for (int i=1;i&lt;=num;++i)&#123; int res=0; for (int j=i;j&lt;=num;++j)&#123; for (int k=l[j];k&lt;=r[j];++k) if (!((++cnt[w[k]])&amp;1))++res; else if (cnt[w[k]]!=1)--res; f[i][j]=res; &#125; for (int j=i;j&lt;=num;++j) for (int k=l[j];k&lt;=r[j];++k)--cnt[w[k]]; &#125; memset(cnt,0,sizeof(cnt)); for (int i=1;i&lt;=n;++i)&#123; ++cnt[w[i]]; if (i==r[belong[i]]) memcpy(sum[belong[i]],cnt,sizeof(sum[belong[i]])); &#125;&#125;inline int calc(int l,int r,int w)&#123; return (l&lt;r)?(sum[r-1][w]-sum[l][w]):0;&#125;int query(int x,int y)&#123; x=(x+ans)%n+1,y=(y+ans)%n+1; if (x&gt;y)swap(x,y); int A=belong[x],B=belong[y],res=f[A+1][B-1]; for (int i=x;i&lt;=min(y,r[A]);++i)&#123; if (!((++cnt[w[i]]+calc(A,B,w[i]))&amp;1))++res; else if (cnt[w[i]]+calc(A,B,w[i])!=1)--res; &#125; if (A!=B)&#123; for (int i=l[B];i&lt;=y;++i)&#123; if (!((++cnt[w[i]]+calc(A,B,w[i]))&amp;1))++res; else if (cnt[w[i]]+calc(A,B,w[i])!=1)--res; &#125; for (int i=l[B];i&lt;=y;++i)--cnt[w[i]]; &#125; for (int i=x;i&lt;=min(y,r[A]);++i)--cnt[w[i]]; return res;&#125;signed main()&#123; n=read(),c=read(),m=read(); for (int i=1;i&lt;=n;++i)w[i]=read(); build(); memset(cnt,0,sizeof(cnt)); for (int i=1;i&lt;=m;++i) printf("%d\n",ans=query(read(),read())); return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2864 【[USACO06JAN]树林The Grove】]]></title>
    <url>%2F2019%2F05%2F24%2F%E9%A2%98%E8%A7%A3%20P2864%20%E3%80%90%5BUSACO06JAN%5D%E6%A0%91%E6%9E%97The%20Grove%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给定一张$R\times C$的地图，并给出一个联通块和一个起点，要求从起点出发，绕联通块一圈的最短路。 $Solution:$设起点为$S$,从这个树林的第一行最左边的那个点向左连出一条射线，然后从$S$开始$bfs$，求穿越射线奇数次最后终点在$S$的最短路径即可。 以样例为例， $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3fusing namespace std;struct node&#123; int x,y,p;&#125;;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;queue&lt;node&gt;q;char s[60];int n,m,ma[60][60],dis[60][60][2],xx,yy,sx,sy,dx[]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;-1,0,1,-1,1,-1,0,1&#125;;//dis[x][y][v]表示当前bfs的坐标为(x,y),穿越射线次数的奇偶性为vinline bool across(node a,node b)&#123; if (a.x==xx&amp;&amp;a.y&lt;yy&amp;&amp;xx&gt;b.x)return 1; if (b.x==xx&amp;&amp;b.y&lt;yy&amp;&amp;xx&gt;a.x)return 1; return 0;&#125;//判断是否穿越射线void bfs()&#123; q.push((node)&#123;sx,sy,0&#125;); memset(dis,0x3f,sizeof(dis));dis[sx][sy][0]=0; while (!q.empty())&#123; node u=q.front();int x=u.x,y=u.y,p=u.p;q.pop(); for (int i=0;i&lt;8;++i)&#123; int xx=x+dx[i],yy=y+dy[i]; node v=(node)&#123;xx,yy,p&#125;; if (ma[xx][yy]==-1||xx&lt;1||yy&lt;1||xx&gt;n||yy&gt;m)continue; if (across(u,v))v.p^=1; if (dis[xx][yy][v.p]!=inf)continue; dis[xx][yy][v.p]=dis[x][y][p]+1; q.push(v); &#125; &#125;&#125;//bfssigned main()&#123; n=read(),m=read(); for (int i=1;i&lt;=n;++i)&#123; scanf("%s",s+1); for (int j=1;j&lt;=m;++j) if (s[j]=='.')ma[i][j]=1; else if (s[j]=='*')ma[sx=i][sy=j]=1; else&#123;if (!xx)xx=i,yy=j;ma[i][j]=-1;&#125; &#125; bfs(); printf("%d",dis[sx][sy][1]); return 0;&#125;]]></content>
      <tags>
        <tag>奇技淫巧</tag>
        <tag>射线法</tag>
        <tag>$bfs$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3702 【[SDOI2017]序列计数】]]></title>
    <url>%2F2019%2F05%2F19%2F%E9%A2%98%E8%A7%A3%20P3702%20%E3%80%90%5BSDOI2017%5D%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[很显然，要求的方案数可以转化为所有方案数减去不含质数的方案数 对于所有方案，设$f_{i,j}$表示前$i$个数$mod~p$等于$j$的方案数 $f_{i,j}=\sum\limits_{k=1}^{m}f_{i-1,((j-k)\%p+p)\%p}$ 对于不含质数的方案，我们只需先预处理$cnt_i$表示$1$~$m$中$\%p==i$的合数的个数，设$g_{i,j}$表示前$i$个数$mod~p$等于$j$且没有质数的方案数。 $g_{i,j}=\sum\limits_{k=0}^{p-1} cnt_{((j-k)\%p+p)\%p}$ 然后发现这两个东西显然都可以用矩阵快速幂优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define ll long long#define mod 20170408#define M 20000070#define re registerusing namespace std;bool f[M];int cnt[M],pre[7000000],tot,n,m,p,ans;inline void add(int &amp;a,int b)&#123; a+=b; while (a&gt;=mod)a-=mod;&#125;struct node&#123; int a[207][207]; inline void init0()&#123;memset(a,0,sizeof(a));&#125; inline void init1()&#123; for (int i=0;i&lt;=p-1;++i) for (int j=0;j&lt;=p-1;++j) a[i][j]=i==j; &#125; friend node operator *(node a,node b)&#123; node res;res.init0(); for (int i=0;i&lt;=p-1;++i) for (int k=0;k&lt;=p-1;++k) for (int j=0;j&lt;=p-1;++j) add(res.a[i][k],1ll*a.a[i][j]*b.a[j][k]%mod); return res; &#125; friend node operator ^(node x,int p)&#123; node res;res.init1(); while (p)&#123; if (p&amp;1)res=res*x; x=x*x; p&gt;&gt;=1; &#125; return res; &#125;&#125;t,A;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;void init()&#123; f[1]=1; for (int i=2;i&lt;=m;++i)&#123; if (!f[i])pre[++tot]=i,--cnt[i%p]; for (int j=1;j&lt;=tot&amp;&amp;i*pre[j]&lt;=m;++j)&#123; f[i*pre[j]]=1; if (i%pre[j]==0)break; &#125; &#125;&#125;signed main()&#123;// freopen("dodo.in", "r", stdin); freopen("dodo.out", "w", stdout); n=read();m=read();p=read(); for (int i=1;i&lt;=m;++i)++cnt[i%p]; init();t.init0(); for (re int i=0;i&lt;=p-1;++i) for (re int j=0;j&lt;=p-1;++j)&#123; int d=((j-i)%p+p)%p; if (d==0)d=p;//特判，因为序列中的数都是不超过mm的正整数 if (m&gt;=d)t.a[i][j]=(m-d)/p+1; &#125; t=t^n;int res=t.a[0][0]; for (int i=0;i&lt;=p-1;++i) for (int j=0;j&lt;=p-1;++j)&#123; int d=((j-i)%p+p)%p;//余数 t.a[i][j]=cnt[d]; &#125; t=t^n; cout&lt;&lt;((res-t.a[0][0])%mod+mod)%mod&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4008 【[NOI2003]文本编辑器】]]></title>
    <url>%2F2019%2F05%2F19%2F%E9%A2%98%E8%A7%A3%20P4008%20%E3%80%90%5BNOI2003%5D%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[块状链表模板题，但出奇的恶心 由于一些操作会产生或删去一些块，所以对于块的产生与删去，块的编号用内存池分配 先给出几个操作，添加块($add$),查询属于哪个块($belong$),分裂($split$),合并($merge$)，具体细节看代码分析. 下面对题目给的操作进行分析 $1.Move~k$ 将光标移动到第 $k$个字符之后直接移动即可1pos=read(); $2.Insert~n~s$ 在光标处插入长度为$n$的字符串$s$，光标位置不变将插入串分块，最后一块(即剩余块,唯一的一块长度不一定是$size$的块)与它后面那一块判断一下，如果长度相加后$&lt;size$,那么就合并. 并且我们很可能在块内插入，那我们就要将这个块从插入位置$split$,然后进行插入。 $3.Delete~n$ 删除光标后的n个字符，光标位置不变先将两端所在的块分裂，然后直接删除，并且对两端分类出的块长度和进行判断，如果$&lt;size$，就进行$merge$操作。 $4.Get~n$ 输出光标后的$n$个字符，光标位置不变只需把左边块和右边块的需要部分给截出来，与中间完整的块拼在一起输出即可 $5.Prev$ 光标前移一个字符直接移动即可1--pos; $6.Next$ 光标后移一个字符直接移动即可1++pos; $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 100007using namespace std;struct node&#123; int nx,size; char s[4500];&#125;t[9000];char ans[8000000];int cnt=1,tot,pos,pool[800000];const int size=2007;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline int mod()&#123;return pool[++cnt];&#125;inline void del(int x)&#123;pool[cnt--]=x;&#125;//动态分配和回收内存池void add(int x,int y,int len,char *s)&#123;//在编号为x的块后面加一个编号为y的块 t[y].nx=t[x].nx;t[y].size=len; memcpy(t[y].s,s,sizeof(t[y].s)); t[x].nx=y;&#125;inline int belong(int &amp;k)&#123;//查询属于哪个块 int p=1; while (p&amp;&amp;k&gt;t[p].size)k-=t[p].size,p=t[p].nx; return p;&#125;void split(int x,int y)&#123;//将第x个块从y处分裂 if (!x||y==t[x].size)return;//如果当前块不存在或从块中最后一个开始分割是没有意义的 add(x,mod(),t[x].size-y,t[x].s+y);//t[x].s+y就相当于截去了t[x].s[1~(y-1)] t[x].size=y;&#125;void merge(int x,int y)&#123;//合并x和y，把y接在x的后面,然后把y删除 memcpy(t[x].s+t[x].size,t[y].s,t[y].size); t[x].size+=t[y].size;t[x].nx=t[y].nx;del(y);&#125;void ins(int len,char *s)&#123; int k=pos,now=belong(k),w=now; split(now,k);int sum,nx; for (sum=0;sum+size&lt;=len;sum+=size)&#123; add(now,nx=mod(),size,s+sum); now=nx; &#125; if (len-sum&gt;0)&#123;//如果剩余块的大小大于0 add(now,nx=mod(),len-sum,s+sum); if (t[now].size+t[nx].size&lt;size&amp;&amp;nx) merge(now,nx); &#125; if (t[w].size+t[t[w].nx].size&lt;size&amp;&amp;t[w].nx) merge(w,t[w].nx);&#125;void dele(int len)&#123; int k=pos,now=belong(k); split(now,k); int i; for (i=t[now].nx;t[i].size&lt;len&amp;&amp;i;i=t[i].nx) len-=t[i].size; split(i,len); for (int j=t[now].nx;j!=t[i].nx;j=t[now].nx) t[now].nx=t[j].nx,del(j); int q=t[i].nx; while (t[now].size+t[q].size&lt;size&amp;&amp;q)merge(now,q),q=t[q].nx;&#125;void print(int len)&#123; int k=pos; int now=belong(k); int nx=t[now].nx; int l=min(len,t[now].size-k); memcpy(ans,t[now].s+k,l); while (l+t[nx].size&lt;=len&amp;&amp;nx)&#123; memcpy(ans+l,t[nx].s,t[nx].size); l+=t[nx].size;nx=t[nx].nx; &#125; if (len-l&gt;0&amp;&amp;nx) memcpy(ans+l,t[nx].s,len-l); ans[len]='\0'; printf("%s\n",ans);&#125;char s[8000000];inline char gc()&#123; char ch=getchar(); while (ch!='M'&amp;&amp;ch!='I'&amp;&amp;ch!='D'&amp;&amp;ch!='G'&amp;&amp;ch!='P'&amp;&amp;ch!='N')ch=getchar(); return ch;&#125;signed main()&#123; int T=read(); for (int i=1;i&lt;=2e5+7;++i)pool[i]=i; while (T--)&#123; char ch=gc(); if (ch=='M')&#123;//将光标移动到第 k个字符之后 pos=read(); &#125;else if (ch=='I')&#123;//在光标处插入长度为n的字符串s，光标位置不变 int n=read(); for (int i=0;i&lt;n;++i)&#123; s[i]=getchar(); if (s[i]&lt;32||s[i]&gt;126)--i; &#125; ins(n,s); &#125;else if (ch=='D')&#123;//删除光标后的n个字符 dele(read()); &#125;else if (ch=='G')&#123;//输出光标后的n个字符 print(read()); &#125;else if (ch=='P')&#123; --pos; &#125;else&#123; ++pos; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
        <tag>块状链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2325 【[SCOI2005]王室联邦】]]></title>
    <url>%2F2019%2F05%2F19%2F%E9%A2%98%E8%A7%A3%20P2325%20%E3%80%90%5BSCOI2005%5D%E7%8E%8B%E5%AE%A4%E8%81%94%E9%82%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[我们可以考虑这样一种构造方法： 我们$dfs$整棵树，处理当前节点$u$时，将其子节点进行分块，如果需要进行分块的节点数不能整除块的大小，则将未被分块的子节点与$u$分在同一个块。 枚举$u$的每个子节点$v$，递归处理子树后，将每个子节点返回的未被分块的节点添加到集合$S$中，一旦$\vert S\vert\geqslant size$就把$S$作为一个新的块并将$u$作为省会，然后清空$S$并继续枚举$v$。 处理完所有子树后，将$u$也加入到集合$S$中，此时在$S$中的节点为未被分块的节点，将被返回到上一层，显然$S$的大小最大为$size$,$size-1$个子树节点$+u$节点本身。 由于返回的集合的大小最大为$size$，对于一个子树会对集合最多增加$B-1$个节点，那么每个块的大小最大为$2B-1,$满足条件。 在$dfs$结束后，集合$S$中可能还有节点（最多有$B$个），那么我们把这$ B$个节点并入最后一个块（以根节点为省会的最后一个块，块的大小最大为 $2B-1$）中，那么这个块的大小最大为$3B-1$，符合条件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 100007using namespace std;struct node&#123; int to,next;&#125;e[N];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt,top,head[N],sh[N],K,col[N],st[N],n,B;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; int now=top; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs(v,u); if (top-now&gt;=B)&#123; sh[++K]=u; while (top&gt;now)col[st[top--]]=K; &#125; &#125; st[++top]=u;&#125;signed main()&#123; n=read(),B=read(); for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; dfs(1,0); if (n==B)sh[++K]=1; while (top)col[st[top--]]=K; printf("%d\n",K); for (int i=1;i&lt;=n;++i)printf("%d ",col[i]);puts(""); for (int i=1;i&lt;=K;++i)printf("%d ",sh[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3449 【[POI2006]PAL-Palindromes】]]></title>
    <url>%2F2019%2F05%2F12%2F%E9%A2%98%E8%A7%A3%20P3449%20%E3%80%90%5BPOI2006%5DPAL-Palindromes%E3%80%91%2F</url>
    <content type="text"><![CDATA[题意：给出$n$个回文串$s_1, s_2, \cdots,s_n$求如下二元组$(i, j)$的个数$s_i + s_j$仍然是回文串 对于每个字符串进行$hash$,判断连接形成回文串只需判断$a+b$是否$=$$b+a$即可 注:这里的$x+y$指的是将字符串$y$连到字符串$x$后面去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3f#define N 2000002#define hash HASH#define mod 1000000007#define base 131using namespace std;int n,m,hash[N],len[N],ch[N][26],tot,po[N],w[N],ans;string s[N];int calc(string s)&#123; int res=0,len=s.length(); for (int i=0;i&lt;len;++i)res=(res*base+s[i]-'a')%mod; return res;&#125;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;void build(string s,int id)&#123; int len=s.length(),now=0; for (int i=0;i&lt;len;++i)&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot; now=ch[now][v]; &#125; w[now]=id;&#125;void query(string ss,int id)&#123; int le=ss.length(),now=0; for (int i=0;i&lt;le;++i)&#123; int v=ss[i]-'a'; now=ch[now][v]; if (w[now]&amp;&amp;w[now]!=id)&#123; if ((hash[w[now]]*po[len[id]]%mod+hash[id])%mod==(hash[id]*po[len[w[now]]]%mod+hash[w[now]])%mod)&#123; ++ans; &#125; &#125; &#125;&#125;signed main()&#123; n=read();po[0]=1; for (int i=1;i&lt;=200000;++i)po[i]=po[i-1]*base%mod; for (int i=1;i&lt;=n;++i)&#123; len[i]=read();cin&gt;&gt;s[i]; build(s[i],i); hash[i]=calc(s[i]); &#125; for (int i=1;i&lt;=n;++i) query(s[i],i); cout&lt;&lt;ans*2+n; return 0;&#125;]]></content>
      <tags>
        <tag>$hash$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4683 【[IOI2008] Type Printer 打印机】]]></title>
    <url>%2F2019%2F05%2F12%2F%E9%A2%98%E8%A7%A3%20P4683%20%E3%80%90%5BIOI2008%5D%20Type%20Printer%20%E6%89%93%E5%8D%B0%E6%9C%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[给出这么多字符串，显然就是要你建出字典树 在建完字典树后，我们手动模拟一下，发现树上兄弟的遍历先后其实是没有关系的(只所有兄弟是连着一起遍历的就行了)(即$dfs$序)， 唯一不同的就是最后遍历的一个单词不用删，所以我们考虑让最长的单词最后遍历，于是考虑在最长单词的所有字母上加上标记，最后走。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 500007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ch[N][26],tot,book[N],w[N],ans,n;char s[N][26];void build(char *s)&#123; int len=strlen(s),now=0; for (int i=0;i&lt;len;++i)&#123; int v=s[i]-'a'; if (!ch[now][v])ch[now][v]=++tot; now=ch[now][v]; &#125; w[now]=1;&#125;void work(char *s)&#123; int len=strlen(s),now=0; for (int i=0;i&lt;len;++i)&#123; int v=s[i]-'a'; now=ch[now][v]; book[now]=1; &#125;&#125;void query(int now,int flag)&#123; if (w[now])&#123;++ans;if (flag)puts("P");&#125; int t=-1; for (int i=0;i&lt;26;++i) if (ch[now][i]) if (!book[ch[now][i]])&#123; ++ans;if (flag)printf("%c\n",i+'a'); query(ch[now][i],flag); ++ans;if (flag)puts("-"); &#125;else t=i; if (t!=-1)&#123; ++ans; if (flag)printf("%c\n",t+'a'); query(ch[now][t],flag); &#125;&#125;signed main()&#123; n=read();int mx=0,num; for (int i=1;i&lt;=n;++i)&#123; scanf("%s",s[i]); build(s[i]);int len=strlen(s[i]); if (len&gt;mx)&#123;mx=len;num=i;&#125; &#125; work(s[num]); query(0,0); printf("%d\n",ans); query(0,1); return 0;&#125;]]></content>
      <tags>
        <tag>$Trie$树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇技淫巧杂记]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[奇技淫巧杂记$1.$描述给定两个数$n,m,$其中$m$是一个素数。将$n(0\leqslant n\leqslant 2^{31})$的阶乘分解质因数，求其中有多少个$m$。 做法： $while(n/m) ans+=n/m,n/=m;$ $ans$即为答案]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2403 【[SDOI2010]所驼门王的宝藏】]]></title>
    <url>%2F2019%2F05%2F01%2F%E9%A2%98%E8%A7%A3%20P2403%20%E3%80%90%5BSDOI2010%5D%E6%89%80%E9%A9%BC%E9%97%A8%E7%8E%8B%E7%9A%84%E5%AE%9D%E8%97%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Tarjan+toposort$的经典套路题吧，$Tarjan+toposort$应该一眼就能看出来，但是发现对于第$1$,$2$种边连边显然会超时，这里用了一种比较无脑简单的方法(像我这种小蒟蒻都能想出来肯定简单啊)，这里以第$1$种为例(第二种类比一下就可以了) 若有多个第一种门在某一行，那么这些门都是可以互相到达的，但是我们两两之间连$n^2$的边显然很愚蠢，只需要连成一个环即可(第$1$个连第$2$个，第$2$个连第$3$个，最后一个连第$1$个)，在这个环上的其他所有点，只需从环上任意一点连出去即可(像对于网络流时经常用的建一个虚点连接两边优化$n^2$连边的方法应该也可以) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 1003000#define mod 19260817#define pb push_backusing namespace std;struct node1&#123; int u,to,next;&#125;e[N&lt;&lt;4];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;unordered_map&lt;ll,int&gt;mp,ed;vector&lt;int&gt;x[N],y[N];int dx[]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;-1,0,1,-1,1,-1,0,1&#125;;int opt[N],R,C,m,u[N],v[N],cnt=1,head[N],dfn[N],low[N],ans,f[N],st[N],top,num,col,in[N],w[N],color[N];inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].u=u; e[cnt].next=head[u]; head[u]=cnt;&#125;inline ll h(ll x,ll y)&#123; return 1ll*(x-1)*C+1ll*y;&#125;inline ll ee(ll x,ll y)&#123; return 1ll*(x-1)*col+1ll*y;&#125;void Tarjan(int u)&#123; dfn[u]=low[u]=++num; st[++top]=u; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (!dfn[v])&#123; Tarjan(v); low[u]=min(low[u],low[v]); &#125;else if (!color[v]) low[u]=min(low[u],dfn[v]); &#125; if (low[u]==dfn[u])&#123; ++col; do&#123; ++w[col];color[st[top--]]=col; &#125;while (st[top+1]!=u); &#125;&#125;void topo()&#123; queue&lt;int&gt;q; for (int i=1;i&lt;=col;++i)if (!in[i])q.push(i),f[i]=w[i]; while (!q.empty())&#123; int u=q.front();q.pop(); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; --in[v]; f[v]=max(f[v],f[u]+w[v]); if (!in[v])q.push(v); &#125; &#125;&#125;signed main()&#123; m=read(),R=read(),C=read(); for (int i=1;i&lt;=m;++i)&#123; u[i]=read(),v[i]=read(),opt[i]=read(); mp[h(u[i],v[i])]=i; x[u[i]].pb(i); y[v[i]].pb(i); &#125; for (int i=1;i&lt;=R;++i)&#123; int st=0,cnt=0; while (st&lt;x[i].size()&amp;&amp;opt[x[i][st]]!=1)++st;int last; if (st!=x[i].size())&#123;++cnt;last=x[i][st];&#125; if (cnt)for (int j=0;j&lt;st;++j)add(last,x[i][j]); for (int j=st+1;j&lt;x[i].size();++j) if (opt[x[i][j]]==1)&#123; add(last,x[i][j]); last=x[i][j];++cnt; &#125;else add(x[i][st],x[i][j]); if (cnt&gt;1)add(last,x[i][st]); &#125; for (int i=1;i&lt;=C;++i)&#123; int st=0,cnt=0; while (st&lt;y[i].size()&amp;&amp;opt[y[i][st]]!=2)++st;int last; if (st!=y[i].size())&#123;++cnt;last=y[i][st];&#125; if (cnt)for (int j=0;j&lt;st;++j)add(last,y[i][j]); for (int j=st+1;j&lt;y[i].size();++j) if (opt[y[i][j]]==2)&#123; add(last,y[i][j]); last=y[i][j];++cnt; &#125;else&#123;add(y[i][st],y[i][j]);&#125; if (cnt&gt;1)add(last,y[i][st]); &#125; for (int i=1;i&lt;=m;++i) if (opt[i]==3) for (int ii=0;ii&lt;8;++ii)&#123; int x=u[i]+dx[ii],y=v[i]+dy[ii]; if (!mp[h(x,y)])continue; add(i,mp[h(x,y)]); &#125; for (int i=1;i&lt;=m;++i) if (!dfn[i]) Tarjan(i); int tot=cnt;memset(head,0,sizeof(head));cnt=0; for (int i=1;i&lt;=tot;++i)&#123; int u=e[i].u,v=e[i].to; if (color[u]!=color[v])&#123; if (ed[ee(color[u],color[v])])continue; add(color[u],color[v]); ed[ee(color[u],color[v])]=1; ++in[color[v]]; &#125; &#125; topo(); for (int i=1;i&lt;=col;++i) ans=max(ans,f[i]); cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>连边优化</tag>
        <tag>$Tarjan$</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2151 【[SDOI2009]HH去散步】]]></title>
    <url>%2F2019%2F05%2F01%2F%E9%A2%98%E8%A7%A3%20P2151%20%E3%80%90%5BSDOI2009%5DHH%E5%8E%BB%E6%95%A3%E6%AD%A5%E3%80%91%2F</url>
    <content type="text"><![CDATA[如果没有限制条件不能沿着刚走过的道路走回，那就是裸的矩阵快速幂优化$DP$了。 但是，这个限制条件使得无论怎么构造矩阵，普通的矩阵快速幂不能符合要求 这时，我们就要向别的方向想了，普通的矩阵快速幂是点之间转移，那我们能不能边与边之间转移呢$？$ 只需要在矩阵中将除了当前边与当前边的反向边以外的所有边对的权值都赋为$1$,然后进行矩阵快速幂即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define int long long#define mod 45989using namespace std;struct ed&#123; int u,v;&#125;e[393939];int cnt,ans,n,m,t,A,B;struct node&#123; int a[207][207]; inline void init0()&#123;memset(a,0,sizeof(a));&#125; inline void init1()&#123; memset(a,0,sizeof(a)); for (int i=0;i&lt;=n;++i) for (int j=0;j&lt;=n;++j) a[i][j]=i==j; &#125; friend node operator *(node a,node b)&#123; node res;res.init0(); for (int i=0;i&lt;=n;++i) for (int k=0;k&lt;=n;++k) for (int j=0;j&lt;=n;++j)&#123; res.a[i][k]=(res.a[i][k]+a.a[i][j]*b.a[j][k]%mod)%mod; &#125; return res; &#125; friend node operator ^(node x,int p)&#123; node res;res.init1(); while (p&gt;0)&#123; if (p&amp;1)res=res*x; x=x*x; p&gt;&gt;=1; &#125; return res; &#125;&#125;f;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;signed main()&#123;// freopen("desire.in","r", stdin); freopen("desire.out", "w", stdout); cnt=read(),m=read(),t=read(),A=read(),B=read(); f.init0();n=-1; for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); e[++n]=(ed)&#123;u,v&#125;; e[++n]=(ed)&#123;v,u&#125;; &#125; for (int i=0;i&lt;=n;++i) for (int j=0;j&lt;=n;++j) if ((i!=j)&amp;&amp;((i^1)!=j)&amp;&amp;(e[i].v==e[j].u)) f.a[i][j]=1; f=f^(t-1); for (int i=0;i&lt;=n;++i) if (e[i].u==A) for (int j=0;j&lt;=n;++j) if (e[j].v==B) ans=(ans+f.a[i][j])%mod; printf("%d",ans);&#125;]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF878C Tournament]]></title>
    <url>%2F2019%2F05%2F01%2F%E9%A2%98%E8%A7%A3%20CF878C%20Tournament%2F</url>
    <content type="text"><![CDATA[我们考虑两个选手之间的关系，如果一个选手能在任何一项运动中战胜对手，那么就从他自身向对手连一条有向边。这样显然会出现很多环，于是可以大力缩点，将整张图缩成一个$DAG$（实际实现中会变为一条链）。那么显然入度为零的环中包含的点数即为最后可能成为冠军的人数。 这里缩点的技巧就是这道题的关键，由于题目要求动态插入点，那么$tarjan$就不再适合了。于是我们可以选择$set$作为容器，把上述判断的条件重载成小于号，在$set$中用$find$查找（这里的$find$查找完全是根据$”&lt;”$来的,即对于两个参数$a,b$,判断$==$的操作相当于判断$(!(a&lt;b))$&amp;&amp;$(!(b&lt;a)),)$是否有与当前选手可以合并的，并进行合并操作。合并后，我们的节点（即一个环）记录的是环中每项运动所有选手中的最大值和最小值，这样可以方便地进行环与环之间的比较。 将所有点插入后，答案即为$set$中的最后一个元素的大小，因为我们重载了小于号，所以最后一个节点都是“大于”之前的点的，在缩点后的图中一定是入度为$0$。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3fusing namespace std;int n,k;struct node&#123; int mx[15],mn[15],size; friend bool operator &lt;(node a,node b)&#123; for (int i=1;i&lt;=k;++i) if (a.mx[i]&gt;b.mn[i])return 0; return 1; &#125;&#125;lxy;set&lt;node&gt;s;set&lt;node&gt;::iterator it;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int main()&#123; n=read(),k=read(); for (int i=1;i&lt;=n;++i)&#123; lxy.size=1; for (int j=1;j&lt;=k;++j)lxy.mx[j]=lxy.mn[j]=read(); it=s.find(lxy); while (it!=s.end())&#123; lxy.size+=(*it).size; for (int j=1;j&lt;=k;++j) lxy.mx[j]=max(lxy.mx[j],(*it).mx[j]),lxy.mn[j]=min(lxy.mn[j],(*it).mn[j]); s.erase(it);it=s.find(lxy); &#125; s.insert(lxy); printf("%d\n",(*--s.end()).size); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>$STL$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流杂记(待填坑,可能咕咕)]]></title>
    <url>%2F2019%2F04%2F30%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[求二分图最大匹配方案时只需求出所有反向边中边权大于0的即可 二分图匹配只需源点连向所有左侧的点，边权为inf，所有右侧的点连汇点，边权也为$inf$，两侧的点的连边即是原图上的连边，边权为$1$。求最大流即可 证明：我们求最大流等于求最小割，因为两侧的点与源汇点的连边权都为$inf$，所以割边只能是 拆点最大流模型的一般建模思路是运用流的容量限制，使得题目中的约束得以满足，有时还需使用一些特殊的方法（如拆点）来满足题目的特别约束。 拆点的主要应用1.例如一件物品只能用有限次，但是如果不拆点普通建模跑网络流很可能会导致这个点被超过限制次数的流量经过，使答案出错，所以如果将这个点拆成两个，设为$i_1$ , $i_2$,原入边连 $i_1$，原出边连 $i_2$,$i_1$与$i_2$之间连边权为限制次数的边即可。正确性显然。 例题1:P1231 教辅的组成 例题2:P1345 [USACO5.4]奶牛的电信(拆点解决最小割点问题) 例题: P1402 酒店之王 二分图最大匹配的三个定理 1:最大匹配数 + 最大独立集 =$n$(点数) 2:二分图的最小覆盖数 = 最大匹配数 3:最小路径覆盖 = 最大独立集 最大独立集是指求一个二分图中最大的一个点集，该点集内的点互不相连。 最小顶点覆盖是指 在二分图中，用最少的点，让所有的边至少和一个点有关联。 最小路径覆盖是指一个不含圈的有向图G 中，G的一个路径覆盖是一个其结点不相交的路径集合P，图中的每一个结点仅包含于P 中的某一条路径。路径可以从任意结点开始和结束，且长度也为任意值，包括0. 在二分图匹配时，如果有很多个条件都不满足才能连边，跑最大匹配是错误的，]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流——最小割求最大权闭合子图]]></title>
    <url>%2F2019%2F04%2F30%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E5%89%B2%E6%B1%82%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[有一个有向图，每一个点都有一个权值（可以为正或负或$0$），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。 如下图： 能选的子图有$Ø$(即不选),{$4$},{$3,4$},{$2,4$},{$1,2,3,4$},它们的权值分别为$0,-1,5,-6,4.$所以最大权闭合子图为{$3,4$}，权值为$5$. 解法这个问题可以转化为最小割问题，用网络流解决。 从源点$s$向每个正权点连一条容量为权值的边，每个负权点向汇点$t$连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。 求它的最小割，割掉后，与源点s连通的点构成最大权闭合子图，权值为（正权值之和$-$最小割）。 如何理解割掉一条边的含义由于原图的边都是无穷大，那么割边一定是与源点$s$或汇点$t$相连的。 割掉$s$与$i$的边，表示不选择$i$点作为子图的点； 割掉$i$与$t$的边，表示选择$i$点为子图的点。 如果$s$与$i$有边，表示$i$存在子图中； 如果$i$与$t$有边，表示$i$不存在于子图中。 合法性只有$s$与$t$不连通时，才能得到闭合子图。 如果$s$与$t$连通，则存在点$i,j$，使得$s$到$i$有边，$i$到$j$连通,$j$到$t$有边，所以$j$一定是$i$的后继，但选择了$i$，没有选择$j$，不是闭合子图。 如果$s$与$t$不连通，选择了正权点$i$，一定选择了$i$后继中的所有负权点。设$j$是$i$的后继中的正权点，则割掉$s$到$j$的边是没有意义的，最小割不会割掉它，则$j$一点被选中，所以$i$的所有后继都被选中，符合闭合图的定义。 最优性最小割=(不选的正权之和+要选的负权绝对值之和） 最大权闭合子图=（正权之和-不选的正权之和-要选的负权绝对值之和）=正权值和-最小割 因为正权值和，是定值，而最小割保证值最小，所以最大权闭合子图一定最优。 例题洛谷P3410 拍照 POJ2987_Firing P4174 [NOI2006]最大获利 拓展要求输出方案枚举每个点的$dep$，如果$dep&lt;inf$，那么则是方案内的点 因为那种无论怎么买花费$&gt;$收入，这样的购买有一个特点，因为它不能供给需求，所以源点到它的残流一定是$0$，就是说不管是正向边还是反向边都是$0$，同样的那些可以供给的，源点到它的残留一定大于$0$，也就是正向边或者反向边大于$0$，说明做这个购买能赚钱。 所以在最后一遍$bfs$时，边权为$0$的边是不会走的，也就是说$bfs$时只会走边权大于$0$的边，所以走过的每一个点都是方案中的点，因为只有走过的点$dep$才会小于$inf$，所以只需要找出$dep&lt;inf$的点即可 例题P2762 太空飞行计划问题]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 4.21模拟赛T4]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%204.21%E6%A8%A1%E6%8B%9F%E8%B5%9BT4%2F</url>
    <content type="text"><![CDATA[$Description$$Ahri$得到了一个$(h+1) × (w+1)$的巧克力，这意味着她横着最多可以切$h$刀，竖着最多可以切$w$刀。 她想总共切$K$刀，每刀要么竖着切要么横着切，如果竖着切了$i$刀，横着切了$j$刀，会得到$(i+1) × (j+1)$个巧克力，定义一个切$K$刀的方案的代价是每一刀切完后巧克力个数之和，假设每刀切的位置是随机选择的（即剩余能切的位置等概率随机选一个），请你求出期望代价，对$1e9+7$取模 $Solution:$做法一:参考xjh大佬的博客 我们把答案的每一部分分开来考虑 每一部分对答案的贡献就是这一部分能算进答案里的方案数$×$这部分的价值 显然这里的每一部分就指的是横着切$i$刀，竖着切$j$刀 这一部分的价值横着切i刀，竖着切j刀的价值很好求，就是$(i+1)(j+1)$ 无论怎么切，这一部分的价值都是$(i+1)(j+1)$ 难点在于求这一部分能算进答案里的方案数 我们把所有方案都画出来，就会清楚的发现怎么求了 方案数就是能走到这个状态的方案数$×$这个状态走到结束状态的方案数(简称来的状态和去的状态) 来的状态就是$A^i_h\times A^j_w\times$(不同的切横切竖的顺序),$A^i_h\times A^j_w$比较好理解，但对(不同的切横切竖的顺序) 不知道怎么求 我们稍微转换一下：有$i$个$0$(相当于横切)，$j$个$1$(相当于纵切)，问用它们构成一个长为$i+j$的$01$串的方案数，答案就相当于有$i+j$个位置，选$i$个位置放$0$,剩余位置放$1$的方案数，即$C^{i}_{i+j}$。 去的状态就是$A^{k-i-j}_{n-i-j}$ 贴上$xjh$大佬的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod=1e9+7;const int N=10005;int h,w,k,n,ans,jc[N],inv[N];int add(int a,int b)&#123; a+=b; if(a&gt;=mod)a-=mod; return a;&#125;int kuai(int a,int b)&#123; int res=1; while(b) &#123; if(b%2==1)res=res*a%mod; a=a*a%mod; b=b/2; &#125; return res;&#125;signed main()&#123; freopen("ahri.in","r",stdin); freopen("ahri.out","w",stdout); jc[0]=1;inv[0]=inv[1]=1; for(int i=1;i&lt;=10000;i++)jc[i]=jc[i-1]*i%mod; for(int i=2;i&lt;=10000;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod; for(int i=2;i&lt;=10000;i++)inv[i]=inv[i]*inv[i-1]%mod; scanf("%lld%lld%lld",&amp;h,&amp;w,&amp;k); n=h+w; for(int i=0;i&lt;=h;i++) for(int j=0;j&lt;=w;j++) &#123; if(i==0&amp;&amp;j==0)continue; if(i+j&gt;k)break; //ans=add(ans,a[h][i]*a[w][j]%mod*c[i+j][i]%mod*a[n-i-j][k-i-j]%mod*(i+1)%mod*(j+1)%mod); ans=add(ans,jc[h]*inv[h-i]%mod*jc[w]%mod*inv[w-j]%mod*jc[i+j]%mod*inv[i]%mod*inv[j]%mod*jc[n-i-j]%mod*inv[n-k]%mod*(i+1)%mod*(j+1)%mod); &#125; cout&lt;&lt;(ans*kuai(jc[n]%mod*inv[n-k]%mod,mod-2)%mod+mod)%mod; return 0;&#125; 做法二:概率期望$DP$(菜鸡我的做法) 下文中读入的$h,w$,分别设为$n,m$ 设$g[i][j]$为切了$i$刀，有$j$刀是横向切的的期望,纵向切的刀数$k$显然$=i-j$ 显然$g[i][j]=\sum f*val$,此处$f$表示其中一种切法的概率，$val$这种切法能得到的价值和。 我们去掉$val$,设$f[i][j]=\sum f$ 对于$f$数组的转移显然不难,$f[i][j]=f[i-1][j]\times \dfrac{m-(k-1)}{n+m-i}+f[i-1][j]\times \dfrac{n-(j-1)}{n+m-i}$ 但是$g$数组的转移就不简单了，我们考虑当前的$g[i][j]$如何从上一个状态转移过来。 之前说过$g[i][j]=\sum f*val$ $\qquad \qquad \qquad $$=f[i][j]\times (j+1)\times(k+1)$ 我们假设 就这样，式子就推出来了 $ans=\sum\limits_{i=1}^{n} g[K][i]$ 答案的寻找范围显然 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define int long long#define re register#define mod 1000000007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int g[2][5005],f[2][5005],ans,inv[10009];signed main()&#123; freopen("ahri.in", "r", stdin); freopen("ahri.out", "w", stdout); int n=read(),m=read(),k=read();inv[0]=inv[1]=1; for (int i=2;i&lt;=10007;++i)inv[i]=(mod-mod/i)*inv[mod%i]%mod; f[1][1]=n*inv[n+m]%mod;f[1][0]=m*inv[n+m]%mod;//概率 g[1][1]=2*n%mod*inv[n+m]%mod;g[1][0]=2*m%mod*inv[n+m]%mod;//期望 for (int i=2;i&lt;=k;++i)&#123; int now=i&amp;1;//滚存 memset(f[now],0,sizeof(f[now])); memset(g[now],0,sizeof(g[now])); for (int j=0;j&lt;=min(i,n);++j)&#123; if (i-j&gt;m)continue; int k=i-j; //考虑最后一刀横向切还是纵向切 int A=0,B=0; if (k!=0)&#123;//最后一刀纵向切 A=f[now^1][j]*(m-(k-1))%mod*inv[n+m-i+1]%mod; g[now][j]+=g[now^1][j]*(m-(k-1))%mod*inv[n+m-i+1]%mod+(j+1)*(k+1)%mod*A%mod; &#125; f[now][j]%=mod;g[now][j]%=mod; if (j!=0)&#123;//最后一刀横向切 B=f[now^1][j-1]*(n-(j-1))%mod*inv[n+m-i+1]%mod; g[now][j]+=g[now^1][j-1]*(n-(j-1))%mod*inv[n+m-i+1]%mod+(j+1)*(k+1)%mod*B%mod; &#125; f[now][j]=A+B;//概率相加 f[now][j]%=mod;g[now][j]%=mod; &#125; &#125; for (int i=0;i&lt;=n;++i) ans=(ans+g[k&amp;1][i])%mod;//统计答案 cout&lt;&lt;ans&lt;&lt;endl;&#125; 其他做法此外还有复杂度跟我的做法一样，但实现更简单一些的$DP$; 并且用$FFT$优化$xjh$大佬的$O(nlogn)$做法和一种$O(logK+logn+logm)$的神奇做法。]]></content>
      <tags>
        <tag>思维题</tag>
        <tag>概率期望$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 51nod有限背包计数问题]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%2051nod%E6%9C%89%E9%99%90%E8%83%8C%E5%8C%85%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接 很考验对背包的理解 对于$1$~$sqrt(n)$与$(sqrt(n)+$$1)$~$n,$我们可以用NOIP2001数的划分的类似做法，分别处理，显然$1$~$sqrt(n)$是个多重背包问题，$(sqrt(n)+$$1)$~$n$是个完全背包问题 对于$1$~$sqrt(n)$，我们可以用总方案数减去不合法的方案数(具体见代码注释)，并利用滚存优化空间 对于$(sqrt(n)+$$1)$~$n,$我们可以用NOIP2001数的划分的类似做法，将划分分成两种类型，进行$dp$转移 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3fusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int f[2][393939],g[319][100007],ans;signed main()&#123;// freopen("game.in", "r", stdin); freopen("game.out", "w", stdout); int n=read(),mod=read(); f[0][0]=1;//选0个的方案数为1 int sq=sqrt(n),now=0; for (int i=1;i&lt;=sq;++i)&#123; now^=1;//滚存 for (int j=0;j&lt;=n;++j)&#123; f[now][j]=f[now^1][j];//加上i-1的方案种数 if (j&gt;=i)f[now][j]+=f[now][j-i];//完全背包方案数的递推式 if (f[now][j]&gt;=mod)f[now][j]-=mod; if (j&gt;=i*(i+1))f[now][j]=f[now][j]-f[now^1][j-i*(i+1)]+mod;//减去不符合的方案数，即不在j-i*i到j范围内的方案数 if (f[now][j]&gt;=mod)f[now][j]-=mod; &#125; &#125;//前sqrt(n)个数进行多重背包计算方案 //g[i][j]表示选了i个,而不是选到第i种，和为j的方案数，注意i的含义与f[i][j]中的i的含义不一样 //类似NOIP2001数的划分的做法,所有划分成两种：//1.包含sqrt(n)+1(即最小的数)//2.不包含sqrt(n)+1的//一个dp状态的方案数就是由这两种划分构成的//对于第一种划分，只需要单独加上一份sqrt(n)+1即可，所以划分数等于f[i-1][j-(sqrt(n)+1)];//对于第二种划分，只需要给当前每份都加上1，每份就不可能等于sqrt(n)+1了，因为最小就是sqrt(n)+1,所以划分数就等于f[i][j+i]; g[0][0]=1;//选0个，和为0的方案数为1 if (sq+1&lt;=n)g[1][sq+1]=1;//选1个sqrt(n)+1(最小值) for (int i=1;i&lt;=sq;++i)&#123; for (int j=0;j&lt;=n;++j)&#123; if (j+sq+1&lt;=n)g[i+1][j+sq+1]+=g[i][j];//第一种划分 if (g[i+1][j+sq+1]&gt;=mod)g[i+1][j+sq+1]-=mod; if (j+i&lt;=n)g[i][j+i]+=g[i][j];//第二种划分 if (g[i][j+i]&gt;=mod)g[i][j+i]-=mod; &#125; &#125; for (int i=0;i&lt;=n;++i) for (int j=0;j&lt;=sq;++j)&#123; ans+=1ll*f[now][i]*g[j][n-i]%mod;// 最后枚举多少空间给前sqrt(n)个物品(剩下空间给其它物品) if (ans&gt;=mod)ans-=mod; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF632F 【Magic Matrix】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF632F%20%E3%80%90Magic%20Matrix%E3%80%91%2F</url>
    <content type="text"><![CDATA[最小生成树： 咋一看和最小生成树一点关系都没有，但是我们设$a_{i,j}$表示$i$到$j$的边的边权为$a_{i,j}$,然后观察本题的三个条件： $1.$对于每一个$i,j,a_{i,j}=a_{j,i}$(说明是无向图) $2.$对于每个$i,a_{i,i}=0$(表示没有自环) $3.$对于每个$i,j,k$,都有$a_{i,j}\leqslant max(a_{i,k},a_{k,j})$ 第三个条件说明的就是最小生成树 我们可以设$f_{i,j}$为$i$到$j$的任意路径的最长边的最小值，可得$a_{i,j}\geqslant f_{i,j}.$ 假设一个矩阵满足条件,则$a_{i,j}\leqslant max(a_{i,k_1}~,~a_{k_1,k_2}),a_{k_1,j}\leqslant max(a_{k_1,k_2},a_{k_2,j})\cdots\cdots$ $∴a_{i,j}\leqslant max(a_{i,k_1},a_{k_1,k_2},a_{k_2,k_3},\cdots,a_{k_m,j})$ $=f_{i,j}$ 判断矩阵是否合法，就是判断图上的$i$到$j$的任意路径的最长边的最小值是否等于$a_{i,j}$. 这可以用最小生成树实现,模拟一遍$Kruskal$会更好理解，从最小的边开始加，形成环显然走已经形成的路更优，加边到形成树就保证图联通了就没必要加边了 判断合法即判断完全图中是不是任意一个生成树都是最小生成树 具体实现就是以任意一个节点(我使用$1$)为根，记录每个节点的父节点$fa$,然后找一个$y$,如下图，如果$max(a,b)&lt;c$,那么就不符合最小生成树和题目给定条件了。 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define re registerusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,a[2555][2555],vis[2555],dis[2555],fa[2555],dep[2555];int main()&#123; int n=read(); for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++)a[i][j]=read(); for(re int i=1;i&lt;=n;i++) if(a[i][i])&#123; puts("NOT MAGIC\n"); return 0; &#125; for (re int i=1;i&lt;=n;++i) for (re int j=1+i;j&lt;=n;++j) if (a[i][j]!=a[j][i])&#123; puts("NOT MAGIC"); return 0; &#125; for (re int i=0;i&lt;=n;++i)fa[i]=i,dis[i]=1e9+1e8;dis[1]=0; for (re int i=1;i&lt;=n;++i)&#123; re int pos=0; for (re int j=1;j&lt;=n;++j) if (!vis[j]&amp;&amp;dis[pos]&gt;dis[j]) pos=j; vis[pos]=1; for (re int j=1;j&lt;=n;++j) if (!vis[j]&amp;&amp;a[pos][j]&lt;dis[j]) dis[j]=a[pos][j],fa[j]=pos,dep[j]=dep[pos]+1; &#125; for (re int i=1;i&lt;=n;++i) for (re int j=1;j&lt;=n;++j)&#123; re int x=i,y=j; if (max(a[x][fa[x]],a[fa[x]][y])&lt;a[x][y]) return puts("NOT MAGIC"),0; if (max(a[x][fa[y]],a[fa[y]][y])&lt;a[x][y]) return puts("NOT MAGIC"),0; &#125; puts("MAGIC"); return 0;&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>思维题</tag>
        <tag>神仙题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 牛客练习赛6 手铐]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B6%20%E6%89%8B%E9%93%90%2F</url>
    <content type="text"><![CDATA[链接：牛客练习赛6手铐 $Description$给你一个连通无向图，保证每个点最多属于一个简单环，每个点度数最多为$3$，求这个图有多少“手铐图形个数” 其中“手铐图形个数”，定义为三元组$(x,y,S)$，其中$x$和$y$表示图上的两个点，$S$表示一条$x$到$y$的简单路径，而且必须满足： $1.x$和$y$分别在两个不同的简单环上 $2.x$所在的简单环与路径$S$的所有交点仅有$x,y$所在的简单环与路径$S$的所有交点仅有$y$。 $(x,y,S)$与$(y,x,S)$算同一个手铐 $Solution:$我们考虑把环给缩掉，缩了之后的点叫做方点，然后本来树上的点叫做圆点 缩完后变成 首先手铐两端都必须是一个方点，然后可以发现如果一条两端都是方点的路径上总共有$x$个方点(不包括两端的方点)，则这两个端点可以构成$2^{x}$个手铐（每次可以走两端） 如图这构成了4个手铐 由于无向图缩点后一定形成一棵树，我们考虑对于生成的这个树进行树形$DP$用$f[u]$表示以$u$为根的子树，到$u$构成的“一半的手铐”的数量也就是说这样的： 半手铐维护的方法就是 如果u是圆点，则$f[u]=\sum f[v]$; 如果u是方点，则$f[u]=(\sum f[v])\times 2 + 1$; 因为下面上来的每个半手铐都可以走两个方向，然后这个点也可以作为一个半手铐的端点 在跑树形$DP$时顺便统计答案。 对于每个节点$u$,我们强制它的贡献就是手铐的两端在它的两颗子树中，或是一个在子树中，一个是它自己。 对于手铐的两端在它的两颗子树中，只要算出$\frac{\sum f[v]\times(sum-f[v])}{2}$即可 当节点$u$是方点时，贡献还要$\times 2$再加上所有子树中的半手铐个数(即$u$节点与子树中半手铐匹配) $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 2003000#define mod 19260817using namespace std;struct node&#123; int to,next;&#125;e[N&lt;&lt;1];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,m,u[N],v[N],cnt=1,head[N],dfn[N],low[N],ans,f[N],st[N],top,num,col,w[N],color[N];inline int inv2()&#123;return (mod-mod/2)%mod;&#125;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void Tarjan(int u,int E)&#123; dfn[u]=low[u]=++num; st[++top]=u; for (int i=head[u];i;i=e[i].next)&#123; if (i==(E^1))continue; int v=e[i].to; if (!dfn[v])&#123; Tarjan(v,i); low[u]=min(low[u],low[v]); &#125;else if (!color[v]) low[u]=min(low[u],dfn[v]); &#125; if (low[u]==dfn[u])&#123; ++col; do&#123; ++w[col];color[st[top--]]=col; &#125;while (st[top+1]!=u); &#125;&#125;void dfs1(int u,int fa)&#123; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs1(v,u); f[u]=(f[u]+f[v]*w[u]%mod)%mod; &#125; f[u]+=w[u]==2;&#125;void dfs(int u,int fa)&#123; int res=0,sum=(w[u]==2?(f[u]-1)*inv2()%mod:f[u]); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs(v,u); res=(res+w[u]*f[v]%mod*((sum-f[v]+mod)%mod))%mod; &#125; ans=(ans+res*inv2()%mod)%mod; if (w[u]==2)ans=(ans+sum)%mod;&#125;signed main()&#123; n=read(),m=read(); for (int i=1;i&lt;=m;++i)&#123; u[i]=read(),v[i]=read(); add(u[i],v[i]);add(v[i],u[i]); &#125; for (int i=1;i&lt;=n;++i) if (!dfn[i]) Tarjan(i,0); for (int i=1;i&lt;=col;++i)w[i]=(w[i]&gt;1)+1; memset(head,0,sizeof(head));cnt=0; for (int i=1;i&lt;=m;++i) if (color[u[i]]!=color[v[i]])&#123; add(color[u[i]],color[v[i]]); add(color[v[i]],color[u[i]]); &#125; dfs1(1,0); dfs(1,0); cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>$Tarjan$</tag>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF24D 【Broken robot】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF24D%20%E3%80%90Broken%20robot%E3%80%91%2F</url>
    <content type="text"><![CDATA[设状态$f[i][j]$为从坐标$(i,j)$走到最后一行的期望 此时需要分类讨论,由于$f[n]j=0$，所以我们倒着枚举行,也可感性理解为从最后一行走到第x行 当$j=1$时，$f[i][1]=\frac{1}{3}f[i][1]+\frac{1}{3}f[i][2]+\frac{1}{3}f[i+1][1]+1$ 当$j=m$时，$f[i][m]=\frac{1}{3}f[i][m]+\frac{1}{3}f[i][m-1]+\frac{1}{3}f[i+1][m]+1$ 当$1&lt;j&lt;m$时，$f[i][j]=\frac{1}{4}f[i][j-1]+\frac{1}{4}f[i][j]+\frac{1}{4}f[i][j+1]+\frac{1}{4}f[i+1][j]+1$ 然后我们发现这个式子是有后效性的，所以要$dp+$高斯消元。 为了更好高斯消元，我们可以压掉第一维，式子中的$f[i+1]$计为数组$last$。(但我实现上还是用了两维) 经过移项化简后得到： 当$j=1$时，$2f[1]-f[2]=last[i] + 3$ 当$j=m$时，$-f[m-1]+2f[m]=last[m]+3$ 当$1&lt;j&lt;m$时，$-f[j-1]+3f[j]-f[j+1]=last[j]+4$ 由于是倒着枚举，所以$last$数组在转移前已经知道了，这就完全是个高斯消元的式子了，用矩阵表示就会变成下面这个样子 $\begin{bmatrix}2\ &amp;-1\ &amp;0\ &amp;0\ &amp;0\-1\ &amp;3\ &amp;-1\ &amp;0\ &amp;0\0 &amp;-1\ &amp;3\ &amp;-1\ &amp; 0\0\ &amp;0\ &amp;-1\ &amp;3\ &amp;-1\0\ &amp;0\ &amp;0\ &amp;-1\ &amp;2\end{bmatrix}$ 用高斯消元显然会T，但是我们发现每行最多只有$3$个非$0$元素,所以我们可以暴力模拟高斯消元求解,最后答案就是$f[x][y]$ 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define mod 1000000007#define ll long longusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;double f[1007][1007],a1[1007],a2[1007],a3[1007],c[1007];//c数组为方程组'='右边的值，a1,a2,a3分别表示一行中三个元素的值，f数组即为转移数组signed main()&#123; int n=read(),m=read(),x=read(),y=read(); if (m==1)&#123; printf("%.10lf",2.0*(n-x)); return 0; &#125; for (int i=n-1;i&gt;=x;--i)&#123; for (int j=1;j&lt;=m;++j)c[j]=f[i+1][j]+4.0; c[1]-=1.0;c[m]-=1.0; a1[1]=0;a2[1]=2.0;a3[1]=-1.0; for (int j=2;j&lt;=m-1;++j)a1[j]=-1,a2[j]=3,a3[j]=-1; a1[m]=-1;a2[m]=2;a3[m]=0; for (int j=2;j&lt;=m;++j)&#123; double z=a1[j]/a2[j-1]; a2[j]-=z*a3[j-1]; c[j]-=c[j-1]*z; &#125; f[i][m]=c[m]/a2[m]; for (int j=m-1;j;--j)f[i][j]=(f[i][j+1]+c[j])/a2[j]; &#125; printf("%.10lf",f[x][y]);&#125;]]></content>
      <tags>
        <tag>概率期望$DP$</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SRM 563 Div1 500 SpellCards]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20SRM%20563%20Div1%20500%20SpellCards%2F</url>
    <content type="text"><![CDATA[$Description$有$n$张符卡排成一个队列，每张符卡有两个属性，等级$l_{i}$和伤害$d_{i}$。你可以做任意次操作，每次操作为以下二者之一： $1$. 把队首的符卡移动到队尾。 $2$. 使用队首的符卡，对敌人造成$d_{i}$点伤害，并丢弃队首的$l_{i}$张符卡（包括你所使用的符卡）。如果队列不足$l_{i}$张符卡那么你不能使用。 求出造成的伤害的总和的最大值。 $1$$\leqslant$$n$$\leqslant$$50,1$$\leqslant$$l_{i}$$\leqslant$$50,1$$\leqslant$$d_{i}$$\leqslant$$10000$ $Solution:$我们可以把原问题简化成在环上操作，这样第一个操作就被简化掉了 设我们选的集合的点的$l_{i}$为$L_{i}$，注意这里集合内的所有的$L_{i}$是可重的，也就是可以覆盖下一个点，例如下图是合法的。 显然我们只需要满足$\sum L_{i}\leqslant$$n$就行了 我们发现一定有一个点没有覆盖下一个点，证明：如果每个点都覆盖了下一个点，那么整个环一定被完全覆盖了，再加上重叠的部分，$\sum L_{i}$不会$\leqslant$$n$，所有一定有一个点没有覆盖下一个点 那么，我们就可以直接用掉这个点$L_{i}$包含的区间，此时$n-=L_{i}$,剩下的$\sum L_{i}$依然满足$\leqslant$$n$，这个点的上一个点就变成了没有覆盖下一个点的点了，就可以一直删，直到删完。 然后我们发现就是一个裸的背包问题 $Code:$123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3fusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int f[60],l[60],d[60];int main()&#123; int n=read(); for (int i=1;i&lt;=n;++i)l[i]=read(); for (int i=1;i&lt;=n;++i)d[i]=read(); for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) f[j]=max(f[j],f[j-l[i]]+d[i]); printf("%d",f[n]); return 0;&#125;]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 bzoj4668冷战]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20bzoj4668%E5%86%B7%E6%88%98%2F</url>
    <content type="text"><![CDATA[bzoj4668: 冷战 并查集按秩合并$+LCA$找最大。 并查集按秩合并：复杂度为$O(nlogn)$，稍劣于路径压缩，但优点在于保留了树形结构，对于每个并查集记录一个值$rank$，初始值为$1$，表示树高，每次将$rank$小的并查集根节点合并到$rank$大的并查集根节点上(即把$f[find(x)]$赋值成$find(y))$，并将$v[x]$赋为$cnt$(即当前是第几次合并)这时$rank$不变，若两个并查集$rank$相同，则将一个合并到另一个,将$v[x]$赋值$,rank[find(y)]++;$ 在$find$函数中，每次在回溯过程中更新每个点的一个值$deep$，表示它的深度$(deep[k]=deep[f[k]]+1;)$ 若$opt=0$，每次用并查集按秩合并两个点. 若$opt=1$，则用暴力求$LCA$的方法从一个点不停的走向它的父亲，直到它的$deep\geqslant$另一个点的$deep$，此时若$deep[x]==deep[y]$,则退出，否则交换$x$与$y$，继续进行上述过程，直到$x==y$，在过程中不断更新$v[x]$的最大值，记录在变量$ans$中，并返回$ans$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define re register #define dd c=getchar()using namespace std;inline int read() &#123;int s=0,w=1;char c;while (dd,c&gt;'9' || c&lt;'0') if (c=='-') w=-1;while (c&gt;='0' &amp;&amp; c&lt;='9') s=s*10+c-'0',dd;return s*w;&#125;#undef ddinline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;int lastans,f[600000],cnt,dep[600000],v[600000],rank[600000];int find(int k)&#123; if (f[k]==k)return k; int o=find(f[k]); dep[k]=dep[f[k]]+1; return o;&#125;void merge(int x,int y,int z)&#123; x=find(x),y=find(y); if (x==y)return; if (rank[x]&gt;rank[y])swap(x,y); if (rank[x]==rank[y])rank[y]++; f[x]=y;v[x]=z;&#125;int lca(int x,int y)&#123; if (find(x)!=find(y))return 0; int ans=0; while (x!=y)&#123; if (dep[x]&lt;dep[y])swap(x,y); ans=max(ans,v[x]); x=f[x]; &#125; return ans;&#125;int main()&#123; freopen("build.in","r",stdin); freopen("build.out","w",stdout); int n=read(),m=read(); for (int i=1;i&lt;=n;++i)f[i]=i,rank[i]=1;//初始化 for (int i=1;i&lt;=m;++i)&#123; int opt=read(),x=read()^lastans,y=read()^lastans; if (opt)&#123; lastans=lca(x,y); wln(lastans); &#125;else&#123; cnt++; merge(x,y,cnt); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>按秩合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF780F 【Axel and Marston in Bitland】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF780F%20%E3%80%90Axel%20and%20Marston%20in%20Bitland%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目要求第$i$个是由第$i-1$个和（第$i-1$个取反）拼在后面。 求最长路。 因此可以用倍增的思想进行$dp$，$dp$思路在代码中。可以用$bitset$优化 最后选取时从长的往短的枚举，在加的过程中大于$1e18$就退出 听说好像可以用矩乘优化，但蒟蒻我不会 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;bitset&lt;505&gt;f[2][65][505],t,pre;//f[p][s][x][y]表示第一条边为p类型，x与y之间有2的s次方的路径存不存在ll ans;int main()&#123; int n=read(),m=read(); while (m--)&#123; int x=read(),y=read(),t=read(); f[t][0][x][y]=1; &#125;// 转移方程:f[p][s][x][y]|=(f[p][s][x][k]&amp;f[p^1][s][k][y]) k为枚举的中转点 //最后一位可以用bitset压掉，即if (f[p][s-1][x][k]) f[p][s][x]|=f[p^1][s-1][k] for (int s=1;s&lt;=60;++s)//s为路径长度是2的多少幂次 for (int p=0;p&lt;=1;++p)//p为第一条边的类型 for (int x=1;x&lt;=n;++x)//x为起点 for (int k=1;k&lt;=n;++k)//k为枚举的中转点 if (f[p][s-1][x][k]) f[p][s][x]|=f[p^1][s-1][k]; for (int i=1;i&lt;=n;++i) if (f[0][60][1][i])&#123; puts("-1");return 0; &#125; int now=0;pre[1]=1;//一开始只有节点1可以作为起点 for (int s=59;s&gt;=0;--s)&#123;// 贪心得选，能选长的就选长的 t.reset(); for (int i=1;i&lt;=n;++i) if (pre[i])//pre数组表示当前可不可以选为起点 t|=f[now][s][i];//t数组表示从当前可选的起点走接下来能到达的点 if (t.count())&#123; pre=t; now^=1; ans+=(1ll&lt;&lt;s); if (ans&gt;1e18)&#123;puts("-1");return 0;&#125; &#125; &#125; printf("%I64d",ans);&#125;]]></content>
      <tags>
        <tag>$DP$</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2444 【[POI2000]病毒】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2444%20%E3%80%90%5BPOI2000%5D%E7%97%85%E6%AF%92%E3%80%91%2F</url>
    <content type="text"><![CDATA[很考验对$fail$指针的理解,假设我们构造出了一个无限长的安全代码，再到$AC$自动机上匹配，从原点出发，向下走遇到一个环，然后不停地在这个环上跳转(无法理解就手玩样例)，且这个环上没有危险节点(即病毒单词最后一个字母在$Trie$树上的位置) 注意：这个环不包括$fail$指针,但是包括优化边(即如果节点$i$的某个字符儿子为空，那么这个儿子存为$i$的$fail$指针指向的节点的相同字符儿子)(有点绕,放张样例构成的$trie$图) 黑边是$trie$树上的正常边，蓝边是在处理$AC$自动机时连上的优化边，红边是$fail$指针。灰色节点即危险节点 这里的环只由蓝边和黑边构成的，即不考虑走$fail$指针， 这样，问题就变成了找一个从根节点出发能在不经过危险节点的情况下走到到的环，且环上没有危险节点。 注意：如果某个点的$fail$指针指向的点是有危险节点，那么该节点也是危险节点 接下来$dfs$找环，找到就输出属于基础图论。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 1000007using namespace std;struct node&#123; int fail,cnt,ch[2];&#125;f[N&gt;&gt;1];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ans,cnt,ok[N],vis[N];char s[N];queue&lt;int&gt;q;inline void build(char *s)&#123; int len=strlen(s),now=0; for (int i=0;i&lt;len;++i)&#123; int v=s[i]-'0'; if (!f[now].ch[v])f[now].ch[v]=++cnt; now=f[now].ch[v]; &#125; f[now].cnt=1;&#125;inline void build_fail()&#123; for (int i=0;i&lt;2;++i)if (f[0].ch[i])q.push(f[0].ch[i]); while (!q.empty())&#123; int u=q.front();q.pop(); for (int i=0;i&lt;2;++i) if (f[u].ch[i])&#123; f[f[u].ch[i]].fail=f[f[u].fail].ch[i]; f[f[u].ch[i]].cnt|=f[f[f[u].fail].ch[i]].cnt; q.push(f[u].ch[i]); &#125;else f[u].ch[i]=f[f[u].fail].ch[i]; &#125;&#125;void dfs(int now)&#123; if (ok[now])&#123;puts("TAK");exit(0);&#125; if (vis[now]||f[now].cnt)return; vis[now]=ok[now]=1; if (f[now].ch[0])dfs(f[now].ch[0]); if (f[now].ch[1])dfs(f[now].ch[1]); ok[now]=0;&#125;signed main()&#123; int n=read(); for (int i=1;i&lt;=n;++i)&#123; scanf("%s",s); build(s); &#125; build_fail(); dfs(0); puts("NIE"); return 0;&#125;]]></content>
      <tags>
        <tag>$AC$自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1155D 【Beautiful Array】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF1155D%20%E3%80%90Beautiful%20Array%E3%80%91%2F</url>
    <content type="text"><![CDATA[$Description$给定一个值$x$,一个长度为$n$的数组$a$，你可以选择一段区间，让这段区间每个数都乘上$x$,求最大连续子段和 $Solution:$三个数组,$f_{i}$表示以$i$结尾的最大子段和,$g_{i}$表示选定区间还未完结($a_{i}$乘上$x$)的最大子段和，$h_{i}$表示已经选定区间已经在$1$~$(i-1)$中一处结尾$(a_{i}$不乘$x)$ $f_{i}=max(f_{i-1},0)+a_{i}$ $g_{i}=max(g_{i-1},f_{i-1},0)+a_{i}\times x$ $h_{i}=max(h_{i-1},g_{i-1},0)+a_{i}$ $ans=max(h_{i},g_{i})$ $Code$12345678910111213141516#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;signed main()&#123; int n=read(),m=read(),ans=0,a,f=0,g=0,h=0; for (int i=1;i&lt;=n;++i) a=read(),h=max(h,max(g,0ll))+a,g=max(g,max(0ll,f))+a*m,f=max(f,0ll)+a,ans=max(ans,max(h,max(f,g))); cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3393 【逃离僵尸岛】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P3393%20%E3%80%90%E9%80%83%E7%A6%BB%E5%83%B5%E5%B0%B8%E5%B2%9B%E3%80%91%2F</url>
    <content type="text"><![CDATA[题意：有$N$个点，$M$条双向边，$K$个被侵略城市，与这$K$个被侵略城市距离$\leqslant$$S$的城市就是危险城市。其他就是安全城市。安全城市的点权就是$P$，危险城市的点权就是$Q$,问才$1$号点到$N$号点的最小花费。 标记危险城市显然需要跑最短路，但是对于$K$个点跑$K$次最短路时间复杂度太高，于是我们建立虚点连接$K$个点，边权为$0$,原先道路边权为$1$,跑最短路即可，这样就可以找到所有危险城市了。 对于点权最短路，我们只需要将到达点的权值设为边权即可，对于到达点是危险城市或是$1$或$N$特判。 记得开$long long$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define int long long#define inf 0x3f3f3f3fusing namespace std;struct node&#123; int to,next,dis;&#125;e[499999];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt,head[400000],dis[300000],inque[300000],tag[300000];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt;&#125;void spfa(int s)&#123; memset(dis,0x3f,sizeof(dis)); memset(inque,0,sizeof(inque)); dis[s]=0;queue&lt;int&gt;q;q.push(s); while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (dis[v]&gt;dis[u]+e[i].dis)&#123; dis[v]=dis[u]+e[i].dis; if (!inque[v])&#123; inque[v]=1;q.push(v); &#125; &#125; &#125; &#125;&#125;signed main()&#123; int n=read(),m=read(),k=read(),s=read(),p=read(),q=read(); for (int i=1;i&lt;=k;++i)&#123; int t=read(); tag[t]=2; add(0,t,0); &#125; for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); add(u,v,1);add(v,u,1); &#125; spfa(0); for (int i=1;i&lt;=n;++i) tag[i]=tag[i]==0?dis[i]&lt;=s:2; for (int i=1;i&lt;=cnt;++i)&#123; if (tag[e[i].to]==2)&#123;e[i].dis=inf;continue;&#125; if (e[i].to==n||e[i].to==1)&#123;e[i].dis=0;continue;&#125; if (tag[e[i].to]==1)&#123;e[i].dis=q;continue;&#125; else e[i].dis=p; &#125; spfa(1); printf("%lld",dis[n]); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3959 【宝藏】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P3959%20%E3%80%90%E5%AE%9D%E8%97%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[在任意时刻，我们关心的只有我们已经把多少点加进树了，以及树的最大树高是多少。 设$f[S][i]$为当前树已经包含集合$S$中的点，并且树高是$i$。 那么怎么判断$S_{0}$在转移中是否合法呢？我们设$G_{S}$是$S$能拓展到的边的集合，显然$G$数组是可以预处理出来的。 $f[S][i]=min(f[S_0][i-1]+pay)$，其中满足$S_{0}$是$S$的子集，通过$S_{0}$加边一定可以联结成$S$。$pay$是这次加边的花费。 设$ss=S~xor~S_{0}$，即$ss$是在$S$但不在$S_{0}$中的元素。 这里$pay$的计算显然是对于每个$ss$中的元素找$S_{0}$中的元素与它最短一条的边求和后$\times $树高(即$i$)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3fusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int cnt,ma[393939],head[393939],f[15][40000],dis[39][39],ans;signed main()&#123; int n=read(),m=read();memset(dis,0x3f,sizeof(dis)); for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),d=read(); dis[v][u]=dis[u][v]=min(dis[v][u],d); &#125; memset(f,0x3f,sizeof(f)); for (re int i=1;i&lt;=n;++i)dis[i][i]=0,f[0][1&lt;&lt;(i-1)]=0; for (re int i=1;i&lt;=(1&lt;&lt;n)-1;++i) for (re int j=1;j&lt;=n;++j) if (i&amp;(1&lt;&lt;(j-1))) for (re int k=1;k&lt;=n;++k) if (dis[j][k]!=inf) ma[i]|=1&lt;&lt;(k-1); for (int s=2;s&lt;=(1&lt;&lt;n)-1;++s) for (re int i=s-1;i;i=s&amp;(i-1)) if ((s|ma[i])==ma[i])&#123; int res=0,st=s^i; for (re int k=1;k&lt;=n;++k) if (st&amp;(1&lt;&lt;(k-1)))&#123; int t=inf; for (re int p=1;p&lt;=n;++p) if (i&amp;(1&lt;&lt;(p-1))) t=min(t,dis[p][k]); res+=t; if (res&gt;inf)break; &#125; if (res&lt;inf) for (re int t=1;t&lt;n;++t) f[t][s]=min(f[t][s],f[t-1][i]+res*t); &#125; ans=inf; for (int i=0;i&lt;n;++i) ans=min(ans,f[i][(1&lt;&lt;n)-1]); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>状压$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1453 【城市环路】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1453%20%E3%80%90%E5%9F%8E%E5%B8%82%E7%8E%AF%E8%B7%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[会了这道题就可以顺便$A$了P2607 [ZJOI2008]骑士 由于只有$n$条边，每个点之间互通，所以图就是一颗基环树 所以只需要$dfs$找环，在环上找任意一条边，枚举这条边的两端中其中一端不选(因为两端不能同时选，所以至少有一端不选)，然后进行树形$dp$即可，由于然后这道题就和没有上司的舞会一样了。 dfs找环：一边走一边用一个$vis$数组标记，回溯时$vis$清零，如果当前点的儿子上有$vis$标记,那么这个点和它的儿子就在环上。 树形$dp$:设$f[u][0/1]$表示u这个节点选$(0)$或不选$(1)$的最大价值（这里$v$表示u的所有子节点) $f[u][1]=\sum f[v][0]$ $f[u][0]=\sum max(f[v][0],f[v][1])$ 答案就是$f[root][0]$,这里的$root$就是枚举的一端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define N 393939*7using namespace std;struct node&#123; int to,next;&#125;e[N&lt;&lt;1];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int now,la,n,ans,cnt,head[N],f[N][2],vis[N],fa[N],v[N];inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa,int rt,int unrt)&#123; f[u][0]=0;f[u][1]=v[u];vis[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa||(u==rt&amp;&amp;v==unrt))continue; if (v!=rt)&#123; dfs(v,u,rt,unrt); f[u][1]+=f[v][0]; f[u][0]+=max(f[v][1],f[v][0]); &#125; &#125;&#125;void dfss(int u,int fa)&#123; vis[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; if (vis[v])&#123;la=v;now=u;return;&#125; dfss(v,u); &#125; vis[u]=0;&#125;void lxy(int u)&#123; now=u,la=0; dfss(u,0); dfs(now,0,now,la); int res=f[now][0]; dfs(la,0,la,now); ans+=max(res,f[la][0]); return;&#125;signed main()&#123; n=read(); for (int i=1;i&lt;=n;++i) v[i]=read(); for (int i=1;i&lt;=n;++i)&#123; int u=read()+1,v=read()+1; add(u,v);add(v,u); &#125; double K; scanf("%lf",&amp;K); for (int i=1;i&lt;=n;++i) if (!vis[i]) lxy(i); double res=1.0*K*ans; printf("%.1lf",res); return 0;&#125;]]></content>
      <tags>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT2164 【Rabbit Exercise】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20AT2164%20%E3%80%90Rabbit%20Exercise%E3%80%91%2F</url>
    <content type="text"><![CDATA[当$k=1$时，$a[i]=\frac{1}{2}[a[i-1]-(a[i]-a[i-1])]+\frac{1}{2}[a[i+1]+(a[i+1]-a[i])]$ 经过化简后$a[i]=a[i+1]+a[i-1]-a[i]$,用差分数组表示就是: $c[i]=a[i]-a[i-1]$ $c[i]=(a[i+1]+a[i-1]-a[i])-a[i-1]$ $c[i]=a[i+1]-a[i]$ $c[i]=c[i+1]$ $c[i+1]=a[i+1]-a[i]$ $c[i+1]=a[i+1]-(a[i+1]+a[i-1]-a[i])$ $c[i+1]=a[i]-a[i-1]$ $c[i+1]=c[i]$ 然后我们发现一次运算就是把$c[i]$与$c[i+1]$交换，于是$k$轮跳转就相当于$k$次交换，然后利用类似快速幂的方法求解 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define mod 1000000007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int a[100007],c[100007],v[100007],t[100007],n;inline void ksm(int p)&#123; while (p)&#123; if (p&amp;1)&#123; for (int i=1;i&lt;=n;++i)t[i]=c[v[i]]; for (int i=1;i&lt;=n;++i)c[i]=t[i]; &#125; for (int i=1;i&lt;=n;++i)t[i]=v[v[i]]; for (int i=1;i&lt;=n;++i)v[i]=t[i]; p&gt;&gt;=1; &#125;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(),c[i]=a[i]-a[i-1],v[i]=i; int m=read(),k=read(); for(int i=1;i&lt;=m;i++)&#123; int x=read(); swap(v[x],v[x+1]); &#125; ksm(k); double sum=0; for (int i=1;i&lt;=n;++i)&#123; sum+=c[i]; printf("%.1lf\n",sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT2364 【Colorful Balls】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20AT2364%20%E3%80%90Colorful%20Balls%E3%80%91%2F</url>
    <content type="text"><![CDATA[显然如果有三个球$a,b,c$,如果$a$与$b$能交换,$b$与$c$能交换，那$a$与$c$一定能通过$b$的“媒介”交换（$a$先于$b$交换，$b$与$c$交换，$a$与$b$交换）。 于是我们可以把$a,b,c$缩在同一个连通块里。 由于不同颜色与相同颜色交换条件是不一样的，我们先考虑相同颜色。 显然只需要用最小值做“媒介”即可。 然后我们考虑跨颜色交换。我们发现只需要用全局最小值做“媒介”，也就是说对于某个点，先通过该颜色最小值换到全局最小值，再通过全局最小值换到其他点。如果与全局最小值颜色相同，那我们就只能用次小值做媒介。 这样我们只需要记录某种颜色的最小值、全局最小值、全局次小值即可。 然后我们不难发现含有不同颜色的连通块只有一个，那就是全局最小值所在的连通块。 而只有一种颜色的连通块对答案没有影响。 于是我们只考虑最小值所在的连通块。首先我们找到全局最小值、全局次小值与每种颜色的最小值。如果他们都不能交换，那显然是凉了（答案为11）。我们对每种颜色数出能与该种颜色最小值交换的点数，然后用每种连通块的最小值与全局最小值（全局次小值）比较，求出这个联通块。我们发现就是求这个联通块排列方案数，其实就是可重集合排列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define int long long#define mod 1000000007#define N 200007using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ksm(int x,int k)&#123; int res=1; while(k)&#123; if(k&amp;1)res=res*x%mod; x=x*x%mod; k&gt;&gt;=1; &#125; return res;&#125;int mn[N],c[N],w[N],cnt[N],jc[N],inv[N],n,A,B,ans;signed main()&#123;// freopen("keep.in", "r", stdin); freopen("keep.out", "w", stdout); n=read(),A=read(),B=read(); memset(mn,0x3f,sizeof(mn)); jc[0]=1; for(int i=1;i&lt;=n;i++)jc[i]=jc[i-1]*i%mod; inv[n]=ksm(jc[n],mod-2); for(int i=n-1;i&gt;=0;i--)inv[i]=inv[i+1]*(i+1)%mod; for (int i=1;i&lt;=n;++i)&#123; c[i]=read(),w[i]=read(); mn[c[i]]=min(mn[c[i]],w[i]);//颜色集合最小值 ++cnt[c[i]];//集合元素个数 &#125; int Mn=1,mnn=inf; for (int i=1;i&lt;=n;++i) if (mn[i]&lt;mn[Mn]) Mn=i;//找出全局最小值的颜色 for (int i=1;i&lt;=n;++i) if (i!=Mn) mnn=min(mn[i],mnn);//找出除全局最小值的集合以外的所有数的最小值 for (int i=1;i&lt;=n;++i)&#123; if (w[i]!=mn[c[i]]&amp;&amp;w[i]+mn[c[i]]&lt;=A)continue;//如果这个值不是所在集合的最小值但它与所在集合的最小值的和小于A，那么它是有意义的 if (c[i]!=Mn&amp;&amp;w[i]+mn[Mn]&lt;=B)continue;//如果这个值不在全局最小值所在的集合中 ，但它与全局最小值的和小于B，那么它是有意义的 if (c[i]==Mn&amp;&amp;w[i]+mnn&lt;=B)continue;//如果它在全局最小值所在的集合中，且它与除全局最小值的集合以外的所有数的最小值的和小于B，那么它是有意义的 --cnt[c[i]];//如果它不符合以上条件，那么它的存在是没有意义的 &#125; int num=cnt[Mn]; for (int i=1;i&lt;=n;++i) if (i!=Mn&amp;&amp;mn[Mn]+mn[i]&lt;=B)//如果这种颜色存在且它不是全局最小值所在的集合 num+=cnt[i]; ans=1; for (int i=1;i&lt;=n;++i) if(mn[i]!=inf&amp;&amp;(i==Mn||mn[i]+mn[Mn]&lt;=B)) ans=ans*inv[cnt[i]]%mod; for (int i=1;i&lt;=num;++i) ans=ans*i%mod;//这里是求有重复元素的排列种数 printf("%lld",ans);&#125;]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1357 花园]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1357%20%E8%8A%B1%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[我们用一个$m$位二进制数表示后$m$个花圃的状态，$1$表示为$M$. 那么令$f[i][j]$表示由状态$i$转移到状态$j$的方案数（$i$和$j$都合法，即1的个数不超过$k$）。($Floyd$矩阵) 所谓转移，是指如果$i$表示第$1$～$m$个花圃的状态，那么$j$代表第$2$～第$m+1$个花圃的状态。 那么怎么求得$f[i][j]$呢？ 枚举一个长度为$m-1$的状态，在它前面加$0/1$即是$i$，在它后面加$0/1$即是$j$，在过程中判断$1$的个数会不会超过$k$即可。 由于是个环，所以实质上有$n+m$个花圃，第$n+1~n+m$个花圃就相当于第$1～m$个花圃，所以我们求的答案就是一个合法状态转移$n$次，转移回原状态的方案数之和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define mod 1000000007using namespace std;int n,m,k,t,o[39+39],ans;struct node&#123; int a[39+39][39+39]; inline void init()&#123; for (int i=0;i&lt;=t;++i) for (int j=0;j&lt;=t;++j) if (i==j) a[i][i]=1; else a[i][j]=0; &#125; inline void init0()&#123;memset(a,0,sizeof(a));&#125; friend node operator * (node a,node b)&#123; node c;c.init0(); for (int i=0;i&lt;=t;++i) for (int k=0;k&lt;=t;++k) for (int j=0;j&lt;=t;++j)&#123; c.a[i][j]+=1ll*a.a[i][k]*b.a[k][j]%mod; if (c.a[i][j]&gt;mod)c.a[i][j]-=mod; &#125; return c; &#125; friend node operator ^ (node a,int p)&#123; node res; res.init(); while(p)&#123; if(p&amp;1) res=res*a; p&gt;&gt;=1; a=a*a; &#125; return res; &#125;&#125;f;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline int count(int x)&#123; int res=0; while (x)&#123; res+=x&amp;1; x&gt;&gt;=1; &#125; return res;&#125;signed main()&#123; n=read(),m=read(),k=read(); t=(1&lt;&lt;m)-1; for (int i=0;i&lt;=t&gt;&gt;1;++i)&#123; int num=count(i); if (num&lt;=k)&#123; o[i]=1,o[i&lt;&lt;1]=1; f.a[i][i&lt;&lt;1]=1; &#125; if (num+1&lt;=k)&#123; o[i|(1&lt;&lt;m-1)]=1,o[i&lt;&lt;1|1]=1; f.a[i][i&lt;&lt;1|1]=1; f.a[i|(1&lt;&lt;m-1)][i&lt;&lt;1]=1; f.a[i|(1&lt;&lt;m-1)][i&lt;&lt;1|1]=1; &#125; &#125; f=f^n; for (int i=0;i&lt;=t;++i) if (o[i]) ans=(ans+f.a[i][i])&gt;=mod?ans+f.a[i][i]-mod:ans+f.a[i][i]; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
        <tag>状压$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF718C 【Sasha and Array】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF718C%20%E3%80%90Sasha%20and%20Array%E3%80%91%2F</url>
    <content type="text"><![CDATA[众所周知，快速求$Fibonacci$第$n$项的方法是用矩阵乘法，即原始矩阵$(21)$$Fibonacci$矩阵^$(n-2)$,所以我们可以想到将$n$加上$k$相当于给$f[n]$乘上$Fibonacci$矩阵^$k$，所以我们可以想到线段树维护矩阵 对于第一个问题：由于矩阵具有分配律，即$a×b+a×c=a×(b+c)$，所以对于一段区间的矩阵可以相加维护。 对于第二个问题，显然将$[l,r]$的矩阵乘上转移矩阵的$x$次方即可。 用线段树维护即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define ls(k) (k&lt;&lt;1)#define rs(k) (k&lt;&lt;1|1)#define mod 1000000007#define getchar() (p1==p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf;using namespace std;struct node&#123; int a[3][3]; inline void init()&#123; a[1][1]=a[2][2]=1;a[1][2]=a[2][1]=0; &#125; inline void init0()&#123; a[1][1]=a[2][2]=a[1][2]=a[2][1]=0; &#125; inline void init1()&#123; a[1][1]=a[2][1]=a[1][2]=1;a[2][2]=0; &#125; friend node operator + (node aa,node bb)&#123; for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=1;j++)&#123; aa.a[i][j]=(aa.a[i][j]+bb.a[i][j]); if (aa.a[i][j]&gt;mod)aa.a[i][j]-=mod; &#125; return aa; &#125; friend node operator * (node a,node b)&#123; node c;c.init0(); for (int i=1;i&lt;=2;++i) for (int k=1;k&lt;=2;++k) for (int j=1;j&lt;=2;++j)&#123; c.a[i][j]+=1ll*a.a[i][k]*b.a[k][j]%mod; if (c.a[i][j]&gt;mod)c.a[i][j]-=mod; &#125; return c; &#125; friend node operator ^ (node a,int p)&#123; node res; res.init(); while(p)&#123; if(p&amp;1) res=res*a; p&gt;&gt;=1; a=a*a; &#125; return res; &#125;&#125;f[100005],p,jz[500005],tag[500005];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;inline bool check(node tag)&#123; return tag.a[1][1]!=1||!tag.a[2][2]!=1||tag.a[1][2]!=0||tag.a[2][1]!=0;&#125;inline void pushup(int k)&#123; jz[k]=jz[ls(k)]+jz[rs(k)];&#125;void build(int k,int l,int r)&#123; tag[k].init(); if (l==r)&#123; jz[k]=f[l]; return; &#125; int mid=l+r&gt;&gt;1; build(ls(k),l,mid); build(rs(k),mid+1,r); pushup(k);&#125;inline void pushdown(int k)&#123; node sq=tag[k]; jz[ls(k)]=sq*jz[ls(k)]; tag[ls(k)]=tag[ls(k)]*sq; jz[rs(k)]=sq*jz[rs(k)]; tag[rs(k)]=tag[rs(k)]*sq; tag[k].init();&#125;void change(int k,int l,int r,int x,int y,node sq)&#123; if (x&lt;=l&amp;&amp;r&lt;=y)&#123; jz[k]=sq*jz[k]; tag[k]=tag[k]*sq; return; &#125; int mid=l+r&gt;&gt;1; if (check(tag[k]))pushdown(k); if (x&lt;=mid)change(ls(k),l,mid,x,y,sq); if (mid&lt;y) change(rs(k),mid+1,r,x,y,sq); pushup(k);&#125;node query(int k,int l,int r,int x,int y)&#123; if (x&lt;=l&amp;&amp;r&lt;=y) return jz[k]; int mid=l+r&gt;&gt;1; if (check(tag[k]))pushdown(k); if (x&lt;=mid&amp;&amp;mid&lt;y) return query(ls(k),l,mid,x,y)+query(rs(k),mid+1,r,x,y); else if (x&lt;=mid)return query(ls(k),l,mid,x,y); else return query(rs(k),mid+1,r,x,y);&#125;signed main()&#123; int n=read(),m=read(); p.init1(); node ttt; ttt.a[1][1]=ttt.a[2][1]=1; for (int i=1;i&lt;=n;++i)&#123; int x=read()-2; if (x==-1)f[i].a[1][1]=1,f[i].a[2][1]=0; else f[i]=(p^x)*ttt; &#125; build(1,1,n); while (m--)&#123; int opt=read(),x=read(),y=read(); if (opt==1)&#123; int d=read(); change(1,1,n,x,y,p^d); &#125;else&#123; node ans=query(1,1,n,x,y); write(ans.a[1][1]);puts(""); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4159 【[SCOI2009]迷路】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P4159%20%E3%80%90%5BSCOI2009%5D%E8%BF%B7%E8%B7%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[首先考虑边权只有$0,1$的情况。这时候只需要$Floyd$矩阵进行矩阵乘法即可，但是这道题的边权并不是$0,1$，那么我们能不能让$Floyd$矩阵中的每个单位存大于$1$的边权，然后矩乘呢？ 不能也就是说在$Floyd$矩阵中每个单位的值只能是$0$或$1$，但是我们发现$2 &lt;= N &lt;= 10$，这意味着我们可以乱搞将每个点都拆开，将这张图转化成边权只有$0,1$的图，这样上面的意义就成立了。 我们发现可以将每个点拆成$9$个点，令有序数对$(i,j)$表示点$i$拆成的第$j$个点，其中第$0$个点是“真”点，其余的是“假”点。 我们可以令 $(i,j)$表示到“真”点$(i,0)$的距离为j的“假”点，只要让$(i,j)$向$(i,j-1)$连一条边权为$1$的边。 而对于原图中的一条$u→v $边权为$w$的边，只要让$(u,0)$向$(v,w−1)$连一条边权为$1$的边。 这样我们就还原了原图中的边，并且将边权都转化成了$0,1$。 而每个$(i,j)$又可以唯一对应一个编号$(i-1)9+j$，因此原矩阵就变成了一个 $9n9n$的矩阵$ f$. 答案就是$f[0][n-9]$即点$1$的真点与点$n$的真点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define mod 2009#define inf 0x3f3f3f3fusing namespace std;char s[400][400];int f[400][400],now[400][400],t[400][400],ans[400][400];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for (int i=1;i&lt;=n;++i) scanf("%s",s[i]+1); for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) if (s[i][j]!='0')&#123; now[(i-1)*9][(j-1)*9+s[i][j]-'0'-1]=1; &#125; for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=8;++j)&#123; now[(i-1)*9+j][(i-1)*9+j-1]=1; &#125; int ttt=m;n*=9; for (int i=0;i&lt;=n;++i)ans[i][i]=1; while (ttt&gt;0)&#123; if (ttt&amp;1)&#123; memset(t,0,sizeof(t)); for (re int i=0;i&lt;=n;++i) for (re int j=0;j&lt;=n;++j) for (re int k=0;k&lt;=n;++k) t[i][j]=(t[i][j]+now[i][k]*ans[k][j])%mod; for (re int i=0;i&lt;=n;++i) for (re int j=0;j&lt;=n;++j) ans[i][j]=t[i][j]; &#125; ttt&gt;&gt;=1; memset(t,0,sizeof(t)); for (re int i=0;i&lt;=n;++i) for (re int j=0;j&lt;=n;++j) for (re int k=0;k&lt;=n;++k) t[i][j]=(t[i][j]+now[i][k]*now[k][j])%mod; for (re int i=0;i&lt;=n;++i) for (re int j=0;j&lt;=n;++j) now[i][j]=t[i][j]; &#125; printf("%d",ans[0][n-9]); return 0;&#125;]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2765 魔术球问题]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2765%20%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我们考虑建图，把每个点拆开，若两个数和为平方数，那么就从编号小的向编号大的连权值为$1$的有向边。那么就把这个问题转换成了最大匹配问题。 然后我们考虑对于一个新的球，如果能找到原来在的一个球能够匹配，那么可以直接匹配，否则就需要新开一根柱子。所以我们从小到大枚举放的球数，每次加入一个球，直到柱子个数超过给定的上限，那么上一次就是能放的最多球数。 对于方案，我们为了方便，在新增一根柱子的时候记录这个需要新柱子的球的编号，其余路径就按网络流跑二分图匹配的路径记录搞一搞即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3fusing namespace std;const int mx=3939;struct node&#123; int to,next,dis;&#125;e[393939];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int num,ans[10000],ttt,res,n,m,s,t,cnt=1,nex[10000],vis[10000],head[10000],cur[10000],dep[10000];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].to=u; e[cnt].dis=0; e[cnt].next=head[v]; head[v]=cnt;&#125;inline bool bfs()&#123; memset(dep,0,sizeof(dep)); queue&lt;int&gt;q;q.push(s); dep[s]=1; while(!q.empty())&#123; int u=q.front();q.pop(); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;!dep[v])&#123; dep[v]=dep[u]+1;// if (v==t)return 1; q.push(v); &#125; &#125; &#125; return dep[t]&gt;0;&#125;int dfs(int u,int mn)&#123; if (u==t)return mn; int used=0,mi; for (int &amp;i=cur[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]==dep[u]+1) if (mi=dfs(v,min(e[i].dis,mn-used)))&#123; e[i].dis-=mi; e[i^1].dis+=mi; used+=mi;if (v!=t)nex[(u-1)%mx+1]=(v-1)%mx+1; if (mn==used)break; &#125; &#125; return used;&#125;int Dinic()&#123; int res=0; while (bfs())&#123; for (int i=s;i&lt;=t;++i)cur[i]=head[i]; res+=dfs(s,inf); &#125; return res;&#125;int main()&#123; n=read(),s=0,t=mx&lt;&lt;1|1; while (ttt&lt;=n)&#123;++num; add(s,num,1);add(num+mx,t,1); for (int i=sqrt(num)+1;i*i-num&lt;num;++i) add(i*i-num,num+mx,1); int k=Dinic(); if (!k)ans[++ttt]=num; &#125; printf("%d\n",num-1); for (int i=1;i&lt;num;++i) if (!vis[i])&#123; int now=i; while (now)&#123; vis[now]=1; printf("%d ",now); now=nex[now]; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>网络流$24$题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF117C Cycle]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF117C%20Cycle%2F</url>
    <content type="text"><![CDATA[题目大意：给定一个竞赛图(有向完全图，从数据保证$map[i][i]=0$，$map[i][j]≠map[j][i]$。可以看出)，找出一个长度为$3$的环。 竞赛图的重要性质： 竞赛图没有自环，没有二元环；若竞赛图存在环，则一定存在三元环。 前半句话浅显易懂，后半句话的意思就是说：竞赛图要么没有环，如果存在一个环大于三元，那么一定存在另一个三元的小环。 简单证明：假设一个竞赛图存在一个$N$元环(大于三元),环上有连续三点$A,B,C$(存在有向边$AB,BC)$ 根据竞赛图的定义，一定存在有向边$CA$或$AC$中的一者。 情况$1:$若存在$CA,$则$A,B,C$构成三元环； 情况$2:$若存在$AC$，不考虑$B$点，剩下的点构成一个$(N-1)$元环。显然，如果一直不存在情况$1$的话，最终也会形成一个三元环。 下面用类似$dfs$的$tanjan$寻找 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std; char s[5005];int n,low[39393],col,flag,in[39393],dfn[39393],st[39393],w[39393],t[39393],tot,vis[39393],top,num;bool a[5005][5005];void Tarjan(int u)&#123; if (flag)return; if (in[u]&amp;&amp;st[top]!=u)&#123; flag=1; while (st[top]!=u)t[++tot]=st[top--]; t[++tot]=u; return; &#125; if (vis[u])return; st[++top]=u;in[u]=vis[u]=1; for (int v=1;v&lt;=n;++v) if (a[u][v]) Tarjan(v); --top; in[u]=0;&#125;int main()&#123; scanf("%d",&amp;n); for (int i=1;i&lt;=n;++i)&#123; scanf("%s",s+1); for (int j=1;j&lt;=n;++j) if (s[j]=='1')a[i][j]=1; &#125; for (int i=1;i&lt;=n;++i) if (!vis[i])Tarjan(i); if (!flag)&#123;puts("-1");return 0;&#125; for (int j=3;j&lt;=tot;++j) if (a[t[1]][t[j]])&#123; printf("%d %d %d\n",t[1],t[j],t[j-1]); return 0; &#125;//如果枚举到j，说明之前有一条j-1到1的有向边，因为如果有1到j-1的有向边，之前程序就该结束了，不可能循环到j printf("%d %d %d\n",t[1],t[tot],t[tot-1]);//单独特判 return 0;&#125;]]></content>
      <tags>
        <tag>竞赛图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SP4318 【MFISH - Catch Fish】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20SP4318%20%E3%80%90MFISH%20-%20Catch%20Fish%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意:一条河分为$n$个段，每个段都有一个给定的鱼的数量$A_i$，现有$m$条船，每条船都有两个值$B_i$与$D_i$,$B_i$表示船必须在$B_i$处落锚，这意味着船必须占据$B_i$这个位置。且船的长度为$D_i$.数据保证$m$条船一定都可以放在河上。(也就是说我们选择时一定每条船都选，因为每条船都放显然是最优的)。求最大捕鱼数。 这道题给人一种贪心的错觉，实际上它是一个$DP$，首先对于每条船求出它左端点能放的最左边和最右边，这个结合代码应该很好理解 接下来就是$DP$了，$f_{j}$表示之前放的所有点的最右端为$j$的最大收益。显然我们可以发现每个$j$唯一对应着一条船，所以我们可以枚举每条船。 $f_{j+d_{i}-1}=max(f_{j+d_{i}-2},f_{j-1}+(sum_{a_{j+d_{i}-1}}-sum_{a_{j}}));$ 在代码实现上还有一些细节需要处理，具体详见代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define ll long long #define inf 0x3f3f3f3fusing namespace std;struct node&#123; int x,y,l,r;&#125;b[393939];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;void write(const int &amp;x)&#123; char ggg[10001];int s=0;int tmp=x; if(tmp==0)&#123;putchar('0');return;&#125;if(tmp&lt;0)&#123;tmp=-tmp;putchar('-');&#125; while(tmp&gt;0)&#123;ggg[s++]=tmp%10+'0';tmp/=10;&#125;while(s&gt;0)&#123;putchar(ggg[--s]);&#125;&#125;inline bool cmp(node a,node b)&#123; return a.x&lt;b.x;&#125;int a[393939],f[393939];signed main()&#123; int n=read(); for (int i=1;i&lt;=n;++i) a[i]=a[i-1]+read(); int m=read(); for (int i=1;i&lt;=m;++i) b[i].x=read(),b[i].y=read(); sort(b+1,b+1+m,cmp); b[0].l=1;b[m+1].x=inf; for (int i=1;i&lt;=m;++i)b[i].l=max(b[i].x-b[i].y+1,b[i-1].l+b[i-1].y); for (int i=1;i&lt;=m;++i)b[i].r=min(b[i+1].x-b[i].y,b[i].x); b[m+1].r=n+1; for (int i=1;i&lt;=n;++i)&#123; for (int j=b[i].l;j&lt;=b[i].r;++j) f[j+b[i].y-1]=max(f[j+b[i].y-1],f[j-1]+a[j+b[i].y-1]-a[j-1]); for (int j=b[i].l+b[i].y-1;j&lt;b[i+1].r;++j)f[j]=max(f[j],f[j-1]); &#125; printf("%d",f[n]);&#125;]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF570E 【Pig and Palindromes】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF570E%20%E3%80%90Pig%20and%20Palindromes%E3%80%91%2F</url>
    <content type="text"><![CDATA[感觉有点像传纸条，传纸条是是维护两个点同时从起点出发，保证步数相同，转移到终点，这道题是一个点从起点，另一个点从终点出发，保证步数相同$f[step][i][j][k][p]$表示走了$step$步，一个点走到$(i,j),$另一个点走到$(k,p)$，但是这样的状态在时空复杂度上都过不去，所以我们要优化，于是我们发现$j$和$p$都可以通过$step$算出来，并且我们可以滚动数组存储$step$这一位，并且在细节处理上这道题还是挺麻烦的12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define base 131#define mod 1000000007#define ll long longusing namespace std;int dx[]=&#123;-1,-1,0,0&#125;,dy[]&#123;1,0,1,0&#125;,f[2][1000][1000];char s[1000][1000];int main()&#123; int n=read(),m=read(); for (int i=1;i&lt;=n;++i) scanf("%s",s[i]+1); if (s[1][1]!=s[n][m])&#123; puts("0"); return 0; &#125; f[1][1][n]=1; int now=1; for (int st=2;st&lt;=(n+m)&gt;&gt;1;++st)&#123; now^=1; memset(f[now],0,sizeof(f[now])); for (int i=1;i&lt;=min(st,n);++i) for (int k=n;k&gt;=max(n-st,i);--k)&#123; int j=st-i+1,p=m-(st-(n-k))+1; if (s[i][j]==s[k][p]) for (int t=0;t&lt;4;++t) f[now][i][k]=(f[now][i][k]+f[now^1][i+dx[t]][k+dy[t]])%mod;//左边的点可以由左与上转移过来，右边的点可以由右与下转移过来 &#125; &#125; ll ans=0; if ((n+m)&amp;1) for (int i=1;i&lt;=n;++i) ans=(ans+f[now][i][i]+f[now][i][i+1])%mod; else for (int i=1;i&lt;=n;++i) ans=(ans+f[now][i][i])%mod;//n与m的奇偶性需要特判 printf("%d",ans);&#125;]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4088 【[USACO18FEB]Slingshot】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P4088%20%E3%80%90%5BUSACO18FEB%5DSlingshot%E3%80%91%2F</url>
    <content type="text"><![CDATA[由于坐标很大，先离散化，然后离线处理询问，然后通过调整枚举顺序与在树状数组的插入位置等处理不同情况，手推一下应该不难理解，情况如下图所示 设$x,y$为弹弓左端点与右端点,$s,t$为查询左端点与右端点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;struct node&#123; int x,y,v,id;&#125;a[200200];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int c[200200],cnt,nm,px[200200],py[200200],ans[100100];inline bool cmp(node a,node b)&#123;return (a.x!=b.x)?a.x&lt;b.x:a.y&lt;b.y;&#125;inline void change(int x,int d)&#123; for (;x&lt;=cnt;x+=x&amp;-x) c[x]=min(c[x],d);&#125;inline int query(int x)&#123; int res=0x3f3f3f3f3f3f3f3f; for (;x;x-=x&amp;-x) res=min(res,c[x]); return res;&#125;signed main()&#123; int n=read(),m=read(); for (int i=1;i&lt;=n;++i)&#123; int x=read(),y=read(),t=read(); a[++cnt]=node&#123;x,y,t,0&#125;; px[cnt]=x;py[cnt]=y; &#125; for (int i=1;i&lt;=m;++i)&#123; int x=read(),y=read(); a[++cnt]=node&#123;x,y,0,i&#125;; px[cnt]=x;py[cnt]=y; ans[i]=abs(y-x); &#125; sort(px+1,px+1+cnt); sort(py+1,py+1+cnt); sort(a+1,a+1+cnt,cmp); nm=unique(px+1,px+1+cnt)-px-1; for (int i=1;i&lt;=cnt;++i)a[i].x=lower_bound(px+1,px+1+nm,a[i].x)-px; nm=unique(py+1,py+1+cnt)-py-1; for (int i=1;i&lt;=cnt;++i)a[i].y=lower_bound(py+1,py+1+nm,a[i].y)-py;//离散化 memset(c,0x3f,sizeof(c)); for (int i=1;i&lt;=cnt;++i) if (!a[i].id) change(a[i].y,-px[a[i].x]-py[a[i].y]+a[i].v); else ans[a[i].id]=min(ans[a[i].id],query(a[i].y)+px[a[i].x]+py[a[i].y]); memset(c,0x3f,sizeof(c)); for (int i=1;i&lt;=cnt;++i) if (!a[i].id) change(cnt-a[i].y+1,-px[a[i].x]+py[a[i].y]+a[i].v); else ans[a[i].id]=min(ans[a[i].id],query(cnt-a[i].y+1)+px[a[i].x]-py[a[i].y]); memset(c,0x3f,sizeof(c)); for (int i=cnt;i;--i) if (!a[i].id) change(a[i].y,px[a[i].x]-py[a[i].y]+a[i].v); else ans[a[i].id]=min(ans[a[i].id],query(a[i].y)-px[a[i].x]+py[a[i].y]); memset(c,0x3f,sizeof(c)); for (int i=cnt;i;--i) if (!a[i].id) change(cnt-a[i].y+1,px[a[i].x]+py[a[i].y]+a[i].v); else ans[a[i].id]=min(ans[a[i].id],query(cnt-a[i].y+1)-px[a[i].x]-py[a[i].y]);//四种情况 for (int i=1;i&lt;=m;++i) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离线</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2602 [ZJOI2010]数字计数]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2602%20%5BZJOI2010%5D%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题意：给定两个正整数$a$和$b$，求在$[a,b]$中的所有整数中，每个数字各出现了多少次。 定义状态$f[i][j][k]$表示以$j$开头的$i$位数$k$出现的次数 状态转移方程 $f[i][j][k]=\sum\limits_{p=0}^{9}f[i-1][p][k]+(10^{i-1}* [j==k])$ (解释：$i$位数除去最高位就是$i-1$位数，所以要加上所以$i-1$位数的出现次数$(\sum\limits_{p=0}^{9}f[i-1][p][k])$，再加上最高位出现的次数$(10^{i-1}* [j==k])$ 求$A$到$B$之间出现的次数即使就$(1$~$B)-(1$~$(A-1))$的次数 $dp$完了后要开始统计了，首先特判$0$的情况，然后计算出这个数的位数$pos$，所以位数比这个数小的都可以统计答案。由于不能有前导$0$，所以最高位要从$1$枚举到$9$，再枚举所有$i$位数，从最高位枚举到最低位，只要小于当前位的都可以统计(注意等于不可以统计)，再统计一下当前位的贡献，最后还要减去前导$0$的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define int long long#define sqr(x) ((x)*(x))using namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int f[30][40][40],ans[300],poow[200];void make(int x,int d)&#123; if (!x)&#123; ans[0]+=d;return;//0单独特判 &#125; int o=x,poos=0; while(o)&#123;++poos;o/=10;&#125;//算出这个数的位数 for (int i=1;i&lt;poos;++i)//位数比这个数小的都可以统计答案 for (int j=1;j&lt;=9;++j)//从1开始循环是因为开头不能为0 for (int k=0;k&lt;=9;++k) ans[k]+=f[i][j][k]*d; for (int i=poos;i&gt;=1;--i)&#123; int now=x/poow[i-1];x%=poow[i-1]; for (int j=0;j&lt;now;++j)&#123;//比当前位小的都要统计答案 for (int k=0;k&lt;=9;++k) ans[k]+=f[i][j][k]*d; &#125; ans[now]+=(x+1)*d;//当前位也要统计答案(x+1)是因为有后面都是0的情况) &#125; for (int i=0;i&lt;=9;++i)ans[i]-=f[poos][0][i]*d;//减去前导0 ans[0]+=d;//0要特殊处理，因为减去前导0时把0一起统计了&#125; signed main()&#123; int a=read(),b=read(); int cnt=13; poow[0]=1;for (int i=1;i&lt;=cnt;++i)poow[i]=poow[i-1]*10;//预处理10的幂次 for (int j=0;j&lt;=9;++j)f[1][j][j]=1; for (int i=2;i&lt;=cnt;++i) for (int j=0;j&lt;=9;++j)&#123; for (int k=0;k&lt;=9;++k) for (int p=0;p&lt;=9;++p) f[i][j][k]+=f[i-1][p][k]; f[i][j][j]+=poow[i-1]; &#125; make(b,1); make(a-1,-1);//类似前缀和 for (int i=0;i&lt;=9;++i) printf("%lld ",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数位$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1345 [USACO5.4]奶牛的电信Telecowmunication]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1345%20%5BUSACO5.4%5D%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication%2F</url>
    <content type="text"><![CDATA[题意：求网络流图中最小割点 一开始题意看成最小割边，把板子改了一下直接交，80(这样都能有80) 我们可以考虑“拆点”，即把一个点拆成两个点，中间连一条边权为1的边。 前一个点作为“入点”，别的点连边连入这里。 后一个点作为“出点”，出去的边从这里出去。 这样，只要我们切断中间那条边，就可以等效于除去这个点 红色的边边权为$1$，黑色的边边权为$inf$。 原点和汇点的内部边权为$inf$，因为显然这两个点不能删除。 题面给的边删除没意义（因为我们要删点），所以也设为$inf$ 网络流建反向边只是为了有”反悔”的机会，确保答案最优，所以在已有反向边时就没有必要建边圈为$0$的反向边了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;struct node&#123; int to,dis,next;&#125;e[400000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int vis,res,cnt=1,head[400000],inque[400000],dep[400000],n,m,s,t;inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; head[u]=cnt;&#125;inline int bfs()&#123; memset(dep,0x3f,sizeof(dep)); memset(inque,0,sizeof(inque)); queue&lt;int&gt;q;q.push(s); dep[s]=0; while (!q.empty())&#123; int u=q.front();q.pop();inque[u]=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]&gt;dep[u]+1)&#123; dep[v]=dep[u]+1; if (v==t)return 1; if (!inque[v])&#123; q.push(v);inque[v]=1; &#125; &#125; &#125; &#125; return dep[t]&lt;0x3f3f3f3f;&#125;int dfs(int u,int mn)&#123; if (u==t) return mn; int mi=0,used=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (e[i].dis&amp;&amp;dep[v]==dep[u]+1)&#123; if (mi=dfs(v,min(mn-used,e[i].dis)))&#123; used+=mi; e[i].dis-=mi; e[i^1].dis+=mi; if (used==mn)break; &#125; &#125; &#125; return used;&#125;inline int Dinic()&#123; int x; while (bfs()) while (x=dfs(s,0x3f3f3f3f))res+=x; return res;&#125;int main()&#123; n=read(),m=read(),s=read()+n,t=read(); for (int i=1;i&lt;=n;++i)add(i,i+n,1),add(i+n,i,0); for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); add(u+n,v,0x3f3f3f3f); add(v+n,u,0x3f3f3f3f); &#125; printf("%d",Dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最小割</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF773DPerishable Roads]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF773DPerishable%20Roads%2F</url>
    <content type="text"><![CDATA[题意：一个$n$个点的完全图，定义$d_x$为生成树上点$x$到根路径上的最小边权。问图$G$的生成树$\sum d_x$最小是多少？ 人性化题意:给出$n$个点的完全图，对于完全图中的每个点$i,i$作为终点时，要使其他每个点到点$i$的“距离”和最小，对于每个点都输出这个最小值。 这里的“距离”是指对于其他每个点，那个点到点$i$路径上的最小值。且对于每个点$i$，计算答案时应保证图内每条边的方向一定。 首先可以发现这个路标建出来是一颗树，对于每一个点的贡献是这个点到终点的路径上的最小值。然后有一个十分机智的想法就是对于所有终点，把所有点都连在最短的边的一端，然后另一端连向终点。 然后这个东西显然是假的 不过我们可以考虑对它进行一些微小的修改让它成为正确的。 考虑这个想法的错误之处在于最短边的一端到终点的距离可能很长，所以我们考虑对这个进行计算，最短边的一边到终点路径显然是一条链。 显然这条链的边权只有单调递增时才有意义，因为任意一个破坏单调性的点都可以跟最短边不连接的一端连接，这样显然会更优。 这个过程有点难理解，也比较难实现，所以我们把这个过程想象成一个连边的过程，一开始最短路的一端直接跟终点连接。如下图 如果要去更新图$1$中的$a$，那么我们必须找到另一个点来松弛它，如图$2$，我们假设$c&lt;b$(因为如果$c&gt;b$,后面最短路操作会更新)，那么这些点的总贡献就变成了$2\times c$(显然)，因为是一条链，所以我们可以就此跑一遍最短路找出终点到最短边的最小总长度。 由于过程中维护最短边两端的点各自的个数，我们先将每条边减去最短边的权值，最后在加上最短边权值$\times (n-1)$ 怎么计算答案呢？我们设那条链上除终点外有$x$个点，那么那棵树上就有$n-1-x$个点，设最小边长度为$minn$，那么答案为$dis[t]+minn*(n-1-x)$。这个$x$很难计算，考虑消去。即计算$dis[t]$前先对所有边权减去一个$minn$，设新链答案为$dis[t]$，那么答案会变成$(dis[t]+minn\times x)+minn\times(n-1-x)$，即$dis[t]+minn\times(n-1)$,于是$x$就消去了。所以我们计算$dis[t]$即可。 因为要求最优解，我们跑最短路求$dis$(定义见上) 。即向终点直接连边，所以赋为终点与最小点的边权。还有一种状态，即是图$2$的情况，考虑那条链上有$3$个点。设加入的为点$j$，那么链的答案可能为最小点到终点的答案加上$j$到终点的答案，即$a[i][j]\times 2$($a$数组为邻接矩阵,$i$是终点) 最后$dijkstra$松弛即可 (模板) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int s,n,a[3005][3005],mn=21000000000000,dis[400000],vis[400000];void dijkstra(int s)&#123; memset(dis,0x3f,sizeof(dis)); for (int i=1;i&lt;=n;++i)&#123; dis[i]=a[s][i]; for (int j=1;j&lt;=n;++j) if (i!=j) dis[i]=min(dis[i],a[i][j]*2); &#125;//边权如此赋值的原因就是上述的图2情况 vis[s]=1; for (int i=1;i&lt;n;++i)&#123; int mn=210000000000000,k=0; for (int j=1;j&lt;=n;++j) if (!vis[j]&amp;&amp;mn&gt;dis[j]) mn=dis[j],k=j; vis[k]=1; for (int j=1;j&lt;=n;++j) if (!vis[j]&amp;&amp;dis[j]&gt;dis[k]+a[k][j]) dis[j]=dis[k]+a[k][j]; &#125;&#125;//不堆优化的dijkstrasigned main()&#123; n=read(); for (int i=1;i&lt;n;++i) for (int j=i+1;j&lt;=n;++j)&#123; a[i][j]=a[j][i]=read(); if (mn&gt;a[i][j])&#123; mn=a[i][j];s=i;//s即最短边靠终点的那个端点 &#125; &#125; for (int i=1;i&lt;n;++i) for (int j=i+1;j&lt;=n;++j) a[i][j]=a[j][i]=a[i][j]-mn; dijkstra(s); for (int i=1;i&lt;=n;++i)printf("%lld ",dis[i]+mn*(n-1));&#125;]]></content>
      <tags>
        <tag>思维题</tag>
        <tag>神仙题</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF538F 【A Heap of Heaps】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20CF538F%20%E3%80%90A%20Heap%20of%20Heaps%E3%80%91%2F</url>
    <content type="text"><![CDATA[神仙题题意：给一个数组建完全$k$叉树，$k$范围$[1,n-1]$，问每个$k$对应的不满足最小堆性质的结点个数 暴力$n^2$肯定要$T$飞，这里先引入几个性质： $1.\frac{n}{1}+\frac{n}{2}+\frac{n}{3}+…+\frac{n}{n-1}+\frac{n}{n}=nlogn$(调和级数) 2.在$i$叉树中，一个节点$j$的儿子的范围一定是一段区间$(j×i-i+2)$~$(j×i+1)$ 接下来是正解，我们发现对于一个节点$x$，它儿子中所有不合法的节点数即是它儿子中权值小于$x$的权值的数量，这显然可以联想到树状数组求逆序对的思想。 先排一遍序，记录下第i小的数在原先序列中的位置。然后从小的数开始处理，小的数后面肯定是大的数，不可能会出现非法节点，然后处理完小的数之后维护树状数组，对小的数对应的权值单点修改$+1$，这样在后面处理大的数的时候询问就会算上这些更新后的权值了。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x) using namespace std;struct node&#123; int a,b;&#125;a[400000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,c[400000],ans[400000];inline bool cmp(node a,node b)&#123; if (a.a!=b.a)return a.a&lt;b.a; else return a.b&lt;b.b;&#125;inline void change(int x)&#123; for (;x&lt;=n;x+=lowbit(x)) ++c[x];&#125;inline int sum(int x)&#123; int res=0; for (;x;x-=lowbit(x)) res+=c[x]; return res;&#125;int main()&#123; n=read(); for (int i=1;i&lt;=n;++i) a[i].a=read(),a[i].b=i; sort(a+1,a+1+n,cmp); for (int i=1;i&lt;=n;++i)&#123; change(a[i].b); for (int j=1;j&lt;n&amp;&amp;a[i].b*j-j+2&lt;=n;++j) ans[j]+=sum(min(n,a[i].b*j+1))-sum(a[i].b*j-j+1); &#125; for (int i=1;i&lt;n;++i)printf("%d ",ans[i]);&#125;]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2986 [USACO10MAR]伟大的奶牛聚集]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2986%20%5BUSACO10MAR%5D%E4%BC%9F%E5%A4%A7%E7%9A%84%E5%A5%B6%E7%89%9B%E8%81%9A%E9%9B%86%2F</url>
    <content type="text"><![CDATA[观察如果已经知道$1$号节点所需的时间 那么，我们可以做如下假设： ① 所有的牛首先到达了$1$号节点 ② $3$号节点以及他子树上的节点都需要退回$1-&gt;3$的路径的长度 ③ 除了$3$号节点以及他子树上的节点都需要前进$1-&gt;3$的路径的长度 通过上面的三条东西，我们就可以从任意一个父节点推出子节点的时间 所以，又是一遍$O(n)$的计算就可以推出最终的答案 $d[v] = d[u] - size[v]\times e[i].w + (n - size[v])*e[i].w;$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define int long long#define sqr(x) ((x)*(x))using namespace std;struct node&#123; int dis,to,next;&#125;e[400000];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int n,m,cnt,ans=2100000000000000,size[300000],dep[400000],f[400000],head[400000],c[400000];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].next=head[u]; e[cnt].dis=d; head[u]=cnt;&#125;void dfs1(int u,int fa)&#123; size[u]=c[u]; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dep[v]=dep[u]+e[i].dis; dfs1(v,u); size[u]+=size[v]; &#125;&#125;void dfs(int u,int fa)&#123; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; f[v]=f[u]+(m-2*size[v])*e[i].dis; ans=min(ans,f[v]); dfs(v,u); &#125;&#125;signed main()&#123; n=read(); for (int i=1;i&lt;=n;++i)c[i]=read(),m+=c[i]; for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(),d=read(); add(u,v,d);add(v,u,d); &#125; dfs1(1,0); for (int i=1;i&lt;=n;++i)f[1]+=dep[i]*c[i]; dfs(1,0); printf("%lld\n",min(ans,f[1])); return 0;&#125;]]></content>
      <tags>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1948 [USACO08JAN]电话线Telephone Lines]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1948%20%5BUSACO08JAN%5D%E7%94%B5%E8%AF%9D%E7%BA%BFTelephone%20Lines%2F</url>
    <content type="text"><![CDATA[二分答案+$spfa$ 题意：求原点$1$到$n$的所有路中的第$k+1$长的路最小。 因为题意中的答案要最小，我们贪心肯定要使$k$次免费的资格用完，那么最划算的方案肯定是拿最长的$k$条路使之免费，然后付第$k+1$长路的长度的钱。。。这样的贪心思路显然是正确的。 我们首先二分第$k+1$长的路的长度(即答案)，然后关键是如何判断正确性。我们考虑简化问题，对于长度小于二分出的答案的线段，因为不需要付价钱，所以可以将其权值看作是$0$;同理，大于二分的值的路径，我们将长度看作$1$(意味着我需要使用$1$次免费的资格)。我们跑一遍$spfa$，看到了$n$点的最短路的长度，如果大于$k$，则不行，缩小$r$范围继续二分;如果小于，则有可能更小，缩小$l$范围继续二分。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;struct node&#123; int dis,to,next; bool operator &lt;(const node &amp;x)const&#123; return x.dis&lt;dis; &#125;&#125;e[400000];int n,m,k,o,head[400000],cnt,dis[400000],vis[400000],u[400000],w[400000],v[400000];inline void add(int u,int v,int d)&#123; e[++cnt].dis=d; e[cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;priority_queue&lt;node&gt;q;bool dijkstra()&#123; memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); dis[1]=0; q.push(node&#123;0,1&#125;); while (!q.empty())&#123; int x=q.top().to;q.pop(); if (vis[x])continue; vis[x]=1; for (int i=head[x];i;i=e[i].next)&#123; int y=e[i].to; if (dis[y]&gt;dis[x]+e[i].dis)&#123; dis[y]=dis[x]+e[i].dis; q.push(node&#123;dis[y],y&#125;); &#125; &#125; &#125; if (dis[n]&gt;k) return 0; else&#123;o=1;return 1;&#125;&#125;int main()&#123; n=read(),m=read(),k=read(); for (int i=1;i&lt;=m;++i) u[i]=read(),v[i]=read(),w[i]=read(); int l=0,r=1000000; while (l&lt;r)&#123; int mid=l+r&gt;&gt;1; memset(head,0,sizeof(head));cnt=0; for (int i=1;i&lt;=m;++i)add(u[i],v[i],mid&lt;w[i]),add(v[i],u[i],mid&lt;w[i]); if (dijkstra())r=mid; else l=mid+1; &#125; if (o)printf("%d\n",l); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2451 [SDOI2005]遗传代码]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2451%20%5BSDOI2005%5D%E9%81%97%E4%BC%A0%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[想法题，如果一个$l$等于一个$r$，那么他们可以抵消成一个，但是洛谷数据好像有锅，当前位置上的$r&gt;l$时，$ans$加上$r-l$，或者当前位置上的$l&lt;r$时，$ans$加上$l-r$，都是对的。(但洛谷上只有$r-l$是对的) 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int ans,l[300000],r[300000];int main()&#123; int n=read(); for (int i=1;i&lt;=n;++i)&#123; ++l[read()]; ++r[read()]; &#125; for (int i=1;i&lt;=1000;++i) if (r[i]&gt;l[i]) ans+=abs(r[i]-l[i]); cout&lt;&lt;ans+n; return 0;&#125;]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5022 旅行]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P5022%20%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[题意：前$60$分图是一棵树，直接暴力$dfs$枚举边，暴力判断,$O(n)$。后$40$分是一颗基环树，暴力删边,再按照前$60$分的方法暴力$dfs$，$O(n^2)$。 但是这样会$T$飞，所以我们要优化 优化$1:$我们发现我们每条边都删一遍完全没必要，只需对那个环上的所有边进行删除操作，用并查集判环即可 优化$2:$我们发现要求字典序最小，所以我们$dfs$时可以进行最优性剪枝，如果前面的编号与当前答案都相同(注意，这个前提很重要)，当前这条边的编号大于答案那么就可以$return$了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int qqq,ttt,n,m,vis[300000],ans[300000],tot,mp[300000][2],tx,ty,p[300000];vector&lt;int&gt;q[30000];void dfs(int u)&#123; vis[u]=1;ans[++tot]=u; for (int i=0;i&lt;q[u].size();++i)&#123; int v=q[u][i]; if (vis[v])continue; dfs(v); &#125; vis[u]=0;&#125;void dfss(int u)&#123; if (ttt)return; vis[u]=1;p[++tot]=u; if (p[tot]&gt;ans[tot]&amp;&amp;!qqq)&#123;ttt=1;return;&#125; if (p[tot]&lt;ans[tot])qqq=1; for (int i=0;i&lt;q[u].size();++i)&#123; int v=q[u][i];if (ttt)return; if (vis[v]||((u==tx&amp;&amp;v==ty)||(u==ty&amp;&amp;v==tx)))continue; dfss(v); &#125;&#125;void cmp_and_change()&#123; if (tot!=n)return; for (int i=1;i&lt;=n;++i)&#123; if (ans[i]&lt;p[i])return; if (ans[i]&gt;p[i])break; &#125; for (int i=1;i&lt;=n;++i)ans[i]=p[i];&#125;int main()&#123; n=read(),m=read(); for (int i=1;i&lt;=m;++i)&#123; int x=read(),y=read(); q[x].push_back(y); q[y].push_back(x); mp[i][0]=x;mp[i][1]=y; &#125; for (int i=1;i&lt;=n;++i)sort(q[i].begin(),q[i].end()); if (m==n-1)&#123; dfs(1); for (int i=1;i&lt;=tot;++i)printf("%d ",ans[i]); &#125;else&#123; memset(ans,0x3f,sizeof(ans)); for (int i=1;i&lt;=m;++i)&#123; memset(vis,0,sizeof(vis));ttt=0;qqq=0; tx=mp[i][0],ty=mp[i][1];tot=0; dfss(1); cmp_and_change(); &#125; for (int i=1;i&lt;=n;++i)write(ans[i]),putchar(' '); &#125;&#125;]]></content>
      <tags>
        <tag>剪枝优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3618 【误会】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P3618%20%E3%80%90%E8%AF%AF%E4%BC%9A%E3%80%91%2F</url>
    <content type="text"><![CDATA[$dp+hash$ 设子串长度为$m$，$f_{i}$表示到子串末尾在原句是第$i$个位置有几种方案，显然对于每个$f_{i}$有三种情况，当原句以$i$结尾的长度为$m$的字符串等于子串$f_{i}=f_{i-1}+f_{i-m}$,即选或不选，否则$f_{i}=f_{i-1}$,只能不选； 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const int p=313;int v=1,T,n,m,a[2000000];ull power[2000000],sum[2000000],f[200000],t;char s1[200000],s2[200000];int main()&#123; scanf("%d",&amp;T); power[0]=1; for (int i=1;i&lt;=100001;i++) power[i]=power[i-1]*p; while (v&lt;=T)&#123; scanf("%s\n%s",s1+1,s2+1); memset(f,0,sizeof(f)); n=strlen(s1+1);m=strlen(s2+1);t=0; for (int i=1;i&lt;=n;i++) sum[i]=sum[i-1]*p+s1[i]-96; for (int i=1;i&lt;=m;i++) t=t*p+s2[i]-96; f[0]=1; for (int i=1;i&lt;=n;i++) if (t==sum[i]-sum[i-m]*power[m]) f[i]=(f[i-1]+f[i-m])%1000000007; else f[i]=f[i-1]; printf("Case #%d: %d\n",v,f[n]); v++; &#125;&#125;]]></content>
      <tags>
        <tag>$hash$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2749 【[USACO5.1]夜空繁星Starry Night】]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2749%20%E3%80%90%5BUSACO5.1%5D%E5%A4%9C%E7%A9%BA%E7%B9%81%E6%98%9FStarry%20Night%E3%80%91%2F</url>
    <content type="text"><![CDATA[难点在于判断图像是否相似，我们采用将每个点之间互相连起来，计算每个点与点之间的距离之和（也可用$hash$、直接写对称旋转函数或八个循环判断），共$\frac{n*(n-1)}{2}$条线段，这种做法的正确性不难证明，当和相同时，每条边长度相等（正确性下面再证），可以将图像看成一个多边形，连接点可以看成将多边形分成许多三角形，根据三角形全等判定条件（$sss$），可以判定每个三角形全等，根据三角形全等推出对应边相等、对应角相等，可证多边形全等当和相等，每条边也相等的证明：三角形将每个格点的边长设为$1$，故每条线段的长度都为整数或一个整数的开方，整数的小数部分为$0$，整数的开根小数部分取值十分有限，使用$long double$可以将出错率大大降低。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int k,tail,tx[200000],ty[200000],n,m,a[300000],b[300000],dx[]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;-1,0,1,-1,1,-1,0,1&#125;;char s[3000][3000],p='a',u[3999];long double t[39];void dfs(int x,int y,char q,char p)&#123;//深搜求联通块（广搜也可） for (int i=0;i&lt;8;i++)&#123;//根据题意是八个方向 int xx=x+dx[i],yy=y+dy[i]; if (xx&lt;1||xx&gt;n||yy&lt;0||yy&gt;=m||s[xx][yy]!=p) continue; tx[++tail]=xx;ty[tail]=yy; s[xx][yy]=q; dfs(xx,yy,q,p); &#125;&#125;void check(int x,int y)&#123; long double res=0; for (int i=1;i&lt;=tail;i++) for (int j=1;j&lt;=tail;j++) res+=sqrt((tx[i]-tx[j])*(tx[i]-tx[j])+(ty[i]-ty[j])*(ty[i]-ty[j]));//计算每个点与点之间的直线距离和 for (int i=1;i&lt;=k;i++) if (abs(res-t[i])&lt;0.00001)&#123;//浮点数的判定相等的方法 p--;char o=s[x][y]; s[x][y]=u[i]; dfs(x,y,u[i],o);//若与前面重复则重新赋值 return; &#125; t[++k]=res;u[k]=p;//不重复则加入数组（也可用map）&#125;int main() &#123;// freopen("star.in", "r", stdin), freopen("star.out", "w", stdout); cin&gt;&gt;m&gt;&gt;n; for (int i=1;i&lt;=n;i++) scanf("%s",s[i]); for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;m;j++) if (s[i][j]=='1')&#123; s[i][j]=p; tx[1]=i;ty[1]=j; tail=1; dfs(i,j,p,'1'); check(i,j); p++; &#125; for (int i=1;i&lt;=n;i++)&#123; for (int j=0;j&lt;m;j++) cout&lt;&lt;s[i][j]; cout&lt;&lt;endl; &#125;&#125;]]></content>
      <tags>
        <tag>奇技淫巧</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2052 [NOI2011]道路修建]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P2052%20%5BNOI2011%5D%E9%81%93%E8%B7%AF%E4%BF%AE%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[题意：给定一棵有$n$个节点的树，树上每条边花费的价格是这条边两侧的点的数量的差的绝对值与这条边长度的积。求这棵树的总花费。 随便选一个点作为根节点(这里选用节点$1$)，我们可以对这棵树进行$dfs$计算出每个点的$size$，然后就知道这条边的贡献为$abs(n-2\times size_{v})\times w_{i}$，其中$v$为这条边的儿子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))struct node&#123; ll dis,to,next;&#125;e[3000000];using namespace std;inline void write(ll x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(ll x) &#123;write(x);puts("");&#125;inline ll read()&#123; ll s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;ll head[3000000],size[3000000],n,ans,cnt;inline void add(ll u,ll v,ll d)&#123; e[++cnt].dis=d; e[cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(ll u,ll fa)&#123; for (ll i=head[u];i;i=e[i].next)&#123; ll v=e[i].to; if (v==fa)continue; dfs(v,u); size[u]+=size[v]; &#125;&#125;void dfs1(ll u,ll fa)&#123; for (ll i=head[u];i;i=e[i].next)&#123; ll v=e[i].to; if (v==fa)continue; ans+=e[i].dis*abs(size[v]*2-n); dfs1(v,u); &#125;&#125;int main()&#123; n=read(); for (ll i=1;i&lt;=n-1;++i)&#123; size[i]=1; ll u=read(),v=read(),d=read(); add(u,v,d);add(v,u,d); &#125;size[n]=1; dfs(1,0); dfs1(1,0); cout&lt;&lt;ans;&#125;]]></content>
      <tags>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1268 树的重量]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1268%20%E6%A0%91%E7%9A%84%E9%87%8D%E9%87%8F%2F</url>
    <content type="text"><![CDATA[由于所有点均为叶子节点，很显然点$3$是从点$1$到点$2$的路径上分叉出来的 设蓝色部分长度为$len$，那么答案就是$g(1,2)+len$。$len$怎么求呢？显然，$len =\frac{g(1,3)+g(2,3)-g(1,2)}{2}$。 $n&gt;3$的情况也同理。枚举$i$，看看点$n$是不是从点$1$~$i$的路径上分叉出来的，求出的最小$len$就是要加到答案里面去的。 如果认为点$4$是从$1$~$2$的路径上分叉出来的，答案就会加上红色部分的长度。但是红色部分长度显然有一部分是多余的。只有认为点$4$是从$1$~$3$的路径上分叉出来的，才能加上正确答案（也就是蓝色部分）。所以对于当前点我们要枚举是从那一条路径中分叉出来的，取最小值。 证明：因为在最小的情况下，不会有任何冲突的地方，这样加点，可以保证时时刻刻没有冲突，而没有冲突的情况下答案是唯一的 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int a[3000][3000],ans;int main()&#123; while (1)&#123; int n=read(); if (!n)return 0; for (int i=1;i&lt;=n;++i) for (int j=i+1;j&lt;=n;++j) a[i][j]=a[j][i]=read(); ans=a[1][2]; for (int i=3;i&lt;=n;++i)&#123; int mn=2100000000; for (int j=2;j&lt;i;++j)&#123; mn=min(mn,(a[1][i]+a[i][j]-a[1][j])/2); &#125; ans+=mn; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1967 货车运输]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%A2%98%E8%A7%A3%20P1967%20%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[题意：$n$个节点，$m$条边，$q$个询问，对于每个询问求图中两点间所有路径中最小边权的最大值 对于一条边，我们可以走另一条最小边权的最大值；比这条边的权值大的路径，所以对于原图，我们只需求最大生成树，然后求$LCA$即可，在倍增求$LCA$的同时算一个数组$w$表示最小边权的最大值； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))struct node1&#123; int dis,to,next;&#125;e[300000];struct node&#123; int u,v,d;&#125;ed[300000];using namespace std;inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int n,m,head[300000],fa[300000],dep[300000],f[300000][22],w[300000][22],cnt,vis[300000];inline void add(int u,int v,int d)&#123; e[++cnt].to=v; e[cnt].dis=d; e[cnt].next=head[u]; head[u]=cnt;&#125;int find(int k)&#123;return fa[k]==k?k:fa[k]=find(fa[k]);&#125;inline bool cmp(node a,node b)&#123;return a.d&gt;b.d;&#125;void Kruskal()&#123; sort(ed+1,ed+1+m,cmp); for (int i=1;i&lt;=n;++i)fa[i]=i; int cnt=0; for (int i=1;i&lt;=m;++i)&#123; if (find(ed[i].u)==find(ed[i].v)) continue; fa[find(ed[i].u)]=find(ed[i].v); add(ed[i].u,ed[i].v,ed[i].d); add(ed[i].v,ed[i].u,ed[i].d); ++cnt; &#125;&#125;inline void deal_lca(int u,int fa)&#123; vis[u]=1; for (int i=1;i&lt;=20;++i) f[u][i]=f[f[u][i-1]][i-1],w[u][i]=min(w[u][i-1],w[f[u][i-1]][i-1]); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (vis[v])continue; dep[v]=dep[u]+1; f[v][0]=u;w[v][0]=e[i].dis; deal_lca(v,u); &#125;&#125;inline int lca(int x,int y)&#123; if (find(x)!=find(y))return -1; int res=2100000000; if (dep[x]&lt;dep[y])swap(x,y); for (int i=20;i&gt;=0;--i)&#123; if (dep[f[x][i]]&gt;=dep[y])res=min(res,w[x][i]),x=f[x][i]; &#125; if (x==y)return res; for (int i=20;i&gt;=0;--i)&#123; if (f[x][i]!=f[y][i]) res=min(res,min(w[x][i],w[y][i])),x=f[x][i],y=f[y][i]; &#125; return min(res,min(w[x][0],w[y][0]));&#125;int main()&#123; n=read(),m=read(); for (int i=1;i&lt;=m;++i) ed[i].u=read(),ed[i].v=read(),ed[i].d=read(); Kruskal(); for (int i=1;i&lt;=n;++i) if (!vis[i])&#123; dep[i]=1; deal_lca(i,0); f[i][0]=i; w[i][0]=2100000000; &#125; for (int i=1;i&lt;=20;++i) for (int j=1;j&lt;=n;++j)&#123; f[j][i]=f[f[j][i-1]][i-1]; w[j][i]=min(w[j][i-1],w[f[j][i-1]][i-1]); &#125; int q=read(); while(q--)&#123; int x=read(),y=read(); wln(lca(x,y)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>$LCA$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF519E A and B and Lecture Rooms]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF519E%20A%20and%20B%20and%20Lecture%20Rooms%2F</url>
    <content type="text"><![CDATA[题意：有棵大小为$n$的树，再给出m次询问，每次询问中包含$A,B$两点，我们要找到离$A,B$两点距离相等的点一共有多少个。 需要对$A,B$之间的距离进行分类讨论： 需要对$A,B$之间的距离进行分类讨论： 一.如果询问的两个点之间的距离为奇数(或者之间的点为偶数)，那么无论怎样，它们之间必然有偶数个点，不可能有点到它们的距离相等。 二.如果询问的两个点之间的距离为偶数时，我们要找到$A,B$之间的中点，这个时候又需要分几个情况 { $1.A,B$两点到他们的$LCA$的距离不相等（包括$A,B$两点中其中一个点为另一个点的$LCA$的情况），那么我们需要找到$A,B$两点所在链上的中点，中点与它不包含所询问点的子树上的点都是满足条件的点 $2.A,B$两点到他们的$LCA$之间距离相等时，满足条件的点的个数即是整棵树的上节点的总数减去$LCA$包含所询问两点的子树的节点个数 } 三.$3.A,B$两点重合时，整颗树上的点到这两个点的距离都可以看做相等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))struct node&#123; int to,next;&#125;e[300000];using namespace std;inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int tot,size[300000],head[300000],cnt,fa[300000],dep[300000],son[300000],top[300000],w[300000],p[3000000];void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs1(int u)&#123; size[u]=1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (fa[u]==v)continue; fa[v]=u;dep[v]=dep[u]+1; dfs1(v); size[u]+=size[v]; if (!son[u]||size[v]&gt;size[son[u]]) son[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp;w[u]=++tot;p[tot]=u; if (son[u])dfs2(son[u],tp); for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa[u]||v==son[u])continue; dfs2(v,v); &#125;&#125;inline int LCA(int x,int y)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&gt;dep[top[y]]) x=fa[top[x]]; else y=fa[top[y]]; &#125; return dep[x]&gt;dep[y]?y:x;&#125;//以上是树剖求LCA板子int find_mid(int x,int y,int lca,int len,int far)&#123; if (dep[x]-dep[lca]&lt;len)&#123; swap(x,y); len=far-len; &#125; while (x!=lca&amp;&amp;len&gt;0)&#123; int net=top[x]; if (w[x]-w[net]+1&lt;=len)len-=w[x]-w[net]+1; else return p[w[x]-len]; x=fa[net]; &#125; return x;&#125;//找mid这里应该用倍增，但是写了一种自己都看不懂的算法qwqint main()&#123; int n=read();int m=n-1; for (int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; dfs1(1); dfs2(1,1); int q=read(); while (q--)&#123; int x=read(),y=read(); int lca=LCA(x,y); int far=(dep[x]+dep[y]-dep[lca]*2); int mid=find_mid(x,y,lca,far/2,far); int midl=find_mid(x,y,lca,far/2-1,far); int midr=find_mid(y,x,lca,far/2-1,far); if (far&amp;1) printf("0\n"); else if (x==y)&#123; printf("%d\n",n); &#125;else if (dep[midl]==dep[midr])&#123; printf("%d\n",n-size[midl]-size[midr]); &#125;else&#123; printf("%d\n",size[mid]-(dep[midl]&gt;dep[midr]?size[midl]:size[midr])); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
        <tag>$LCA$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF700B Connecting Universities]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF700B%20Connecting%20Universities%2F</url>
    <content type="text"><![CDATA[题意：给出一棵树上的$2\times k$个节点，给他们配对，使得他们之间的距离和最大。 显然，如果对于每条边，它被经过的次数越多越好，那么它被经过的次数最多是多少呢，假设在它两侧分别有$x,y$个端点，那么它被经过的次数最多是$min(x,y)$; 所以$ans$就是$\sum min(x,y)$； 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline void write(ll x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(ll x) &#123;write(x);puts("");&#125;struct node&#123; ll to,next;&#125;e[500000];inline ll read()&#123; ll s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;ll n,k,head[500000],cnt,t[500000],b[500000],a[500000],ans;inline void add(ll u,ll v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(ll u,ll fa)&#123; if (b[u])t[u]=1; for (ll i=head[u];i;i=e[i].next)&#123; ll v=e[i].to; if (v==fa)continue; dfs(v,u); t[u]+=t[v]; &#125; ans+=min(t[u],2*k-t[u]);&#125;int main()&#123; n=read(),k=read(); for (ll i=1;i&lt;=2*k;++i) a[i]=read(),b[a[i]]=1;; for (ll i=1;i&lt;=n-1;++i)&#123; ll u=read(),v=read(); add(u,v);add(v,u); &#125; dfs(1,0); cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF746G New Roads]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF746G%20New%20Roads%2F</url>
    <content type="text"><![CDATA[题意：给你$3$个数字$n,t,k;$分别表示一棵树有$n$个点; 这棵树的深度$t$,以及叶子节点的个数$k;$给你树的每层节点个数; 让你画出这么一棵树; 输出它的$n-1$条边; 首先计算这样的树最多与最少能有几个叶子节点，如果$k$不在这个范围内，则输出$-1,return 0;$ 然后我们钦定同一深度的点都指向同一个父亲 这样叶子节点最多，并且计算一下我们需要消除的叶子节点数量$=n-t-k$。 然后从下到上进行调整,每次将当前层节点指向的父亲转移成上一层每个节点(如果当前层节点数大于上一层节点数，则多余的挤在一起)枚举用两个指针，一个指针指向当前层，另一个指针指向上一层，同时$+1$，如果一个指针指向了尽头就跳到上一层，如果消除的叶子节点数$=$我们需要消除的叶子节点数量则退出。 然后输出即可 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int a[300000],mx,mn,tot;int main()&#123; int n=read(),t=read(),k=read(); for (int i=1;i&lt;=t;++i)&#123; a[i]=read(); if (a[i]&gt;a[i-1])mn+=a[i]-a[i-1]; &#125; mx=n-t; if (k&lt;mn||k&gt;mx)&#123; cout&lt;&lt;-1;return 0; &#125; printf("%d\n",n); for (int i=2;i&lt;=a[1]+1;++i)printf("1 %d\n",i);//根节点与其子节点特殊处理 int T=mx-k;tot=a[1]+2;//T为我们需要消除的叶子节点数量，tot为初始指针指向第三层的第一个节点 for (int i=2;i&lt;=t;++i)&#123; int p=min(a[i],a[i-1]),q=0;//p表示当前层可以消除的叶子节点数，q是指针 while (p&amp;&amp;T)&#123; if (q)--T;//第一个点是下一层多余节点的连接处，所以T不能--; --p; printf("%d %d\n",tot+q-a[i-1],tot+q); ++q; &#125; while (q&lt;a[i])&#123; printf("%d %d\n",tot-a[i-1],tot+q); ++q; &#125;//处理多余节点 tot+=a[i];//指针指向下一行 &#125;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF765E Tree Folding]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF765E%20Tree%20Folding%2F</url>
    <content type="text"><![CDATA[题意：给你一棵树，可以把树上父亲相同的两条长度相同的链合并。（如图）问你最后能不能变成一条链，能的话求链的最短长度。 显然如果可以合并，那么合并后长度一定$\leqslant$直径的一半，所以，我们找到直径的中点作为根(若有两个中点则随便选一个) 对于每个点(除根以外)，如果它有两条或以上长度为不同的子节点形成的链，那么这棵树是无法合并的，输出$-1$，否则用一个$set$维护子节点形成的链长度情况，向上个节点传递$set$中链的长度$+1$ 特别的，对于根，因为它没有父亲节点，所以即使它有两条子节点形成的链，也是合法的(但是如果有三条及以上就不合法了)，如果有一条链，返回这条链的长度$+1$，如果有两条链，返回两条链长度之和$+2$； 最后，对于答案，如果$ans$是$2$的倍数，将它不停地除以$2$，直到$ans$是奇数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;struct node&#123; int to,next;&#125;e[700000];inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int cnt,head[500000],dep[400005][3],mx,loc,mid;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa,int t)&#123; dep[u][t]=dep[fa][t]+1; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue; dfs(v,u,t); &#125; if (dep[u][t]&gt;mx)&#123; mx=dep[u][t]; loc=u; &#125;&#125;int dfs1(int u,int fa)&#123; set&lt;int&gt;lxy666; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v!=fa) lxy666.insert(dfs1(v,u)); &#125; if (u==fa)&#123;//根特殊处理 if (!lxy666.size())return 0; else if (lxy666.size()==1)return *lxy666.begin()+1; else if (lxy666.size()==2)return *lxy666.begin()+*--lxy666.end()+2; else&#123; puts("-1");exit(0); &#125; &#125;else&#123; if (!lxy666.size())return 0; else if (lxy666.size()==1)return *lxy666.begin()+1; else&#123; puts("-1");exit(0); &#125; &#125;&#125;int main()&#123; int n=read(); for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; mx=0; dfs(1,0,2); mx=0; dfs(loc,0,1); int len=mx-1;mx=0; dfs(loc,0,0); for (int i=1;i&lt;=n;++i) if (dep[i][1]+dep[i][0]-2==len)&#123; if (abs(dep[i][0]-dep[i][1])==0||abs(dep[i][0]-dep[i][1])==1)&#123; mid=i;break; &#125; &#125;//以上为找直径中点 int ans=dfs1(mid,mid);while(!(ans&amp;1))ans&gt;&gt;=1; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>思维题</tag>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1073F Choosing Two Paths]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF1073F%20Choosing%20Two%20Paths%2F</url>
    <content type="text"><![CDATA[题目大意：有一棵树，从中选取$2$条链，其中任何一条链的端点不能被另一条链包含，求这两条链，使这两条链的公共的点的部分最长，若相同，使得总长度最长。 因为其中任何一条链的端点不能被另一条链包含，所以重合线段的两个端点的度一定$\geqslant3($两条链的端点在这个节点处分开),在一棵树上要求公共部分最长，有点像求树的直径的做法，两遍$dfs$，特殊的是在更新答案时只有这个点度$\geqslant3$时才更新。 这道题还有个要求，在求公共部分最长的情况下还要使总长度最长 那我们就在$u$和$v$的子树中，找离根最远和次远的点即可。 为了保证求出的两个端点的子树中，“离根最远和次远的点到根距离之和”是最长的，所以在dfs的时候若两个点距离根同样远，则根据它们“离根最远和次远的点到根距离之和”的大小来判断即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;struct node1&#123; int to,dis,next;&#125;e[500000],e1[500000];inline void write(int x) &#123;if (x&lt;0) putchar('-'),x=-x;if (x&gt;=10) write(x/10);putchar(x%10|'0');&#125;inline void wln(int x) &#123;write(x);puts("");&#125;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int loc,ans,head[500000],head1[500000],dep[500000],ind[500000],f[500000],g[500000],cnt;struct node&#123; int x,sum; friend bool operator &lt;(node y,node z)&#123; if (z.x!=y.x)return y.x&lt;z.x; return y.sum&lt;z.sum; &#125;&#125;mx;inline void add(int u,int v)&#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; dep[u]=dep[fa]+1;g[u]=f[u]=0;int cnt=0; for (int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if (v==fa)continue;++cnt; dfs(v,u); if (dep[f[v]]&gt;dep[f[u]])&#123; g[u]=f[u]; f[u]=f[v]; &#125;else if (dep[f[v]]&gt;dep[g[u]])&#123; g[u]=f[v]; &#125; &#125; if (!cnt)f[u]=u; if (cnt&gt;1)&#123; node x=&#123;dep[u],dep[f[u]]+dep[g[u]]-dep[u]*2&#125;; if (mx&lt;x)&#123; mx=x; loc=u; &#125; &#125;&#125;int main()&#123; int n=read(); for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); add(u,v);add(v,u); &#125; mx=&#123;0,0&#125;; dfs(1,0); int a1=f[loc],b1=g[loc]; mx=&#123;0,0&#125;; dfs(loc,0); int a2=f[loc],b2=g[loc]; printf("%d %d\n%d %d\n",a1,a2,b1,b2); return 0;&#125;]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1085D Minimum Diameter Tree]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF1085D%20Minimum%20Diameter%20Tree%2F</url>
    <content type="text"><![CDATA[树的直径的两个端点一定是叶子节点(当边权都为正时)，这个结论显然； 将每一条边分成两类，一类为叶子节点连接的边，设为$a$，另一类为没有叶子节点连接的边，设为$b$； 对于b，我们希望每条$b$对直径贡献尽量小，因为两条可能成为直径的边可能同时包含了$b$。所以将所有$b$的值设为$0$； 根据这个结论，我们将所有$s$均摊给每条$a$； 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int cnt,r[300000];int main()&#123; int n=read(),m=read(); for (int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); ++r[u];++r[v]; &#125; for (int i=1;i&lt;=n;++i) if (r[i]==1) ++cnt; printf("%.18lf",2*m*1.0/(cnt*1.0));&#125;]]></content>
      <tags>
        <tag>树相关</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1552 [APIO2012]派遣]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P1552%20%5BAPIO2012%5D%E6%B4%BE%E9%81%A3%2F</url>
    <content type="text"><![CDATA[题意：$n$个点组成一棵树，每个点都有一个领导力和费用，可以让一个点当领导，然后在这个点的子树中选择一些费用之和不超过$m$的点，得到领导的领导力乘选择的点的个数（领导可不被选择）的利润。求利润最大值。 $n\leqslant100000$； 每个点构造一个大根堆，堆里的就是这个点的人。 往父亲那里合并堆，记录堆的大小，费用的总和。 从儿子合并完毕后，在每个节点，不断踢出费用最大的人，直到费用的总和$\leqslant m$这就是这个点的最优方案了。（显然，花费最小的都留下了） 对于每个点，用这个点的领导力乘堆的大小尝试更新答案即可。 注意：和子树合并的时候,$rt[x]=merge(rt[x],rt[y])$注意是$rt[y]$因为这才是$y$的所属堆的入口。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline ll read()&#123; ll s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;ll ans,fa[300000],size[300000],p[300000],sum[300000],v[300000],n,m,dist[300000],f[300000],s[2][309009],c[300000],son[2][300000];ll merge(ll x,ll y)&#123; if (!x||!y)return x|y; if (v[x]&lt;v[y])swap(x,y); s[1][x]=merge(s[1][x],y); if (dist[s[0][x]]&lt;dist[s[1][x]])swap(s[0][x],s[1][x]); dist[x]=dist[s[1][x]]+1; return x;&#125;int main()&#123; n=read(),m=read(); for (ll i=1;i&lt;=n;++i)&#123; fa[i]=read();v[i]=read();p[i]=read(); size[i]=1;sum[i]=v[i];f[i]=i; ans=max(ans,p[i]); &#125; for (ll i=n;i&gt;1;--i)&#123; ll k=fa[i]; f[k]=merge(f[i],f[k]); sum[k]+=sum[i]; size[k]+=size[i]; while (sum[k]&gt;m)&#123; sum[k]-=v[f[k]]; f[k]=merge(s[0][f[k]],s[1][f[k]]); --size[k]; &#125; ans=max(ans,p[k]*size[k]); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF292D 【Connected Components】]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20CF292D%20%E3%80%90Connected%20Components%E3%80%91%2F</url>
    <content type="text"><![CDATA[题意一个无向图，给出$m$条边，有$k$次询问，每次询问将第$l_{i}$到$r_{i}$条边暂时删去，求这时候有多少个连通分量.$N\leqslant500,1\leqslant M,K\leqslant10000$ 每次暴力建边(即建$1$~$(l_{i}-1),(r_{i}+1)$~$m$这些边)，用并查集维护的思路很好想，复杂度为$O(mk)$, 在卡常或是手动$O3$的情况下可以跑过，但并不是最优解。 我们发现很多边重复建了很多次，没有意义，于是我们只需要预处理出$1$~$l_{i}$这些边连起来得到的并查集与$r_{i}$~$n$这些边连起来得到的并查集，将其合并，求出联通快即可。 难点：如何合并？ 我们可以将左边i条边所得的并查集$l_{i}$直接复制到现在一个的并查集$f$中，然后，我们将现在正在处理的并查集中的每个元素和连右边$j$条边的并查集$r_{j}$的元素一一合并，得到一个新的并查集，这个新的并查集中集合的元素就是答案(统计有多少$f_{i}=i$即可)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define ll long long#define sqr(x) ((x)*(x))using namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int f[10005],l[10005][505],r[10005][505],x[10005],y[10005];int find1(int i,int k)&#123; if (l[i][k]==k)return k; else return l[i][k]=find1(i,l[i][k]);&#125;int find2(int i,int k)&#123; if (r[i][k]==k)return k; else return r[i][k]=find2(i,r[i][k]);&#125;int find(int k)&#123; if (f[k]==k)return k; else return f[k]=find(f[k]);&#125;//三个数组的并查集操作int main()&#123; int n=read(),m=read(); for (int j=1;j&lt;=n;++j) l[0][j]=j,r[m+1][j]=j;//预处理 for (int i=1;i&lt;=m;++i)&#123; x[i]=read(),y[i]=read(); for (int j=1;j&lt;=n;++j)l[i][j]=l[i-1][j]; int u=find1(i,x[i]),w=find1(i,y[i]); if (u!=w)l[i][u]=w; &#125; for (int i=m;i;--i)&#123; for (int j=1;j&lt;=n;++j)r[i][j]=r[i+1][j]; int u=find2(i,x[i]),w=find2(i,y[i]); if (u!=w)r[i][u]=w; &#125; int k=read(); for (int i=1;i&lt;=k;++i)&#123; int l1=read(),r1=read(),cnt=0; for (int i=1;i&lt;=n;++i)f[i]=l[l1-1][i];//将l数组[l1-1]数组复制给f数组 for (int j=1;j&lt;=n;++j)f[find(l[l1-1][j])]=find(r[r1+1][j]);//合并两个并查集 for (int j=1;j&lt;=n;++j) if (f[j]==j) ++cnt;//统计答案 printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1972 [SDOI2009]HH的项链]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P1972%20%5BSDOI2009%5DHH%E7%9A%84%E9%A1%B9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[题意概括：给定一个长度为$N$的自然数序列$(N\leqslant500000$,数的范围$0$到$1000000$之间的整数)，有$M$个询问，每个询问两个整数$l,r$表示$l$~$r$区间内有几个不同的数$(M\leqslant500000)$ 这道题我们考虑离线+树状数组。 设$last_{i}$表示$1$~当前枚举到的右端点 这个序列中i这个数最后出现的位置，如果要求$l$~$r$之间不同的数个数，只要求有几个$last_{i}$在$l$~$r$之间即可,因为我们可以将当前不为空的$last_{i}$分成两类，一类为大小在$1$~$(l-1)$中，因为$last_{i}$表示最后出现的位置，所以在$l$之后不可能有$i$这个数，我们将这一类数设为$a$;另一类为大小在$l$~$r$中，由于$last_{i}$的定义，所以$i$这个数一定在$l$~$r$之间，我们将这一类数设为$b$。显然答案就是$b$，所以我们只需要求$sum_{r}-sum_{l-1}$即可(因为$sum_{r}=a+b,sum_{l-1}=a)$。 我们将询问保存下来，设为$b$数组，将$b$数组按照右端点排序，从让$i=1$~$n$枚举右端点，若$i=b[j].r$,则$j++$并统计答案，然后更新$last$数组。 单点修改，区间查询，显然可以用树状数组维护。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long longstruct node&#123; int l,r,num;&#125;b[3000000];using namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int ans[3000000],a[3000000],n,m,last[3000000],c[3000000];inline int lowbit(int x)&#123; return x&amp;(-x);&#125;inline void change(int x,int d)&#123; if (!x)return; for (;x&lt;=n;x+=lowbit(x)) c[x]+=d;&#125;inline int query(int x)&#123; int res=0; for (;x;x-=lowbit(x)) res+=c[x]; return res; &#125;inline bool cmp(node a,node b)&#123; return a.r&lt;b.r;&#125;int main()&#123; n=read(); for (int i=1;i&lt;=n;i++) a[i]=read(); m=read(); for (int i=1;i&lt;=m;i++) b[i].l=read(),b[i].r=read(),b[i].num=i; sort(b+1,b+1+m,cmp); int t=1; for (int i=1;i&lt;=n;i++)&#123; change(i,1); change(last[a[i]],-1); while (b[t].r==i)&#123; ans[b[t].num]=query(b[t].r)-query(b[t].l-1); t++; &#125; last[a[i]]=i; &#125; for (int i=1;i&lt;=m;i++) printf("%d\n",ans[i]);&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1550 [USACO08OCT]打井Watering Hole]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P1550%20%5BUSACO08OCT%5D%E6%89%93%E4%BA%95Watering%20Hole%2F</url>
    <content type="text"><![CDATA[做法最小生成树很容易发现，但是难点在于想单独打井，设一个源点$0$，把每个井与$0$连边，费用就是打井所需费用 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int u,v,d;&#125;a[3000000];int cnt,x,n,m,ed,ans,f[400000];bool cmp(node a,node b)&#123; return a.d&lt;b.d;&#125;int find(int k)&#123; return (f[k]==k)?k:(f[k]=find(f[k]));&#125;void bing(int x,int y,int d)&#123; int u=find(x),v=find(y); if (u==v)return; f[u]=v; ans+=d; ++ed;&#125;int main()&#123; scanf("%d",&amp;n); for (int i=1;i&lt;=300000;i++)f[i]=i; for (int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); a[++cnt].v=i;a[cnt].d=x; &#125; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++)&#123; scanf("%d",&amp;x); if (j&lt;i) a[++cnt].u=j,a[cnt].v=i,a[cnt].d=x; &#125; sort(a+1,a+1+cnt,cmp); for (int i=1;i&lt;=cnt&amp;&amp;ed&lt;=2*n+1;i++) bing(a[i].u,a[i].v,a[i].d); printf("%d",ans);&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2921 【[USACO08DEC]在农场万圣节Trick or Treat on the Farm】]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P2921%20%E3%80%90%5BUSACO08DEC%5D%E5%9C%A8%E5%86%9C%E5%9C%BA%E4%B8%87%E5%9C%A3%E8%8A%82Trick%20or%20Treat%20on%20the%20Farm%E3%80%91%2F</url>
    <content type="text"><![CDATA[发现巨佬们都用$Tarjan$，但是蒟蒻我用了并查集写这道题，这道题很像P2661，那道题用带权并查集求有向图中的最小环，这道题要求的是每个点在有向图中的环的长度或进入环之前经过的点数与环的长度的和。由于并查集经过路径压缩后只能存储它祖先的信息，所以我们开一个$fa$数组记录它的父亲。判断环我们只需判断读入的$a_{i}$与$i$是否祖先节点相同，那么就可以判断是否能构成一个环。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;//快读int ans[300000],f[300000],fa[3000000];int find(int k)&#123; if (f[k]==k)return k; else return f[k]=find(f[k]);&#125;//并查集int main()&#123; int n=read(); for (int i=1;i&lt;=200000;i++)f[i]=i,fa[i]=1;//初始化 for (int i=1;i&lt;=n;i++)&#123; int x=read(); if (find(x)==find(i))&#123;//如果构成环 int res=1; for (int j=x;j!=i;j=fa[j]) res++;//从x-&gt;x的父亲--&gt;……直到回到i，其中i~x这条边没算，所以res初值赋为1 for (int j=x;j!=i;j=fa[j]) ans[j]=res;//给环中的每个节点的答案赋值 ans[i]=res;//i这个点刚刚没赋值 &#125;else&#123; f[find(i)]=find(x); fa[i]=x; &#125; &#125;//由于i一定是第一次赋值，所以find(i)一定等于i，所以这个循环中的find(i)都可以写成i for (int i=1;i&lt;=n;i++) if (ans[i]==0)&#123; int res=1,j; for (j=fa[i];ans[j]==0;j=fa[j]) res++; ans[i]=res+ans[j]; &#125;//特别处理自身不在环中的点，计算进入环之前经过的点数与环的长度的和 for (int i=1;i&lt;=n;i++) printf("%d\n",ans[i]);&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4870 【[BalticOI 20A09 Day1]甲虫】]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P4870%20%E3%80%90%5BBalticOI%202009%20Day1%5D%E7%94%B2%E8%99%AB%E3%80%91%2F</url>
    <content type="text"><![CDATA[这道题应该一眼就能看出是区间$DP$，但是关键在于怎么写,我们用$f[i][j][0/1]$表示取完$i$~$j$之间的露水，停在$i$或$j$浪费的水分,因为露水水分不可能为负数，而走到后来可能行走路程$&gt;m$，使得计算出的水分为负，所以我们要枚举取的总的露水数$p$（注意不是水分数）于是我们可以列出状态转移方程： $f[i][j][0]=min(f[i+1][j][0]+(p-len+1)\times(a[i+1]-a[i]),f[i+1][j][1]+(p-len+1)\times(a[j]-a[i]));$ $f[i][j][1]=min(f[i][j-1][1]+(p-len+1)\times(a[j]-a[j-1]),f[i][j-1][0]+(p-len+1)\times(a[j]-a[i]));$ $len$为$j-i+1$，即当前采集的露水数 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;int n,m,a[4000],f[400][400][2],t[400][400][2],ans;int main()&#123;// freopen("water.in","r",stdin);// freopen("water.out","w",stdout); n=read();m=read(); for (int i=1;i&lt;=n;i++) a[i]=read(); a[++n]=0;//由于从0出发，故添加一个点为0 sort(a+1,a+1+n);//排序应该不难理解 int z=lower_bound(a+1,a+1+n,0)-a;//找出排序后0在的位置 for (int p=1;p&lt;=n;p++)&#123;//枚举p memset(f,0x3f,sizeof(f)); f[z][z][0]=0;f[z][z][1]=0;//初始化 for (int len=2;len&lt;=p;len++) for (int i=1;i&lt;=n-len+1;i++)&#123; int j=i+len-1; f[i][j][0]=min(f[i+1][j][0]+(p-len+1)*(a[i+1]-a[i]),f[i+1][j][1]+(p-len+1)*(a[j]-a[i])); f[i][j][1]=min(f[i][j-1][1]+(p-len+1)*(a[j]-a[j-1]),f[i][j-1][0]+(p-len+1)*(a[j]-a[i]));//状态转移方程 ans=max(ans,(len-1)*m-min(f[i][j][1],f[i][j][0]));统计答案 &#125; &#125; cout&lt;&lt;ans;&#125;]]></content>
      <tags>
        <tag>区间$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4085 【[USACO17DEC]Haybale Feast】]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%A2%98%E8%A7%A3%20P4085%20%E3%80%90%5BUSACO17DEC%5DHaybale%20Feast%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到题解里巨佬们都写线段树、树状数组、ST表、分块、堆……等数据结构，但是复杂度都至少是$nlogn$的，于是我写了个尺取法+单调队列的方法，时间复杂度$O(n)$ 单调队列维护区间中$si$~$sj$的最大值,这里运用到了一点贪心策略，如果两个区间有包含关系，那么大的区间最大值一定$\geqslant$小的区间最大值，所以对于每一个$i$，我们去前面找第一个$head$，使$sum_{i,j}\geqslant m$ 如图所示，我们选择$5$作为$head$而不是前面的$11$、$2$、$3$、$4$，是因为区间更长，就像在一个数列中加入了另一些数，另一些数中可能有大于原数列的最大值，因为要求最大值的最小值，故不是最优。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;//快读int a[300000],b[300000],p[300000],head=1,head1=1,tail1=0,ans=2100000000;ll sum,m;inline ll Min(int a,int b)&#123; if (a&gt;b)return b; else return a;&#125;int main()&#123; int n=read(); scanf("%lld",&amp;m); for (int i=1;i&lt;=n;i++) a[i]=read(),b[i]=read(); for (int i=1;i&lt;=n;i++)&#123; sum+=a[i]; while (head&lt;=i&amp;&amp;sum-a[head]&gt;=m)&#123; sum-=a[head];head++;//这里注意要先减再head++，尺取法与单调队列在这里都容易出错 &#125; while (head1&lt;=tail1&amp;&amp;p[head1]&lt;head) head1++;//若队首位置小于区间左端，则出队 while (head1&lt;=tail1&amp;&amp;b[i]&gt;=b[p[tail1]]) tail1--;//若新加入的数大于队尾，则队尾出队 p[++tail1]=i;//放入队列 if (sum&gt;=m)ans=Min(ans,b[p[head1]]); &#125; printf("%lld",ans);&#125;]]></content>
      <tags>
        <tag>尺取法</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
</search>
